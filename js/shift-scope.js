(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
window.scope = require("shift-scope");

},{"shift-scope":9}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by src/generate.js.

/**
 * Copyright 2016 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var ArrayAssignmentTarget = exports.ArrayAssignmentTarget = function ArrayAssignmentTarget(_ref) {
  var elements = _ref.elements;
  var rest = _ref.rest;

  _classCallCheck(this, ArrayAssignmentTarget);

  this.type = 'ArrayAssignmentTarget';
  this.elements = elements;
  this.rest = rest;
};

var ArrayBinding = exports.ArrayBinding = function ArrayBinding(_ref2) {
  var elements = _ref2.elements;
  var rest = _ref2.rest;

  _classCallCheck(this, ArrayBinding);

  this.type = 'ArrayBinding';
  this.elements = elements;
  this.rest = rest;
};

var ArrayExpression = exports.ArrayExpression = function ArrayExpression(_ref3) {
  var elements = _ref3.elements;

  _classCallCheck(this, ArrayExpression);

  this.type = 'ArrayExpression';
  this.elements = elements;
};

var ArrowExpression = exports.ArrowExpression = function ArrowExpression(_ref4) {
  var params = _ref4.params;
  var body = _ref4.body;

  _classCallCheck(this, ArrowExpression);

  this.type = 'ArrowExpression';
  this.params = params;
  this.body = body;
};

var AssignmentExpression = exports.AssignmentExpression = function AssignmentExpression(_ref5) {
  var binding = _ref5.binding;
  var expression = _ref5.expression;

  _classCallCheck(this, AssignmentExpression);

  this.type = 'AssignmentExpression';
  this.binding = binding;
  this.expression = expression;
};

var AssignmentTargetIdentifier = exports.AssignmentTargetIdentifier = function AssignmentTargetIdentifier(_ref6) {
  var name = _ref6.name;

  _classCallCheck(this, AssignmentTargetIdentifier);

  this.type = 'AssignmentTargetIdentifier';
  this.name = name;
};

var AssignmentTargetPropertyIdentifier = exports.AssignmentTargetPropertyIdentifier = function AssignmentTargetPropertyIdentifier(_ref7) {
  var binding = _ref7.binding;
  var init = _ref7.init;

  _classCallCheck(this, AssignmentTargetPropertyIdentifier);

  this.type = 'AssignmentTargetPropertyIdentifier';
  this.binding = binding;
  this.init = init;
};

var AssignmentTargetPropertyProperty = exports.AssignmentTargetPropertyProperty = function AssignmentTargetPropertyProperty(_ref8) {
  var name = _ref8.name;
  var binding = _ref8.binding;

  _classCallCheck(this, AssignmentTargetPropertyProperty);

  this.type = 'AssignmentTargetPropertyProperty';
  this.name = name;
  this.binding = binding;
};

var AssignmentTargetWithDefault = exports.AssignmentTargetWithDefault = function AssignmentTargetWithDefault(_ref9) {
  var binding = _ref9.binding;
  var init = _ref9.init;

  _classCallCheck(this, AssignmentTargetWithDefault);

  this.type = 'AssignmentTargetWithDefault';
  this.binding = binding;
  this.init = init;
};

var BinaryExpression = exports.BinaryExpression = function BinaryExpression(_ref10) {
  var left = _ref10.left;
  var operator = _ref10.operator;
  var right = _ref10.right;

  _classCallCheck(this, BinaryExpression);

  this.type = 'BinaryExpression';
  this.left = left;
  this.operator = operator;
  this.right = right;
};

var BindingIdentifier = exports.BindingIdentifier = function BindingIdentifier(_ref11) {
  var name = _ref11.name;

  _classCallCheck(this, BindingIdentifier);

  this.type = 'BindingIdentifier';
  this.name = name;
};

var BindingPropertyIdentifier = exports.BindingPropertyIdentifier = function BindingPropertyIdentifier(_ref12) {
  var binding = _ref12.binding;
  var init = _ref12.init;

  _classCallCheck(this, BindingPropertyIdentifier);

  this.type = 'BindingPropertyIdentifier';
  this.binding = binding;
  this.init = init;
};

var BindingPropertyProperty = exports.BindingPropertyProperty = function BindingPropertyProperty(_ref13) {
  var name = _ref13.name;
  var binding = _ref13.binding;

  _classCallCheck(this, BindingPropertyProperty);

  this.type = 'BindingPropertyProperty';
  this.name = name;
  this.binding = binding;
};

var BindingWithDefault = exports.BindingWithDefault = function BindingWithDefault(_ref14) {
  var binding = _ref14.binding;
  var init = _ref14.init;

  _classCallCheck(this, BindingWithDefault);

  this.type = 'BindingWithDefault';
  this.binding = binding;
  this.init = init;
};

var Block = exports.Block = function Block(_ref15) {
  var statements = _ref15.statements;

  _classCallCheck(this, Block);

  this.type = 'Block';
  this.statements = statements;
};

var BlockStatement = exports.BlockStatement = function BlockStatement(_ref16) {
  var block = _ref16.block;

  _classCallCheck(this, BlockStatement);

  this.type = 'BlockStatement';
  this.block = block;
};

var BreakStatement = exports.BreakStatement = function BreakStatement(_ref17) {
  var label = _ref17.label;

  _classCallCheck(this, BreakStatement);

  this.type = 'BreakStatement';
  this.label = label;
};

var CallExpression = exports.CallExpression = function CallExpression(_ref18) {
  var callee = _ref18.callee;
  var _arguments = _ref18.arguments;

  _classCallCheck(this, CallExpression);

  this.type = 'CallExpression';
  this.callee = callee;
  this.arguments = _arguments;
};

var CatchClause = exports.CatchClause = function CatchClause(_ref19) {
  var binding = _ref19.binding;
  var body = _ref19.body;

  _classCallCheck(this, CatchClause);

  this.type = 'CatchClause';
  this.binding = binding;
  this.body = body;
};

var ClassDeclaration = exports.ClassDeclaration = function ClassDeclaration(_ref20) {
  var name = _ref20.name;
  var _super = _ref20.super;
  var elements = _ref20.elements;

  _classCallCheck(this, ClassDeclaration);

  this.type = 'ClassDeclaration';
  this.name = name;
  this.super = _super;
  this.elements = elements;
};

var ClassElement = exports.ClassElement = function ClassElement(_ref21) {
  var isStatic = _ref21.isStatic;
  var method = _ref21.method;

  _classCallCheck(this, ClassElement);

  this.type = 'ClassElement';
  this.isStatic = isStatic;
  this.method = method;
};

var ClassExpression = exports.ClassExpression = function ClassExpression(_ref22) {
  var name = _ref22.name;
  var _super = _ref22.super;
  var elements = _ref22.elements;

  _classCallCheck(this, ClassExpression);

  this.type = 'ClassExpression';
  this.name = name;
  this.super = _super;
  this.elements = elements;
};

var CompoundAssignmentExpression = exports.CompoundAssignmentExpression = function CompoundAssignmentExpression(_ref23) {
  var binding = _ref23.binding;
  var operator = _ref23.operator;
  var expression = _ref23.expression;

  _classCallCheck(this, CompoundAssignmentExpression);

  this.type = 'CompoundAssignmentExpression';
  this.binding = binding;
  this.operator = operator;
  this.expression = expression;
};

var ComputedMemberAssignmentTarget = exports.ComputedMemberAssignmentTarget = function ComputedMemberAssignmentTarget(_ref24) {
  var object = _ref24.object;
  var expression = _ref24.expression;

  _classCallCheck(this, ComputedMemberAssignmentTarget);

  this.type = 'ComputedMemberAssignmentTarget';
  this.object = object;
  this.expression = expression;
};

var ComputedMemberExpression = exports.ComputedMemberExpression = function ComputedMemberExpression(_ref25) {
  var object = _ref25.object;
  var expression = _ref25.expression;

  _classCallCheck(this, ComputedMemberExpression);

  this.type = 'ComputedMemberExpression';
  this.object = object;
  this.expression = expression;
};

var ComputedPropertyName = exports.ComputedPropertyName = function ComputedPropertyName(_ref26) {
  var expression = _ref26.expression;

  _classCallCheck(this, ComputedPropertyName);

  this.type = 'ComputedPropertyName';
  this.expression = expression;
};

var ConditionalExpression = exports.ConditionalExpression = function ConditionalExpression(_ref27) {
  var test = _ref27.test;
  var consequent = _ref27.consequent;
  var alternate = _ref27.alternate;

  _classCallCheck(this, ConditionalExpression);

  this.type = 'ConditionalExpression';
  this.test = test;
  this.consequent = consequent;
  this.alternate = alternate;
};

var ContinueStatement = exports.ContinueStatement = function ContinueStatement(_ref28) {
  var label = _ref28.label;

  _classCallCheck(this, ContinueStatement);

  this.type = 'ContinueStatement';
  this.label = label;
};

var DataProperty = exports.DataProperty = function DataProperty(_ref29) {
  var name = _ref29.name;
  var expression = _ref29.expression;

  _classCallCheck(this, DataProperty);

  this.type = 'DataProperty';
  this.name = name;
  this.expression = expression;
};

var DebuggerStatement = exports.DebuggerStatement = function DebuggerStatement() {
  _classCallCheck(this, DebuggerStatement);

  this.type = 'DebuggerStatement';
};

var Directive = exports.Directive = function Directive(_ref30) {
  var rawValue = _ref30.rawValue;

  _classCallCheck(this, Directive);

  this.type = 'Directive';
  this.rawValue = rawValue;
};

var DoWhileStatement = exports.DoWhileStatement = function DoWhileStatement(_ref31) {
  var body = _ref31.body;
  var test = _ref31.test;

  _classCallCheck(this, DoWhileStatement);

  this.type = 'DoWhileStatement';
  this.body = body;
  this.test = test;
};

var EmptyStatement = exports.EmptyStatement = function EmptyStatement() {
  _classCallCheck(this, EmptyStatement);

  this.type = 'EmptyStatement';
};

var Export = exports.Export = function Export(_ref32) {
  var declaration = _ref32.declaration;

  _classCallCheck(this, Export);

  this.type = 'Export';
  this.declaration = declaration;
};

var ExportAllFrom = exports.ExportAllFrom = function ExportAllFrom(_ref33) {
  var moduleSpecifier = _ref33.moduleSpecifier;

  _classCallCheck(this, ExportAllFrom);

  this.type = 'ExportAllFrom';
  this.moduleSpecifier = moduleSpecifier;
};

var ExportDefault = exports.ExportDefault = function ExportDefault(_ref34) {
  var body = _ref34.body;

  _classCallCheck(this, ExportDefault);

  this.type = 'ExportDefault';
  this.body = body;
};

var ExportFrom = exports.ExportFrom = function ExportFrom(_ref35) {
  var namedExports = _ref35.namedExports;
  var moduleSpecifier = _ref35.moduleSpecifier;

  _classCallCheck(this, ExportFrom);

  this.type = 'ExportFrom';
  this.namedExports = namedExports;
  this.moduleSpecifier = moduleSpecifier;
};

var ExportFromSpecifier = exports.ExportFromSpecifier = function ExportFromSpecifier(_ref36) {
  var name = _ref36.name;
  var exportedName = _ref36.exportedName;

  _classCallCheck(this, ExportFromSpecifier);

  this.type = 'ExportFromSpecifier';
  this.name = name;
  this.exportedName = exportedName;
};

var ExportLocalSpecifier = exports.ExportLocalSpecifier = function ExportLocalSpecifier(_ref37) {
  var name = _ref37.name;
  var exportedName = _ref37.exportedName;

  _classCallCheck(this, ExportLocalSpecifier);

  this.type = 'ExportLocalSpecifier';
  this.name = name;
  this.exportedName = exportedName;
};

var ExportLocals = exports.ExportLocals = function ExportLocals(_ref38) {
  var namedExports = _ref38.namedExports;

  _classCallCheck(this, ExportLocals);

  this.type = 'ExportLocals';
  this.namedExports = namedExports;
};

var ExpressionStatement = exports.ExpressionStatement = function ExpressionStatement(_ref39) {
  var expression = _ref39.expression;

  _classCallCheck(this, ExpressionStatement);

  this.type = 'ExpressionStatement';
  this.expression = expression;
};

var ForInStatement = exports.ForInStatement = function ForInStatement(_ref40) {
  var left = _ref40.left;
  var right = _ref40.right;
  var body = _ref40.body;

  _classCallCheck(this, ForInStatement);

  this.type = 'ForInStatement';
  this.left = left;
  this.right = right;
  this.body = body;
};

var ForOfStatement = exports.ForOfStatement = function ForOfStatement(_ref41) {
  var left = _ref41.left;
  var right = _ref41.right;
  var body = _ref41.body;

  _classCallCheck(this, ForOfStatement);

  this.type = 'ForOfStatement';
  this.left = left;
  this.right = right;
  this.body = body;
};

var ForStatement = exports.ForStatement = function ForStatement(_ref42) {
  var init = _ref42.init;
  var test = _ref42.test;
  var update = _ref42.update;
  var body = _ref42.body;

  _classCallCheck(this, ForStatement);

  this.type = 'ForStatement';
  this.init = init;
  this.test = test;
  this.update = update;
  this.body = body;
};

var FormalParameters = exports.FormalParameters = function FormalParameters(_ref43) {
  var items = _ref43.items;
  var rest = _ref43.rest;

  _classCallCheck(this, FormalParameters);

  this.type = 'FormalParameters';
  this.items = items;
  this.rest = rest;
};

var FunctionBody = exports.FunctionBody = function FunctionBody(_ref44) {
  var directives = _ref44.directives;
  var statements = _ref44.statements;

  _classCallCheck(this, FunctionBody);

  this.type = 'FunctionBody';
  this.directives = directives;
  this.statements = statements;
};

var FunctionDeclaration = exports.FunctionDeclaration = function FunctionDeclaration(_ref45) {
  var isGenerator = _ref45.isGenerator;
  var name = _ref45.name;
  var params = _ref45.params;
  var body = _ref45.body;

  _classCallCheck(this, FunctionDeclaration);

  this.type = 'FunctionDeclaration';
  this.isGenerator = isGenerator;
  this.name = name;
  this.params = params;
  this.body = body;
};

var FunctionExpression = exports.FunctionExpression = function FunctionExpression(_ref46) {
  var isGenerator = _ref46.isGenerator;
  var name = _ref46.name;
  var params = _ref46.params;
  var body = _ref46.body;

  _classCallCheck(this, FunctionExpression);

  this.type = 'FunctionExpression';
  this.isGenerator = isGenerator;
  this.name = name;
  this.params = params;
  this.body = body;
};

var Getter = exports.Getter = function Getter(_ref47) {
  var name = _ref47.name;
  var body = _ref47.body;

  _classCallCheck(this, Getter);

  this.type = 'Getter';
  this.name = name;
  this.body = body;
};

var IdentifierExpression = exports.IdentifierExpression = function IdentifierExpression(_ref48) {
  var name = _ref48.name;

  _classCallCheck(this, IdentifierExpression);

  this.type = 'IdentifierExpression';
  this.name = name;
};

var IfStatement = exports.IfStatement = function IfStatement(_ref49) {
  var test = _ref49.test;
  var consequent = _ref49.consequent;
  var alternate = _ref49.alternate;

  _classCallCheck(this, IfStatement);

  this.type = 'IfStatement';
  this.test = test;
  this.consequent = consequent;
  this.alternate = alternate;
};

var Import = exports.Import = function Import(_ref50) {
  var defaultBinding = _ref50.defaultBinding;
  var namedImports = _ref50.namedImports;
  var moduleSpecifier = _ref50.moduleSpecifier;

  _classCallCheck(this, Import);

  this.type = 'Import';
  this.defaultBinding = defaultBinding;
  this.namedImports = namedImports;
  this.moduleSpecifier = moduleSpecifier;
};

var ImportNamespace = exports.ImportNamespace = function ImportNamespace(_ref51) {
  var defaultBinding = _ref51.defaultBinding;
  var namespaceBinding = _ref51.namespaceBinding;
  var moduleSpecifier = _ref51.moduleSpecifier;

  _classCallCheck(this, ImportNamespace);

  this.type = 'ImportNamespace';
  this.defaultBinding = defaultBinding;
  this.namespaceBinding = namespaceBinding;
  this.moduleSpecifier = moduleSpecifier;
};

var ImportSpecifier = exports.ImportSpecifier = function ImportSpecifier(_ref52) {
  var name = _ref52.name;
  var binding = _ref52.binding;

  _classCallCheck(this, ImportSpecifier);

  this.type = 'ImportSpecifier';
  this.name = name;
  this.binding = binding;
};

var LabeledStatement = exports.LabeledStatement = function LabeledStatement(_ref53) {
  var label = _ref53.label;
  var body = _ref53.body;

  _classCallCheck(this, LabeledStatement);

  this.type = 'LabeledStatement';
  this.label = label;
  this.body = body;
};

var LiteralBooleanExpression = exports.LiteralBooleanExpression = function LiteralBooleanExpression(_ref54) {
  var value = _ref54.value;

  _classCallCheck(this, LiteralBooleanExpression);

  this.type = 'LiteralBooleanExpression';
  this.value = value;
};

var LiteralInfinityExpression = exports.LiteralInfinityExpression = function LiteralInfinityExpression() {
  _classCallCheck(this, LiteralInfinityExpression);

  this.type = 'LiteralInfinityExpression';
};

var LiteralNullExpression = exports.LiteralNullExpression = function LiteralNullExpression() {
  _classCallCheck(this, LiteralNullExpression);

  this.type = 'LiteralNullExpression';
};

var LiteralNumericExpression = exports.LiteralNumericExpression = function LiteralNumericExpression(_ref55) {
  var value = _ref55.value;

  _classCallCheck(this, LiteralNumericExpression);

  this.type = 'LiteralNumericExpression';
  this.value = value;
};

var LiteralRegExpExpression = exports.LiteralRegExpExpression = function LiteralRegExpExpression(_ref56) {
  var pattern = _ref56.pattern;
  var global = _ref56.global;
  var ignoreCase = _ref56.ignoreCase;
  var multiLine = _ref56.multiLine;
  var sticky = _ref56.sticky;
  var unicode = _ref56.unicode;

  _classCallCheck(this, LiteralRegExpExpression);

  this.type = 'LiteralRegExpExpression';
  this.pattern = pattern;
  this.global = global;
  this.ignoreCase = ignoreCase;
  this.multiLine = multiLine;
  this.sticky = sticky;
  this.unicode = unicode;
};

var LiteralStringExpression = exports.LiteralStringExpression = function LiteralStringExpression(_ref57) {
  var value = _ref57.value;

  _classCallCheck(this, LiteralStringExpression);

  this.type = 'LiteralStringExpression';
  this.value = value;
};

var Method = exports.Method = function Method(_ref58) {
  var isGenerator = _ref58.isGenerator;
  var name = _ref58.name;
  var params = _ref58.params;
  var body = _ref58.body;

  _classCallCheck(this, Method);

  this.type = 'Method';
  this.isGenerator = isGenerator;
  this.name = name;
  this.params = params;
  this.body = body;
};

var Module = exports.Module = function Module(_ref59) {
  var directives = _ref59.directives;
  var items = _ref59.items;

  _classCallCheck(this, Module);

  this.type = 'Module';
  this.directives = directives;
  this.items = items;
};

var NewExpression = exports.NewExpression = function NewExpression(_ref60) {
  var callee = _ref60.callee;
  var _arguments = _ref60.arguments;

  _classCallCheck(this, NewExpression);

  this.type = 'NewExpression';
  this.callee = callee;
  this.arguments = _arguments;
};

var NewTargetExpression = exports.NewTargetExpression = function NewTargetExpression() {
  _classCallCheck(this, NewTargetExpression);

  this.type = 'NewTargetExpression';
};

var ObjectAssignmentTarget = exports.ObjectAssignmentTarget = function ObjectAssignmentTarget(_ref61) {
  var properties = _ref61.properties;

  _classCallCheck(this, ObjectAssignmentTarget);

  this.type = 'ObjectAssignmentTarget';
  this.properties = properties;
};

var ObjectBinding = exports.ObjectBinding = function ObjectBinding(_ref62) {
  var properties = _ref62.properties;

  _classCallCheck(this, ObjectBinding);

  this.type = 'ObjectBinding';
  this.properties = properties;
};

var ObjectExpression = exports.ObjectExpression = function ObjectExpression(_ref63) {
  var properties = _ref63.properties;

  _classCallCheck(this, ObjectExpression);

  this.type = 'ObjectExpression';
  this.properties = properties;
};

var ReturnStatement = exports.ReturnStatement = function ReturnStatement(_ref64) {
  var expression = _ref64.expression;

  _classCallCheck(this, ReturnStatement);

  this.type = 'ReturnStatement';
  this.expression = expression;
};

var Script = exports.Script = function Script(_ref65) {
  var directives = _ref65.directives;
  var statements = _ref65.statements;

  _classCallCheck(this, Script);

  this.type = 'Script';
  this.directives = directives;
  this.statements = statements;
};

var Setter = exports.Setter = function Setter(_ref66) {
  var name = _ref66.name;
  var param = _ref66.param;
  var body = _ref66.body;

  _classCallCheck(this, Setter);

  this.type = 'Setter';
  this.name = name;
  this.param = param;
  this.body = body;
};

var ShorthandProperty = exports.ShorthandProperty = function ShorthandProperty(_ref67) {
  var name = _ref67.name;

  _classCallCheck(this, ShorthandProperty);

  this.type = 'ShorthandProperty';
  this.name = name;
};

var SpreadElement = exports.SpreadElement = function SpreadElement(_ref68) {
  var expression = _ref68.expression;

  _classCallCheck(this, SpreadElement);

  this.type = 'SpreadElement';
  this.expression = expression;
};

var StaticMemberAssignmentTarget = exports.StaticMemberAssignmentTarget = function StaticMemberAssignmentTarget(_ref69) {
  var object = _ref69.object;
  var property = _ref69.property;

  _classCallCheck(this, StaticMemberAssignmentTarget);

  this.type = 'StaticMemberAssignmentTarget';
  this.object = object;
  this.property = property;
};

var StaticMemberExpression = exports.StaticMemberExpression = function StaticMemberExpression(_ref70) {
  var object = _ref70.object;
  var property = _ref70.property;

  _classCallCheck(this, StaticMemberExpression);

  this.type = 'StaticMemberExpression';
  this.object = object;
  this.property = property;
};

var StaticPropertyName = exports.StaticPropertyName = function StaticPropertyName(_ref71) {
  var value = _ref71.value;

  _classCallCheck(this, StaticPropertyName);

  this.type = 'StaticPropertyName';
  this.value = value;
};

var Super = exports.Super = function Super() {
  _classCallCheck(this, Super);

  this.type = 'Super';
};

var SwitchCase = exports.SwitchCase = function SwitchCase(_ref72) {
  var test = _ref72.test;
  var consequent = _ref72.consequent;

  _classCallCheck(this, SwitchCase);

  this.type = 'SwitchCase';
  this.test = test;
  this.consequent = consequent;
};

var SwitchDefault = exports.SwitchDefault = function SwitchDefault(_ref73) {
  var consequent = _ref73.consequent;

  _classCallCheck(this, SwitchDefault);

  this.type = 'SwitchDefault';
  this.consequent = consequent;
};

var SwitchStatement = exports.SwitchStatement = function SwitchStatement(_ref74) {
  var discriminant = _ref74.discriminant;
  var cases = _ref74.cases;

  _classCallCheck(this, SwitchStatement);

  this.type = 'SwitchStatement';
  this.discriminant = discriminant;
  this.cases = cases;
};

var SwitchStatementWithDefault = exports.SwitchStatementWithDefault = function SwitchStatementWithDefault(_ref75) {
  var discriminant = _ref75.discriminant;
  var preDefaultCases = _ref75.preDefaultCases;
  var defaultCase = _ref75.defaultCase;
  var postDefaultCases = _ref75.postDefaultCases;

  _classCallCheck(this, SwitchStatementWithDefault);

  this.type = 'SwitchStatementWithDefault';
  this.discriminant = discriminant;
  this.preDefaultCases = preDefaultCases;
  this.defaultCase = defaultCase;
  this.postDefaultCases = postDefaultCases;
};

var TemplateElement = exports.TemplateElement = function TemplateElement(_ref76) {
  var rawValue = _ref76.rawValue;

  _classCallCheck(this, TemplateElement);

  this.type = 'TemplateElement';
  this.rawValue = rawValue;
};

var TemplateExpression = exports.TemplateExpression = function TemplateExpression(_ref77) {
  var tag = _ref77.tag;
  var elements = _ref77.elements;

  _classCallCheck(this, TemplateExpression);

  this.type = 'TemplateExpression';
  this.tag = tag;
  this.elements = elements;
};

var ThisExpression = exports.ThisExpression = function ThisExpression() {
  _classCallCheck(this, ThisExpression);

  this.type = 'ThisExpression';
};

var ThrowStatement = exports.ThrowStatement = function ThrowStatement(_ref78) {
  var expression = _ref78.expression;

  _classCallCheck(this, ThrowStatement);

  this.type = 'ThrowStatement';
  this.expression = expression;
};

var TryCatchStatement = exports.TryCatchStatement = function TryCatchStatement(_ref79) {
  var body = _ref79.body;
  var catchClause = _ref79.catchClause;

  _classCallCheck(this, TryCatchStatement);

  this.type = 'TryCatchStatement';
  this.body = body;
  this.catchClause = catchClause;
};

var TryFinallyStatement = exports.TryFinallyStatement = function TryFinallyStatement(_ref80) {
  var body = _ref80.body;
  var catchClause = _ref80.catchClause;
  var finalizer = _ref80.finalizer;

  _classCallCheck(this, TryFinallyStatement);

  this.type = 'TryFinallyStatement';
  this.body = body;
  this.catchClause = catchClause;
  this.finalizer = finalizer;
};

var UnaryExpression = exports.UnaryExpression = function UnaryExpression(_ref81) {
  var operator = _ref81.operator;
  var operand = _ref81.operand;

  _classCallCheck(this, UnaryExpression);

  this.type = 'UnaryExpression';
  this.operator = operator;
  this.operand = operand;
};

var UpdateExpression = exports.UpdateExpression = function UpdateExpression(_ref82) {
  var isPrefix = _ref82.isPrefix;
  var operator = _ref82.operator;
  var operand = _ref82.operand;

  _classCallCheck(this, UpdateExpression);

  this.type = 'UpdateExpression';
  this.isPrefix = isPrefix;
  this.operator = operator;
  this.operand = operand;
};

var VariableDeclaration = exports.VariableDeclaration = function VariableDeclaration(_ref83) {
  var kind = _ref83.kind;
  var declarators = _ref83.declarators;

  _classCallCheck(this, VariableDeclaration);

  this.type = 'VariableDeclaration';
  this.kind = kind;
  this.declarators = declarators;
};

var VariableDeclarationStatement = exports.VariableDeclarationStatement = function VariableDeclarationStatement(_ref84) {
  var declaration = _ref84.declaration;

  _classCallCheck(this, VariableDeclarationStatement);

  this.type = 'VariableDeclarationStatement';
  this.declaration = declaration;
};

var VariableDeclarator = exports.VariableDeclarator = function VariableDeclarator(_ref85) {
  var binding = _ref85.binding;
  var init = _ref85.init;

  _classCallCheck(this, VariableDeclarator);

  this.type = 'VariableDeclarator';
  this.binding = binding;
  this.init = init;
};

var WhileStatement = exports.WhileStatement = function WhileStatement(_ref86) {
  var test = _ref86.test;
  var body = _ref86.body;

  _classCallCheck(this, WhileStatement);

  this.type = 'WhileStatement';
  this.test = test;
  this.body = body;
};

var WithStatement = exports.WithStatement = function WithStatement(_ref87) {
  var object = _ref87.object;
  var body = _ref87.body;

  _classCallCheck(this, WithStatement);

  this.type = 'WithStatement';
  this.object = object;
  this.body = body;
};

var YieldExpression = exports.YieldExpression = function YieldExpression(_ref88) {
  var expression = _ref88.expression;

  _classCallCheck(this, YieldExpression);

  this.type = 'YieldExpression';
  this.expression = expression;
};

var YieldGeneratorExpression = exports.YieldGeneratorExpression = function YieldGeneratorExpression(_ref89) {
  var expression = _ref89.expression;

  _classCallCheck(this, YieldGeneratorExpression);

  this.type = 'YieldGeneratorExpression';
  this.expression = expression;
};
},{}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2016 Shape Security, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _shiftAst = require('shift-ast');

var Shift = _interopRequireWildcard(_shiftAst);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CloneReducer = function () {
  function CloneReducer() {
    _classCallCheck(this, CloneReducer);
  }

  _createClass(CloneReducer, [{
    key: 'reduceArrayAssignmentTarget',
    value: function reduceArrayAssignmentTarget(node, _ref) {
      var elements = _ref.elements,
          rest = _ref.rest;

      return new Shift.ArrayAssignmentTarget({ elements: elements, rest: rest });
    }
  }, {
    key: 'reduceArrayBinding',
    value: function reduceArrayBinding(node, _ref2) {
      var elements = _ref2.elements,
          rest = _ref2.rest;

      return new Shift.ArrayBinding({ elements: elements, rest: rest });
    }
  }, {
    key: 'reduceArrayExpression',
    value: function reduceArrayExpression(node, _ref3) {
      var elements = _ref3.elements;

      return new Shift.ArrayExpression({ elements: elements });
    }
  }, {
    key: 'reduceArrowExpression',
    value: function reduceArrowExpression(node, _ref4) {
      var params = _ref4.params,
          body = _ref4.body;

      return new Shift.ArrowExpression({ params: params, body: body });
    }
  }, {
    key: 'reduceAssignmentExpression',
    value: function reduceAssignmentExpression(node, _ref5) {
      var binding = _ref5.binding,
          expression = _ref5.expression;

      return new Shift.AssignmentExpression({ binding: binding, expression: expression });
    }
  }, {
    key: 'reduceAssignmentTargetIdentifier',
    value: function reduceAssignmentTargetIdentifier(node) {
      return new Shift.AssignmentTargetIdentifier({ name: node.name });
    }
  }, {
    key: 'reduceAssignmentTargetPropertyIdentifier',
    value: function reduceAssignmentTargetPropertyIdentifier(node, _ref6) {
      var binding = _ref6.binding,
          init = _ref6.init;

      return new Shift.AssignmentTargetPropertyIdentifier({ binding: binding, init: init });
    }
  }, {
    key: 'reduceAssignmentTargetPropertyProperty',
    value: function reduceAssignmentTargetPropertyProperty(node, _ref7) {
      var name = _ref7.name,
          binding = _ref7.binding;

      return new Shift.AssignmentTargetPropertyProperty({ name: name, binding: binding });
    }
  }, {
    key: 'reduceAssignmentTargetWithDefault',
    value: function reduceAssignmentTargetWithDefault(node, _ref8) {
      var binding = _ref8.binding,
          init = _ref8.init;

      return new Shift.AssignmentTargetWithDefault({ binding: binding, init: init });
    }
  }, {
    key: 'reduceBinaryExpression',
    value: function reduceBinaryExpression(node, _ref9) {
      var left = _ref9.left,
          right = _ref9.right;

      return new Shift.BinaryExpression({ left: left, operator: node.operator, right: right });
    }
  }, {
    key: 'reduceBindingIdentifier',
    value: function reduceBindingIdentifier(node) {
      return new Shift.BindingIdentifier({ name: node.name });
    }
  }, {
    key: 'reduceBindingPropertyIdentifier',
    value: function reduceBindingPropertyIdentifier(node, _ref10) {
      var binding = _ref10.binding,
          init = _ref10.init;

      return new Shift.BindingPropertyIdentifier({ binding: binding, init: init });
    }
  }, {
    key: 'reduceBindingPropertyProperty',
    value: function reduceBindingPropertyProperty(node, _ref11) {
      var name = _ref11.name,
          binding = _ref11.binding;

      return new Shift.BindingPropertyProperty({ name: name, binding: binding });
    }
  }, {
    key: 'reduceBindingWithDefault',
    value: function reduceBindingWithDefault(node, _ref12) {
      var binding = _ref12.binding,
          init = _ref12.init;

      return new Shift.BindingWithDefault({ binding: binding, init: init });
    }
  }, {
    key: 'reduceBlock',
    value: function reduceBlock(node, _ref13) {
      var statements = _ref13.statements;

      return new Shift.Block({ statements: statements });
    }
  }, {
    key: 'reduceBlockStatement',
    value: function reduceBlockStatement(node, _ref14) {
      var block = _ref14.block;

      return new Shift.BlockStatement({ block: block });
    }
  }, {
    key: 'reduceBreakStatement',
    value: function reduceBreakStatement(node) {
      return new Shift.BreakStatement({ label: node.label });
    }
  }, {
    key: 'reduceCallExpression',
    value: function reduceCallExpression(node, _ref15) {
      var callee = _ref15.callee,
          _arguments = _ref15.arguments;

      return new Shift.CallExpression({ callee: callee, arguments: _arguments });
    }
  }, {
    key: 'reduceCatchClause',
    value: function reduceCatchClause(node, _ref16) {
      var binding = _ref16.binding,
          body = _ref16.body;

      return new Shift.CatchClause({ binding: binding, body: body });
    }
  }, {
    key: 'reduceClassDeclaration',
    value: function reduceClassDeclaration(node, _ref17) {
      var name = _ref17.name,
          _super = _ref17.super,
          elements = _ref17.elements;

      return new Shift.ClassDeclaration({ name: name, super: _super, elements: elements });
    }
  }, {
    key: 'reduceClassElement',
    value: function reduceClassElement(node, _ref18) {
      var method = _ref18.method;

      return new Shift.ClassElement({ isStatic: node.isStatic, method: method });
    }
  }, {
    key: 'reduceClassExpression',
    value: function reduceClassExpression(node, _ref19) {
      var name = _ref19.name,
          _super = _ref19.super,
          elements = _ref19.elements;

      return new Shift.ClassExpression({ name: name, super: _super, elements: elements });
    }
  }, {
    key: 'reduceCompoundAssignmentExpression',
    value: function reduceCompoundAssignmentExpression(node, _ref20) {
      var binding = _ref20.binding,
          expression = _ref20.expression;

      return new Shift.CompoundAssignmentExpression({ binding: binding, operator: node.operator, expression: expression });
    }
  }, {
    key: 'reduceComputedMemberAssignmentTarget',
    value: function reduceComputedMemberAssignmentTarget(node, _ref21) {
      var object = _ref21.object,
          expression = _ref21.expression;

      return new Shift.ComputedMemberAssignmentTarget({ object: object, expression: expression });
    }
  }, {
    key: 'reduceComputedMemberExpression',
    value: function reduceComputedMemberExpression(node, _ref22) {
      var object = _ref22.object,
          expression = _ref22.expression;

      return new Shift.ComputedMemberExpression({ object: object, expression: expression });
    }
  }, {
    key: 'reduceComputedPropertyName',
    value: function reduceComputedPropertyName(node, _ref23) {
      var expression = _ref23.expression;

      return new Shift.ComputedPropertyName({ expression: expression });
    }
  }, {
    key: 'reduceConditionalExpression',
    value: function reduceConditionalExpression(node, _ref24) {
      var test = _ref24.test,
          consequent = _ref24.consequent,
          alternate = _ref24.alternate;

      return new Shift.ConditionalExpression({ test: test, consequent: consequent, alternate: alternate });
    }
  }, {
    key: 'reduceContinueStatement',
    value: function reduceContinueStatement(node) {
      return new Shift.ContinueStatement({ label: node.label });
    }
  }, {
    key: 'reduceDataProperty',
    value: function reduceDataProperty(node, _ref25) {
      var name = _ref25.name,
          expression = _ref25.expression;

      return new Shift.DataProperty({ name: name, expression: expression });
    }
  }, {
    key: 'reduceDebuggerStatement',
    value: function reduceDebuggerStatement(node) {
      return new Shift.DebuggerStatement();
    }
  }, {
    key: 'reduceDirective',
    value: function reduceDirective(node) {
      return new Shift.Directive({ rawValue: node.rawValue });
    }
  }, {
    key: 'reduceDoWhileStatement',
    value: function reduceDoWhileStatement(node, _ref26) {
      var body = _ref26.body,
          test = _ref26.test;

      return new Shift.DoWhileStatement({ body: body, test: test });
    }
  }, {
    key: 'reduceEmptyStatement',
    value: function reduceEmptyStatement(node) {
      return new Shift.EmptyStatement();
    }
  }, {
    key: 'reduceExport',
    value: function reduceExport(node, _ref27) {
      var declaration = _ref27.declaration;

      return new Shift.Export({ declaration: declaration });
    }
  }, {
    key: 'reduceExportAllFrom',
    value: function reduceExportAllFrom(node) {
      return new Shift.ExportAllFrom({ moduleSpecifier: node.moduleSpecifier });
    }
  }, {
    key: 'reduceExportDefault',
    value: function reduceExportDefault(node, _ref28) {
      var body = _ref28.body;

      return new Shift.ExportDefault({ body: body });
    }
  }, {
    key: 'reduceExportFrom',
    value: function reduceExportFrom(node, _ref29) {
      var namedExports = _ref29.namedExports;

      return new Shift.ExportFrom({ namedExports: namedExports, moduleSpecifier: node.moduleSpecifier });
    }
  }, {
    key: 'reduceExportFromSpecifier',
    value: function reduceExportFromSpecifier(node) {
      return new Shift.ExportFromSpecifier({ name: node.name, exportedName: node.exportedName });
    }
  }, {
    key: 'reduceExportLocalSpecifier',
    value: function reduceExportLocalSpecifier(node, _ref30) {
      var name = _ref30.name;

      return new Shift.ExportLocalSpecifier({ name: name, exportedName: node.exportedName });
    }
  }, {
    key: 'reduceExportLocals',
    value: function reduceExportLocals(node, _ref31) {
      var namedExports = _ref31.namedExports;

      return new Shift.ExportLocals({ namedExports: namedExports });
    }
  }, {
    key: 'reduceExpressionStatement',
    value: function reduceExpressionStatement(node, _ref32) {
      var expression = _ref32.expression;

      return new Shift.ExpressionStatement({ expression: expression });
    }
  }, {
    key: 'reduceForInStatement',
    value: function reduceForInStatement(node, _ref33) {
      var left = _ref33.left,
          right = _ref33.right,
          body = _ref33.body;

      return new Shift.ForInStatement({ left: left, right: right, body: body });
    }
  }, {
    key: 'reduceForOfStatement',
    value: function reduceForOfStatement(node, _ref34) {
      var left = _ref34.left,
          right = _ref34.right,
          body = _ref34.body;

      return new Shift.ForOfStatement({ left: left, right: right, body: body });
    }
  }, {
    key: 'reduceForStatement',
    value: function reduceForStatement(node, _ref35) {
      var init = _ref35.init,
          test = _ref35.test,
          update = _ref35.update,
          body = _ref35.body;

      return new Shift.ForStatement({ init: init, test: test, update: update, body: body });
    }
  }, {
    key: 'reduceFormalParameters',
    value: function reduceFormalParameters(node, _ref36) {
      var items = _ref36.items,
          rest = _ref36.rest;

      return new Shift.FormalParameters({ items: items, rest: rest });
    }
  }, {
    key: 'reduceFunctionBody',
    value: function reduceFunctionBody(node, _ref37) {
      var directives = _ref37.directives,
          statements = _ref37.statements;

      return new Shift.FunctionBody({ directives: directives, statements: statements });
    }
  }, {
    key: 'reduceFunctionDeclaration',
    value: function reduceFunctionDeclaration(node, _ref38) {
      var name = _ref38.name,
          params = _ref38.params,
          body = _ref38.body;

      return new Shift.FunctionDeclaration({ isGenerator: node.isGenerator, name: name, params: params, body: body });
    }
  }, {
    key: 'reduceFunctionExpression',
    value: function reduceFunctionExpression(node, _ref39) {
      var name = _ref39.name,
          params = _ref39.params,
          body = _ref39.body;

      return new Shift.FunctionExpression({ isGenerator: node.isGenerator, name: name, params: params, body: body });
    }
  }, {
    key: 'reduceGetter',
    value: function reduceGetter(node, _ref40) {
      var name = _ref40.name,
          body = _ref40.body;

      return new Shift.Getter({ name: name, body: body });
    }
  }, {
    key: 'reduceIdentifierExpression',
    value: function reduceIdentifierExpression(node) {
      return new Shift.IdentifierExpression({ name: node.name });
    }
  }, {
    key: 'reduceIfStatement',
    value: function reduceIfStatement(node, _ref41) {
      var test = _ref41.test,
          consequent = _ref41.consequent,
          alternate = _ref41.alternate;

      return new Shift.IfStatement({ test: test, consequent: consequent, alternate: alternate });
    }
  }, {
    key: 'reduceImport',
    value: function reduceImport(node, _ref42) {
      var defaultBinding = _ref42.defaultBinding,
          namedImports = _ref42.namedImports;

      return new Shift.Import({ defaultBinding: defaultBinding, namedImports: namedImports, moduleSpecifier: node.moduleSpecifier });
    }
  }, {
    key: 'reduceImportNamespace',
    value: function reduceImportNamespace(node, _ref43) {
      var defaultBinding = _ref43.defaultBinding,
          namespaceBinding = _ref43.namespaceBinding;

      return new Shift.ImportNamespace({ defaultBinding: defaultBinding, namespaceBinding: namespaceBinding, moduleSpecifier: node.moduleSpecifier });
    }
  }, {
    key: 'reduceImportSpecifier',
    value: function reduceImportSpecifier(node, _ref44) {
      var binding = _ref44.binding;

      return new Shift.ImportSpecifier({ name: node.name, binding: binding });
    }
  }, {
    key: 'reduceLabeledStatement',
    value: function reduceLabeledStatement(node, _ref45) {
      var body = _ref45.body;

      return new Shift.LabeledStatement({ label: node.label, body: body });
    }
  }, {
    key: 'reduceLiteralBooleanExpression',
    value: function reduceLiteralBooleanExpression(node) {
      return new Shift.LiteralBooleanExpression({ value: node.value });
    }
  }, {
    key: 'reduceLiteralInfinityExpression',
    value: function reduceLiteralInfinityExpression(node) {
      return new Shift.LiteralInfinityExpression();
    }
  }, {
    key: 'reduceLiteralNullExpression',
    value: function reduceLiteralNullExpression(node) {
      return new Shift.LiteralNullExpression();
    }
  }, {
    key: 'reduceLiteralNumericExpression',
    value: function reduceLiteralNumericExpression(node) {
      return new Shift.LiteralNumericExpression({ value: node.value });
    }
  }, {
    key: 'reduceLiteralRegExpExpression',
    value: function reduceLiteralRegExpExpression(node) {
      return new Shift.LiteralRegExpExpression({ pattern: node.pattern, global: node.global, ignoreCase: node.ignoreCase, multiLine: node.multiLine, sticky: node.sticky, unicode: node.unicode });
    }
  }, {
    key: 'reduceLiteralStringExpression',
    value: function reduceLiteralStringExpression(node) {
      return new Shift.LiteralStringExpression({ value: node.value });
    }
  }, {
    key: 'reduceMethod',
    value: function reduceMethod(node, _ref46) {
      var name = _ref46.name,
          params = _ref46.params,
          body = _ref46.body;

      return new Shift.Method({ isGenerator: node.isGenerator, name: name, params: params, body: body });
    }
  }, {
    key: 'reduceModule',
    value: function reduceModule(node, _ref47) {
      var directives = _ref47.directives,
          items = _ref47.items;

      return new Shift.Module({ directives: directives, items: items });
    }
  }, {
    key: 'reduceNewExpression',
    value: function reduceNewExpression(node, _ref48) {
      var callee = _ref48.callee,
          _arguments = _ref48.arguments;

      return new Shift.NewExpression({ callee: callee, arguments: _arguments });
    }
  }, {
    key: 'reduceNewTargetExpression',
    value: function reduceNewTargetExpression(node) {
      return new Shift.NewTargetExpression();
    }
  }, {
    key: 'reduceObjectAssignmentTarget',
    value: function reduceObjectAssignmentTarget(node, _ref49) {
      var properties = _ref49.properties;

      return new Shift.ObjectAssignmentTarget({ properties: properties });
    }
  }, {
    key: 'reduceObjectBinding',
    value: function reduceObjectBinding(node, _ref50) {
      var properties = _ref50.properties;

      return new Shift.ObjectBinding({ properties: properties });
    }
  }, {
    key: 'reduceObjectExpression',
    value: function reduceObjectExpression(node, _ref51) {
      var properties = _ref51.properties;

      return new Shift.ObjectExpression({ properties: properties });
    }
  }, {
    key: 'reduceReturnStatement',
    value: function reduceReturnStatement(node, _ref52) {
      var expression = _ref52.expression;

      return new Shift.ReturnStatement({ expression: expression });
    }
  }, {
    key: 'reduceScript',
    value: function reduceScript(node, _ref53) {
      var directives = _ref53.directives,
          statements = _ref53.statements;

      return new Shift.Script({ directives: directives, statements: statements });
    }
  }, {
    key: 'reduceSetter',
    value: function reduceSetter(node, _ref54) {
      var name = _ref54.name,
          param = _ref54.param,
          body = _ref54.body;

      return new Shift.Setter({ name: name, param: param, body: body });
    }
  }, {
    key: 'reduceShorthandProperty',
    value: function reduceShorthandProperty(node, _ref55) {
      var name = _ref55.name;

      return new Shift.ShorthandProperty({ name: name });
    }
  }, {
    key: 'reduceSpreadElement',
    value: function reduceSpreadElement(node, _ref56) {
      var expression = _ref56.expression;

      return new Shift.SpreadElement({ expression: expression });
    }
  }, {
    key: 'reduceStaticMemberAssignmentTarget',
    value: function reduceStaticMemberAssignmentTarget(node, _ref57) {
      var object = _ref57.object;

      return new Shift.StaticMemberAssignmentTarget({ object: object, property: node.property });
    }
  }, {
    key: 'reduceStaticMemberExpression',
    value: function reduceStaticMemberExpression(node, _ref58) {
      var object = _ref58.object;

      return new Shift.StaticMemberExpression({ object: object, property: node.property });
    }
  }, {
    key: 'reduceStaticPropertyName',
    value: function reduceStaticPropertyName(node) {
      return new Shift.StaticPropertyName({ value: node.value });
    }
  }, {
    key: 'reduceSuper',
    value: function reduceSuper(node) {
      return new Shift.Super();
    }
  }, {
    key: 'reduceSwitchCase',
    value: function reduceSwitchCase(node, _ref59) {
      var test = _ref59.test,
          consequent = _ref59.consequent;

      return new Shift.SwitchCase({ test: test, consequent: consequent });
    }
  }, {
    key: 'reduceSwitchDefault',
    value: function reduceSwitchDefault(node, _ref60) {
      var consequent = _ref60.consequent;

      return new Shift.SwitchDefault({ consequent: consequent });
    }
  }, {
    key: 'reduceSwitchStatement',
    value: function reduceSwitchStatement(node, _ref61) {
      var discriminant = _ref61.discriminant,
          cases = _ref61.cases;

      return new Shift.SwitchStatement({ discriminant: discriminant, cases: cases });
    }
  }, {
    key: 'reduceSwitchStatementWithDefault',
    value: function reduceSwitchStatementWithDefault(node, _ref62) {
      var discriminant = _ref62.discriminant,
          preDefaultCases = _ref62.preDefaultCases,
          defaultCase = _ref62.defaultCase,
          postDefaultCases = _ref62.postDefaultCases;

      return new Shift.SwitchStatementWithDefault({ discriminant: discriminant, preDefaultCases: preDefaultCases, defaultCase: defaultCase, postDefaultCases: postDefaultCases });
    }
  }, {
    key: 'reduceTemplateElement',
    value: function reduceTemplateElement(node) {
      return new Shift.TemplateElement({ rawValue: node.rawValue });
    }
  }, {
    key: 'reduceTemplateExpression',
    value: function reduceTemplateExpression(node, _ref63) {
      var tag = _ref63.tag,
          elements = _ref63.elements;

      return new Shift.TemplateExpression({ tag: tag, elements: elements });
    }
  }, {
    key: 'reduceThisExpression',
    value: function reduceThisExpression(node) {
      return new Shift.ThisExpression();
    }
  }, {
    key: 'reduceThrowStatement',
    value: function reduceThrowStatement(node, _ref64) {
      var expression = _ref64.expression;

      return new Shift.ThrowStatement({ expression: expression });
    }
  }, {
    key: 'reduceTryCatchStatement',
    value: function reduceTryCatchStatement(node, _ref65) {
      var body = _ref65.body,
          catchClause = _ref65.catchClause;

      return new Shift.TryCatchStatement({ body: body, catchClause: catchClause });
    }
  }, {
    key: 'reduceTryFinallyStatement',
    value: function reduceTryFinallyStatement(node, _ref66) {
      var body = _ref66.body,
          catchClause = _ref66.catchClause,
          finalizer = _ref66.finalizer;

      return new Shift.TryFinallyStatement({ body: body, catchClause: catchClause, finalizer: finalizer });
    }
  }, {
    key: 'reduceUnaryExpression',
    value: function reduceUnaryExpression(node, _ref67) {
      var operand = _ref67.operand;

      return new Shift.UnaryExpression({ operator: node.operator, operand: operand });
    }
  }, {
    key: 'reduceUpdateExpression',
    value: function reduceUpdateExpression(node, _ref68) {
      var operand = _ref68.operand;

      return new Shift.UpdateExpression({ isPrefix: node.isPrefix, operator: node.operator, operand: operand });
    }
  }, {
    key: 'reduceVariableDeclaration',
    value: function reduceVariableDeclaration(node, _ref69) {
      var declarators = _ref69.declarators;

      return new Shift.VariableDeclaration({ kind: node.kind, declarators: declarators });
    }
  }, {
    key: 'reduceVariableDeclarationStatement',
    value: function reduceVariableDeclarationStatement(node, _ref70) {
      var declaration = _ref70.declaration;

      return new Shift.VariableDeclarationStatement({ declaration: declaration });
    }
  }, {
    key: 'reduceVariableDeclarator',
    value: function reduceVariableDeclarator(node, _ref71) {
      var binding = _ref71.binding,
          init = _ref71.init;

      return new Shift.VariableDeclarator({ binding: binding, init: init });
    }
  }, {
    key: 'reduceWhileStatement',
    value: function reduceWhileStatement(node, _ref72) {
      var test = _ref72.test,
          body = _ref72.body;

      return new Shift.WhileStatement({ test: test, body: body });
    }
  }, {
    key: 'reduceWithStatement',
    value: function reduceWithStatement(node, _ref73) {
      var object = _ref73.object,
          body = _ref73.body;

      return new Shift.WithStatement({ object: object, body: body });
    }
  }, {
    key: 'reduceYieldExpression',
    value: function reduceYieldExpression(node, _ref74) {
      var expression = _ref74.expression;

      return new Shift.YieldExpression({ expression: expression });
    }
  }, {
    key: 'reduceYieldGeneratorExpression',
    value: function reduceYieldGeneratorExpression(node, _ref75) {
      var expression = _ref75.expression;

      return new Shift.YieldGeneratorExpression({ expression: expression });
    }
  }]);

  return CloneReducer;
}();

exports.default = CloneReducer;
},{"shift-ast":2}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = reduce;

var _cloneReducer = require("./clone-reducer");

Object.defineProperty(exports, "CloneReducer", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_cloneReducer).default;
  }
});

var _monoidalReducer = require("./monoidal-reducer");

Object.defineProperty(exports, "MonoidalReducer", {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_monoidalReducer).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright 2016 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var director = {
  ArrayAssignmentTarget: function ArrayAssignmentTarget(reducer, node) {
    var _this = this;

    return reducer.reduceArrayAssignmentTarget(node, { elements: node.elements.map(function (v) {
        return v && _this[v.type](reducer, v);
      }), rest: node.rest && this[node.rest.type](reducer, node.rest) });
  },
  ArrayBinding: function ArrayBinding(reducer, node) {
    var _this2 = this;

    return reducer.reduceArrayBinding(node, { elements: node.elements.map(function (v) {
        return v && _this2[v.type](reducer, v);
      }), rest: node.rest && this[node.rest.type](reducer, node.rest) });
  },
  ArrayExpression: function ArrayExpression(reducer, node) {
    var _this3 = this;

    return reducer.reduceArrayExpression(node, { elements: node.elements.map(function (v) {
        return v && _this3[v.type](reducer, v);
      }) });
  },
  ArrowExpression: function ArrowExpression(reducer, node) {
    return reducer.reduceArrowExpression(node, { params: this.FormalParameters(reducer, node.params), body: this[node.body.type](reducer, node.body) });
  },
  AssignmentExpression: function AssignmentExpression(reducer, node) {
    return reducer.reduceAssignmentExpression(node, { binding: this[node.binding.type](reducer, node.binding), expression: this[node.expression.type](reducer, node.expression) });
  },
  AssignmentTargetIdentifier: function AssignmentTargetIdentifier(reducer, node) {
    return reducer.reduceAssignmentTargetIdentifier(node);
  },
  AssignmentTargetPropertyIdentifier: function AssignmentTargetPropertyIdentifier(reducer, node) {
    return reducer.reduceAssignmentTargetPropertyIdentifier(node, { binding: this.AssignmentTargetIdentifier(reducer, node.binding), init: node.init && this[node.init.type](reducer, node.init) });
  },
  AssignmentTargetPropertyProperty: function AssignmentTargetPropertyProperty(reducer, node) {
    return reducer.reduceAssignmentTargetPropertyProperty(node, { name: this[node.name.type](reducer, node.name), binding: this[node.binding.type](reducer, node.binding) });
  },
  AssignmentTargetWithDefault: function AssignmentTargetWithDefault(reducer, node) {
    return reducer.reduceAssignmentTargetWithDefault(node, { binding: this[node.binding.type](reducer, node.binding), init: this[node.init.type](reducer, node.init) });
  },
  BinaryExpression: function BinaryExpression(reducer, node) {
    return reducer.reduceBinaryExpression(node, { left: this[node.left.type](reducer, node.left), right: this[node.right.type](reducer, node.right) });
  },
  BindingIdentifier: function BindingIdentifier(reducer, node) {
    return reducer.reduceBindingIdentifier(node);
  },
  BindingPropertyIdentifier: function BindingPropertyIdentifier(reducer, node) {
    return reducer.reduceBindingPropertyIdentifier(node, { binding: this.BindingIdentifier(reducer, node.binding), init: node.init && this[node.init.type](reducer, node.init) });
  },
  BindingPropertyProperty: function BindingPropertyProperty(reducer, node) {
    return reducer.reduceBindingPropertyProperty(node, { name: this[node.name.type](reducer, node.name), binding: this[node.binding.type](reducer, node.binding) });
  },
  BindingWithDefault: function BindingWithDefault(reducer, node) {
    return reducer.reduceBindingWithDefault(node, { binding: this[node.binding.type](reducer, node.binding), init: this[node.init.type](reducer, node.init) });
  },
  Block: function Block(reducer, node) {
    var _this4 = this;

    return reducer.reduceBlock(node, { statements: node.statements.map(function (v) {
        return _this4[v.type](reducer, v);
      }) });
  },
  BlockStatement: function BlockStatement(reducer, node) {
    return reducer.reduceBlockStatement(node, { block: this.Block(reducer, node.block) });
  },
  BreakStatement: function BreakStatement(reducer, node) {
    return reducer.reduceBreakStatement(node);
  },
  CallExpression: function CallExpression(reducer, node) {
    var _this5 = this;

    return reducer.reduceCallExpression(node, { callee: this[node.callee.type](reducer, node.callee), arguments: node.arguments.map(function (v) {
        return _this5[v.type](reducer, v);
      }) });
  },
  CatchClause: function CatchClause(reducer, node) {
    return reducer.reduceCatchClause(node, { binding: this[node.binding.type](reducer, node.binding), body: this.Block(reducer, node.body) });
  },
  ClassDeclaration: function ClassDeclaration(reducer, node) {
    var _this6 = this;

    return reducer.reduceClassDeclaration(node, { name: this.BindingIdentifier(reducer, node.name), super: node.super && this[node.super.type](reducer, node.super), elements: node.elements.map(function (v) {
        return _this6.ClassElement(reducer, v);
      }) });
  },
  ClassElement: function ClassElement(reducer, node) {
    return reducer.reduceClassElement(node, { method: this[node.method.type](reducer, node.method) });
  },
  ClassExpression: function ClassExpression(reducer, node) {
    var _this7 = this;

    return reducer.reduceClassExpression(node, { name: node.name && this.BindingIdentifier(reducer, node.name), super: node.super && this[node.super.type](reducer, node.super), elements: node.elements.map(function (v) {
        return _this7.ClassElement(reducer, v);
      }) });
  },
  CompoundAssignmentExpression: function CompoundAssignmentExpression(reducer, node) {
    return reducer.reduceCompoundAssignmentExpression(node, { binding: this[node.binding.type](reducer, node.binding), expression: this[node.expression.type](reducer, node.expression) });
  },
  ComputedMemberAssignmentTarget: function ComputedMemberAssignmentTarget(reducer, node) {
    return reducer.reduceComputedMemberAssignmentTarget(node, { object: this[node.object.type](reducer, node.object), expression: this[node.expression.type](reducer, node.expression) });
  },
  ComputedMemberExpression: function ComputedMemberExpression(reducer, node) {
    return reducer.reduceComputedMemberExpression(node, { object: this[node.object.type](reducer, node.object), expression: this[node.expression.type](reducer, node.expression) });
  },
  ComputedPropertyName: function ComputedPropertyName(reducer, node) {
    return reducer.reduceComputedPropertyName(node, { expression: this[node.expression.type](reducer, node.expression) });
  },
  ConditionalExpression: function ConditionalExpression(reducer, node) {
    return reducer.reduceConditionalExpression(node, { test: this[node.test.type](reducer, node.test), consequent: this[node.consequent.type](reducer, node.consequent), alternate: this[node.alternate.type](reducer, node.alternate) });
  },
  ContinueStatement: function ContinueStatement(reducer, node) {
    return reducer.reduceContinueStatement(node);
  },
  DataProperty: function DataProperty(reducer, node) {
    return reducer.reduceDataProperty(node, { name: this[node.name.type](reducer, node.name), expression: this[node.expression.type](reducer, node.expression) });
  },
  DebuggerStatement: function DebuggerStatement(reducer, node) {
    return reducer.reduceDebuggerStatement(node);
  },
  Directive: function Directive(reducer, node) {
    return reducer.reduceDirective(node);
  },
  DoWhileStatement: function DoWhileStatement(reducer, node) {
    return reducer.reduceDoWhileStatement(node, { body: this[node.body.type](reducer, node.body), test: this[node.test.type](reducer, node.test) });
  },
  EmptyStatement: function EmptyStatement(reducer, node) {
    return reducer.reduceEmptyStatement(node);
  },
  Export: function Export(reducer, node) {
    return reducer.reduceExport(node, { declaration: this[node.declaration.type](reducer, node.declaration) });
  },
  ExportAllFrom: function ExportAllFrom(reducer, node) {
    return reducer.reduceExportAllFrom(node);
  },
  ExportDefault: function ExportDefault(reducer, node) {
    return reducer.reduceExportDefault(node, { body: this[node.body.type](reducer, node.body) });
  },
  ExportFrom: function ExportFrom(reducer, node) {
    var _this8 = this;

    return reducer.reduceExportFrom(node, { namedExports: node.namedExports.map(function (v) {
        return _this8.ExportFromSpecifier(reducer, v);
      }) });
  },
  ExportFromSpecifier: function ExportFromSpecifier(reducer, node) {
    return reducer.reduceExportFromSpecifier(node);
  },
  ExportLocalSpecifier: function ExportLocalSpecifier(reducer, node) {
    return reducer.reduceExportLocalSpecifier(node, { name: this.IdentifierExpression(reducer, node.name) });
  },
  ExportLocals: function ExportLocals(reducer, node) {
    var _this9 = this;

    return reducer.reduceExportLocals(node, { namedExports: node.namedExports.map(function (v) {
        return _this9.ExportLocalSpecifier(reducer, v);
      }) });
  },
  ExpressionStatement: function ExpressionStatement(reducer, node) {
    return reducer.reduceExpressionStatement(node, { expression: this[node.expression.type](reducer, node.expression) });
  },
  ForInStatement: function ForInStatement(reducer, node) {
    return reducer.reduceForInStatement(node, { left: this[node.left.type](reducer, node.left), right: this[node.right.type](reducer, node.right), body: this[node.body.type](reducer, node.body) });
  },
  ForOfStatement: function ForOfStatement(reducer, node) {
    return reducer.reduceForOfStatement(node, { left: this[node.left.type](reducer, node.left), right: this[node.right.type](reducer, node.right), body: this[node.body.type](reducer, node.body) });
  },
  ForStatement: function ForStatement(reducer, node) {
    return reducer.reduceForStatement(node, { init: node.init && this[node.init.type](reducer, node.init), test: node.test && this[node.test.type](reducer, node.test), update: node.update && this[node.update.type](reducer, node.update), body: this[node.body.type](reducer, node.body) });
  },
  FormalParameters: function FormalParameters(reducer, node) {
    var _this10 = this;

    return reducer.reduceFormalParameters(node, { items: node.items.map(function (v) {
        return _this10[v.type](reducer, v);
      }), rest: node.rest && this[node.rest.type](reducer, node.rest) });
  },
  FunctionBody: function FunctionBody(reducer, node) {
    var _this11 = this;

    return reducer.reduceFunctionBody(node, { directives: node.directives.map(function (v) {
        return _this11.Directive(reducer, v);
      }), statements: node.statements.map(function (v) {
        return _this11[v.type](reducer, v);
      }) });
  },
  FunctionDeclaration: function FunctionDeclaration(reducer, node) {
    return reducer.reduceFunctionDeclaration(node, { name: this.BindingIdentifier(reducer, node.name), params: this.FormalParameters(reducer, node.params), body: this.FunctionBody(reducer, node.body) });
  },
  FunctionExpression: function FunctionExpression(reducer, node) {
    return reducer.reduceFunctionExpression(node, { name: node.name && this.BindingIdentifier(reducer, node.name), params: this.FormalParameters(reducer, node.params), body: this.FunctionBody(reducer, node.body) });
  },
  Getter: function Getter(reducer, node) {
    return reducer.reduceGetter(node, { name: this[node.name.type](reducer, node.name), body: this.FunctionBody(reducer, node.body) });
  },
  IdentifierExpression: function IdentifierExpression(reducer, node) {
    return reducer.reduceIdentifierExpression(node);
  },
  IfStatement: function IfStatement(reducer, node) {
    return reducer.reduceIfStatement(node, { test: this[node.test.type](reducer, node.test), consequent: this[node.consequent.type](reducer, node.consequent), alternate: node.alternate && this[node.alternate.type](reducer, node.alternate) });
  },
  Import: function Import(reducer, node) {
    var _this12 = this;

    return reducer.reduceImport(node, { defaultBinding: node.defaultBinding && this.BindingIdentifier(reducer, node.defaultBinding), namedImports: node.namedImports.map(function (v) {
        return _this12.ImportSpecifier(reducer, v);
      }) });
  },
  ImportNamespace: function ImportNamespace(reducer, node) {
    return reducer.reduceImportNamespace(node, { defaultBinding: node.defaultBinding && this.BindingIdentifier(reducer, node.defaultBinding), namespaceBinding: this.BindingIdentifier(reducer, node.namespaceBinding) });
  },
  ImportSpecifier: function ImportSpecifier(reducer, node) {
    return reducer.reduceImportSpecifier(node, { binding: this.BindingIdentifier(reducer, node.binding) });
  },
  LabeledStatement: function LabeledStatement(reducer, node) {
    return reducer.reduceLabeledStatement(node, { body: this[node.body.type](reducer, node.body) });
  },
  LiteralBooleanExpression: function LiteralBooleanExpression(reducer, node) {
    return reducer.reduceLiteralBooleanExpression(node);
  },
  LiteralInfinityExpression: function LiteralInfinityExpression(reducer, node) {
    return reducer.reduceLiteralInfinityExpression(node);
  },
  LiteralNullExpression: function LiteralNullExpression(reducer, node) {
    return reducer.reduceLiteralNullExpression(node);
  },
  LiteralNumericExpression: function LiteralNumericExpression(reducer, node) {
    return reducer.reduceLiteralNumericExpression(node);
  },
  LiteralRegExpExpression: function LiteralRegExpExpression(reducer, node) {
    return reducer.reduceLiteralRegExpExpression(node);
  },
  LiteralStringExpression: function LiteralStringExpression(reducer, node) {
    return reducer.reduceLiteralStringExpression(node);
  },
  Method: function Method(reducer, node) {
    return reducer.reduceMethod(node, { name: this[node.name.type](reducer, node.name), params: this.FormalParameters(reducer, node.params), body: this.FunctionBody(reducer, node.body) });
  },
  Module: function Module(reducer, node) {
    var _this13 = this;

    return reducer.reduceModule(node, { directives: node.directives.map(function (v) {
        return _this13.Directive(reducer, v);
      }), items: node.items.map(function (v) {
        return _this13[v.type](reducer, v);
      }) });
  },
  NewExpression: function NewExpression(reducer, node) {
    var _this14 = this;

    return reducer.reduceNewExpression(node, { callee: this[node.callee.type](reducer, node.callee), arguments: node.arguments.map(function (v) {
        return _this14[v.type](reducer, v);
      }) });
  },
  NewTargetExpression: function NewTargetExpression(reducer, node) {
    return reducer.reduceNewTargetExpression(node);
  },
  ObjectAssignmentTarget: function ObjectAssignmentTarget(reducer, node) {
    var _this15 = this;

    return reducer.reduceObjectAssignmentTarget(node, { properties: node.properties.map(function (v) {
        return _this15[v.type](reducer, v);
      }) });
  },
  ObjectBinding: function ObjectBinding(reducer, node) {
    var _this16 = this;

    return reducer.reduceObjectBinding(node, { properties: node.properties.map(function (v) {
        return _this16[v.type](reducer, v);
      }) });
  },
  ObjectExpression: function ObjectExpression(reducer, node) {
    var _this17 = this;

    return reducer.reduceObjectExpression(node, { properties: node.properties.map(function (v) {
        return _this17[v.type](reducer, v);
      }) });
  },
  ReturnStatement: function ReturnStatement(reducer, node) {
    return reducer.reduceReturnStatement(node, { expression: node.expression && this[node.expression.type](reducer, node.expression) });
  },
  Script: function Script(reducer, node) {
    var _this18 = this;

    return reducer.reduceScript(node, { directives: node.directives.map(function (v) {
        return _this18.Directive(reducer, v);
      }), statements: node.statements.map(function (v) {
        return _this18[v.type](reducer, v);
      }) });
  },
  Setter: function Setter(reducer, node) {
    return reducer.reduceSetter(node, { name: this[node.name.type](reducer, node.name), param: this[node.param.type](reducer, node.param), body: this.FunctionBody(reducer, node.body) });
  },
  ShorthandProperty: function ShorthandProperty(reducer, node) {
    return reducer.reduceShorthandProperty(node, { name: this.IdentifierExpression(reducer, node.name) });
  },
  SpreadElement: function SpreadElement(reducer, node) {
    return reducer.reduceSpreadElement(node, { expression: this[node.expression.type](reducer, node.expression) });
  },
  StaticMemberAssignmentTarget: function StaticMemberAssignmentTarget(reducer, node) {
    return reducer.reduceStaticMemberAssignmentTarget(node, { object: this[node.object.type](reducer, node.object) });
  },
  StaticMemberExpression: function StaticMemberExpression(reducer, node) {
    return reducer.reduceStaticMemberExpression(node, { object: this[node.object.type](reducer, node.object) });
  },
  StaticPropertyName: function StaticPropertyName(reducer, node) {
    return reducer.reduceStaticPropertyName(node);
  },
  Super: function Super(reducer, node) {
    return reducer.reduceSuper(node);
  },
  SwitchCase: function SwitchCase(reducer, node) {
    var _this19 = this;

    return reducer.reduceSwitchCase(node, { test: this[node.test.type](reducer, node.test), consequent: node.consequent.map(function (v) {
        return _this19[v.type](reducer, v);
      }) });
  },
  SwitchDefault: function SwitchDefault(reducer, node) {
    var _this20 = this;

    return reducer.reduceSwitchDefault(node, { consequent: node.consequent.map(function (v) {
        return _this20[v.type](reducer, v);
      }) });
  },
  SwitchStatement: function SwitchStatement(reducer, node) {
    var _this21 = this;

    return reducer.reduceSwitchStatement(node, { discriminant: this[node.discriminant.type](reducer, node.discriminant), cases: node.cases.map(function (v) {
        return _this21.SwitchCase(reducer, v);
      }) });
  },
  SwitchStatementWithDefault: function SwitchStatementWithDefault(reducer, node) {
    var _this22 = this;

    return reducer.reduceSwitchStatementWithDefault(node, { discriminant: this[node.discriminant.type](reducer, node.discriminant), preDefaultCases: node.preDefaultCases.map(function (v) {
        return _this22.SwitchCase(reducer, v);
      }), defaultCase: this.SwitchDefault(reducer, node.defaultCase), postDefaultCases: node.postDefaultCases.map(function (v) {
        return _this22.SwitchCase(reducer, v);
      }) });
  },
  TemplateElement: function TemplateElement(reducer, node) {
    return reducer.reduceTemplateElement(node);
  },
  TemplateExpression: function TemplateExpression(reducer, node) {
    var _this23 = this;

    return reducer.reduceTemplateExpression(node, { tag: node.tag && this[node.tag.type](reducer, node.tag), elements: node.elements.map(function (v) {
        return _this23[v.type](reducer, v);
      }) });
  },
  ThisExpression: function ThisExpression(reducer, node) {
    return reducer.reduceThisExpression(node);
  },
  ThrowStatement: function ThrowStatement(reducer, node) {
    return reducer.reduceThrowStatement(node, { expression: this[node.expression.type](reducer, node.expression) });
  },
  TryCatchStatement: function TryCatchStatement(reducer, node) {
    return reducer.reduceTryCatchStatement(node, { body: this.Block(reducer, node.body), catchClause: this.CatchClause(reducer, node.catchClause) });
  },
  TryFinallyStatement: function TryFinallyStatement(reducer, node) {
    return reducer.reduceTryFinallyStatement(node, { body: this.Block(reducer, node.body), catchClause: node.catchClause && this.CatchClause(reducer, node.catchClause), finalizer: this.Block(reducer, node.finalizer) });
  },
  UnaryExpression: function UnaryExpression(reducer, node) {
    return reducer.reduceUnaryExpression(node, { operand: this[node.operand.type](reducer, node.operand) });
  },
  UpdateExpression: function UpdateExpression(reducer, node) {
    return reducer.reduceUpdateExpression(node, { operand: this[node.operand.type](reducer, node.operand) });
  },
  VariableDeclaration: function VariableDeclaration(reducer, node) {
    var _this24 = this;

    return reducer.reduceVariableDeclaration(node, { declarators: node.declarators.map(function (v) {
        return _this24.VariableDeclarator(reducer, v);
      }) });
  },
  VariableDeclarationStatement: function VariableDeclarationStatement(reducer, node) {
    return reducer.reduceVariableDeclarationStatement(node, { declaration: this.VariableDeclaration(reducer, node.declaration) });
  },
  VariableDeclarator: function VariableDeclarator(reducer, node) {
    return reducer.reduceVariableDeclarator(node, { binding: this[node.binding.type](reducer, node.binding), init: node.init && this[node.init.type](reducer, node.init) });
  },
  WhileStatement: function WhileStatement(reducer, node) {
    return reducer.reduceWhileStatement(node, { test: this[node.test.type](reducer, node.test), body: this[node.body.type](reducer, node.body) });
  },
  WithStatement: function WithStatement(reducer, node) {
    return reducer.reduceWithStatement(node, { object: this[node.object.type](reducer, node.object), body: this[node.body.type](reducer, node.body) });
  },
  YieldExpression: function YieldExpression(reducer, node) {
    return reducer.reduceYieldExpression(node, { expression: node.expression && this[node.expression.type](reducer, node.expression) });
  },
  YieldGeneratorExpression: function YieldGeneratorExpression(reducer, node) {
    return reducer.reduceYieldGeneratorExpression(node, { expression: this[node.expression.type](reducer, node.expression) });
  }
};

function reduce(reducer, node) {
  return director[node.type](reducer, node);
}
},{"./clone-reducer":3,"./monoidal-reducer":5}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2016 Shape Security, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Licensed under the Apache License, Version 2.0 (the "License")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _shiftAst = require('shift-ast');

var _shiftAst2 = _interopRequireDefault(_shiftAst);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MonoidalReducer = function () {
  function MonoidalReducer(monoid) {
    _classCallCheck(this, MonoidalReducer);

    this.identity = monoid.empty();
    var concat = monoid.prototype && monoid.prototype.concat || monoid.concat;
    this.append = function (a, b) {
      return concat.call(a, b);
    };
  }

  _createClass(MonoidalReducer, [{
    key: 'fold',
    value: function fold(list, a) {
      var _this = this;

      return list.reduce(function (memo, x) {
        return _this.append(memo, x);
      }, a == null ? this.identity : a);
    }
  }, {
    key: 'reduceArrayAssignmentTarget',
    value: function reduceArrayAssignmentTarget(node, _ref) {
      var elements = _ref.elements,
          rest = _ref.rest;

      return this.append(this.fold(elements.filter(function (n) {
        return n !== null;
      })), rest === null ? this.identity : rest);
    }
  }, {
    key: 'reduceArrayBinding',
    value: function reduceArrayBinding(node, _ref2) {
      var elements = _ref2.elements,
          rest = _ref2.rest;

      return this.append(this.fold(elements.filter(function (n) {
        return n !== null;
      })), rest === null ? this.identity : rest);
    }
  }, {
    key: 'reduceArrayExpression',
    value: function reduceArrayExpression(node, _ref3) {
      var elements = _ref3.elements;

      return this.fold(elements.filter(function (n) {
        return n !== null;
      }));
    }
  }, {
    key: 'reduceArrowExpression',
    value: function reduceArrowExpression(node, _ref4) {
      var params = _ref4.params,
          body = _ref4.body;

      return this.append(params, body);
    }
  }, {
    key: 'reduceAssignmentExpression',
    value: function reduceAssignmentExpression(node, _ref5) {
      var binding = _ref5.binding,
          expression = _ref5.expression;

      return this.append(binding, expression);
    }
  }, {
    key: 'reduceAssignmentTargetIdentifier',
    value: function reduceAssignmentTargetIdentifier(node) {
      return this.identity;
    }
  }, {
    key: 'reduceAssignmentTargetPropertyIdentifier',
    value: function reduceAssignmentTargetPropertyIdentifier(node, _ref6) {
      var binding = _ref6.binding,
          init = _ref6.init;

      return this.append(binding, init === null ? this.identity : init);
    }
  }, {
    key: 'reduceAssignmentTargetPropertyProperty',
    value: function reduceAssignmentTargetPropertyProperty(node, _ref7) {
      var name = _ref7.name,
          binding = _ref7.binding;

      return this.append(name, binding);
    }
  }, {
    key: 'reduceAssignmentTargetWithDefault',
    value: function reduceAssignmentTargetWithDefault(node, _ref8) {
      var binding = _ref8.binding,
          init = _ref8.init;

      return this.append(binding, init);
    }
  }, {
    key: 'reduceBinaryExpression',
    value: function reduceBinaryExpression(node, _ref9) {
      var left = _ref9.left,
          right = _ref9.right;

      return this.append(left, right);
    }
  }, {
    key: 'reduceBindingIdentifier',
    value: function reduceBindingIdentifier(node) {
      return this.identity;
    }
  }, {
    key: 'reduceBindingPropertyIdentifier',
    value: function reduceBindingPropertyIdentifier(node, _ref10) {
      var binding = _ref10.binding,
          init = _ref10.init;

      return this.append(binding, init === null ? this.identity : init);
    }
  }, {
    key: 'reduceBindingPropertyProperty',
    value: function reduceBindingPropertyProperty(node, _ref11) {
      var name = _ref11.name,
          binding = _ref11.binding;

      return this.append(name, binding);
    }
  }, {
    key: 'reduceBindingWithDefault',
    value: function reduceBindingWithDefault(node, _ref12) {
      var binding = _ref12.binding,
          init = _ref12.init;

      return this.append(binding, init);
    }
  }, {
    key: 'reduceBlock',
    value: function reduceBlock(node, _ref13) {
      var statements = _ref13.statements;

      return this.fold(statements);
    }
  }, {
    key: 'reduceBlockStatement',
    value: function reduceBlockStatement(node, _ref14) {
      var block = _ref14.block;

      return block;
    }
  }, {
    key: 'reduceBreakStatement',
    value: function reduceBreakStatement(node) {
      return this.identity;
    }
  }, {
    key: 'reduceCallExpression',
    value: function reduceCallExpression(node, _ref15) {
      var callee = _ref15.callee,
          _arguments = _ref15.arguments;

      return this.append(callee, this.fold(_arguments));
    }
  }, {
    key: 'reduceCatchClause',
    value: function reduceCatchClause(node, _ref16) {
      var binding = _ref16.binding,
          body = _ref16.body;

      return this.append(binding, body);
    }
  }, {
    key: 'reduceClassDeclaration',
    value: function reduceClassDeclaration(node, _ref17) {
      var name = _ref17.name,
          _super = _ref17.super,
          elements = _ref17.elements;

      return this.fold([name, _super === null ? this.identity : _super, this.fold(elements)]);
    }
  }, {
    key: 'reduceClassElement',
    value: function reduceClassElement(node, _ref18) {
      var method = _ref18.method;

      return method;
    }
  }, {
    key: 'reduceClassExpression',
    value: function reduceClassExpression(node, _ref19) {
      var name = _ref19.name,
          _super = _ref19.super,
          elements = _ref19.elements;

      return this.fold([name === null ? this.identity : name, _super === null ? this.identity : _super, this.fold(elements)]);
    }
  }, {
    key: 'reduceCompoundAssignmentExpression',
    value: function reduceCompoundAssignmentExpression(node, _ref20) {
      var binding = _ref20.binding,
          expression = _ref20.expression;

      return this.append(binding, expression);
    }
  }, {
    key: 'reduceComputedMemberAssignmentTarget',
    value: function reduceComputedMemberAssignmentTarget(node, _ref21) {
      var object = _ref21.object,
          expression = _ref21.expression;

      return this.append(object, expression);
    }
  }, {
    key: 'reduceComputedMemberExpression',
    value: function reduceComputedMemberExpression(node, _ref22) {
      var object = _ref22.object,
          expression = _ref22.expression;

      return this.append(object, expression);
    }
  }, {
    key: 'reduceComputedPropertyName',
    value: function reduceComputedPropertyName(node, _ref23) {
      var expression = _ref23.expression;

      return expression;
    }
  }, {
    key: 'reduceConditionalExpression',
    value: function reduceConditionalExpression(node, _ref24) {
      var test = _ref24.test,
          consequent = _ref24.consequent,
          alternate = _ref24.alternate;

      return this.fold([test, consequent, alternate]);
    }
  }, {
    key: 'reduceContinueStatement',
    value: function reduceContinueStatement(node) {
      return this.identity;
    }
  }, {
    key: 'reduceDataProperty',
    value: function reduceDataProperty(node, _ref25) {
      var name = _ref25.name,
          expression = _ref25.expression;

      return this.append(name, expression);
    }
  }, {
    key: 'reduceDebuggerStatement',
    value: function reduceDebuggerStatement(node) {
      return this.identity;
    }
  }, {
    key: 'reduceDirective',
    value: function reduceDirective(node) {
      return this.identity;
    }
  }, {
    key: 'reduceDoWhileStatement',
    value: function reduceDoWhileStatement(node, _ref26) {
      var body = _ref26.body,
          test = _ref26.test;

      return this.append(body, test);
    }
  }, {
    key: 'reduceEmptyStatement',
    value: function reduceEmptyStatement(node) {
      return this.identity;
    }
  }, {
    key: 'reduceExport',
    value: function reduceExport(node, _ref27) {
      var declaration = _ref27.declaration;

      return declaration;
    }
  }, {
    key: 'reduceExportAllFrom',
    value: function reduceExportAllFrom(node) {
      return this.identity;
    }
  }, {
    key: 'reduceExportDefault',
    value: function reduceExportDefault(node, _ref28) {
      var body = _ref28.body;

      return body;
    }
  }, {
    key: 'reduceExportFrom',
    value: function reduceExportFrom(node, _ref29) {
      var namedExports = _ref29.namedExports;

      return this.fold(namedExports);
    }
  }, {
    key: 'reduceExportFromSpecifier',
    value: function reduceExportFromSpecifier(node) {
      return this.identity;
    }
  }, {
    key: 'reduceExportLocalSpecifier',
    value: function reduceExportLocalSpecifier(node, _ref30) {
      var name = _ref30.name;

      return name;
    }
  }, {
    key: 'reduceExportLocals',
    value: function reduceExportLocals(node, _ref31) {
      var namedExports = _ref31.namedExports;

      return this.fold(namedExports);
    }
  }, {
    key: 'reduceExpressionStatement',
    value: function reduceExpressionStatement(node, _ref32) {
      var expression = _ref32.expression;

      return expression;
    }
  }, {
    key: 'reduceForInStatement',
    value: function reduceForInStatement(node, _ref33) {
      var left = _ref33.left,
          right = _ref33.right,
          body = _ref33.body;

      return this.fold([left, right, body]);
    }
  }, {
    key: 'reduceForOfStatement',
    value: function reduceForOfStatement(node, _ref34) {
      var left = _ref34.left,
          right = _ref34.right,
          body = _ref34.body;

      return this.fold([left, right, body]);
    }
  }, {
    key: 'reduceForStatement',
    value: function reduceForStatement(node, _ref35) {
      var init = _ref35.init,
          test = _ref35.test,
          update = _ref35.update,
          body = _ref35.body;

      return this.fold([init === null ? this.identity : init, test === null ? this.identity : test, update === null ? this.identity : update, body]);
    }
  }, {
    key: 'reduceFormalParameters',
    value: function reduceFormalParameters(node, _ref36) {
      var items = _ref36.items,
          rest = _ref36.rest;

      return this.append(this.fold(items), rest === null ? this.identity : rest);
    }
  }, {
    key: 'reduceFunctionBody',
    value: function reduceFunctionBody(node, _ref37) {
      var directives = _ref37.directives,
          statements = _ref37.statements;

      return this.append(this.fold(directives), this.fold(statements));
    }
  }, {
    key: 'reduceFunctionDeclaration',
    value: function reduceFunctionDeclaration(node, _ref38) {
      var name = _ref38.name,
          params = _ref38.params,
          body = _ref38.body;

      return this.fold([name, params, body]);
    }
  }, {
    key: 'reduceFunctionExpression',
    value: function reduceFunctionExpression(node, _ref39) {
      var name = _ref39.name,
          params = _ref39.params,
          body = _ref39.body;

      return this.fold([name === null ? this.identity : name, params, body]);
    }
  }, {
    key: 'reduceGetter',
    value: function reduceGetter(node, _ref40) {
      var name = _ref40.name,
          body = _ref40.body;

      return this.append(name, body);
    }
  }, {
    key: 'reduceIdentifierExpression',
    value: function reduceIdentifierExpression(node) {
      return this.identity;
    }
  }, {
    key: 'reduceIfStatement',
    value: function reduceIfStatement(node, _ref41) {
      var test = _ref41.test,
          consequent = _ref41.consequent,
          alternate = _ref41.alternate;

      return this.fold([test, consequent, alternate === null ? this.identity : alternate]);
    }
  }, {
    key: 'reduceImport',
    value: function reduceImport(node, _ref42) {
      var defaultBinding = _ref42.defaultBinding,
          namedImports = _ref42.namedImports;

      return this.append(defaultBinding === null ? this.identity : defaultBinding, this.fold(namedImports));
    }
  }, {
    key: 'reduceImportNamespace',
    value: function reduceImportNamespace(node, _ref43) {
      var defaultBinding = _ref43.defaultBinding,
          namespaceBinding = _ref43.namespaceBinding;

      return this.append(defaultBinding === null ? this.identity : defaultBinding, namespaceBinding);
    }
  }, {
    key: 'reduceImportSpecifier',
    value: function reduceImportSpecifier(node, _ref44) {
      var binding = _ref44.binding;

      return binding;
    }
  }, {
    key: 'reduceLabeledStatement',
    value: function reduceLabeledStatement(node, _ref45) {
      var body = _ref45.body;

      return body;
    }
  }, {
    key: 'reduceLiteralBooleanExpression',
    value: function reduceLiteralBooleanExpression(node) {
      return this.identity;
    }
  }, {
    key: 'reduceLiteralInfinityExpression',
    value: function reduceLiteralInfinityExpression(node) {
      return this.identity;
    }
  }, {
    key: 'reduceLiteralNullExpression',
    value: function reduceLiteralNullExpression(node) {
      return this.identity;
    }
  }, {
    key: 'reduceLiteralNumericExpression',
    value: function reduceLiteralNumericExpression(node) {
      return this.identity;
    }
  }, {
    key: 'reduceLiteralRegExpExpression',
    value: function reduceLiteralRegExpExpression(node) {
      return this.identity;
    }
  }, {
    key: 'reduceLiteralStringExpression',
    value: function reduceLiteralStringExpression(node) {
      return this.identity;
    }
  }, {
    key: 'reduceMethod',
    value: function reduceMethod(node, _ref46) {
      var name = _ref46.name,
          params = _ref46.params,
          body = _ref46.body;

      return this.fold([name, params, body]);
    }
  }, {
    key: 'reduceModule',
    value: function reduceModule(node, _ref47) {
      var directives = _ref47.directives,
          items = _ref47.items;

      return this.append(this.fold(directives), this.fold(items));
    }
  }, {
    key: 'reduceNewExpression',
    value: function reduceNewExpression(node, _ref48) {
      var callee = _ref48.callee,
          _arguments = _ref48.arguments;

      return this.append(callee, this.fold(_arguments));
    }
  }, {
    key: 'reduceNewTargetExpression',
    value: function reduceNewTargetExpression(node) {
      return this.identity;
    }
  }, {
    key: 'reduceObjectAssignmentTarget',
    value: function reduceObjectAssignmentTarget(node, _ref49) {
      var properties = _ref49.properties;

      return this.fold(properties);
    }
  }, {
    key: 'reduceObjectBinding',
    value: function reduceObjectBinding(node, _ref50) {
      var properties = _ref50.properties;

      return this.fold(properties);
    }
  }, {
    key: 'reduceObjectExpression',
    value: function reduceObjectExpression(node, _ref51) {
      var properties = _ref51.properties;

      return this.fold(properties);
    }
  }, {
    key: 'reduceReturnStatement',
    value: function reduceReturnStatement(node, _ref52) {
      var expression = _ref52.expression;

      return expression === null ? this.identity : expression;
    }
  }, {
    key: 'reduceScript',
    value: function reduceScript(node, _ref53) {
      var directives = _ref53.directives,
          statements = _ref53.statements;

      return this.append(this.fold(directives), this.fold(statements));
    }
  }, {
    key: 'reduceSetter',
    value: function reduceSetter(node, _ref54) {
      var name = _ref54.name,
          param = _ref54.param,
          body = _ref54.body;

      return this.fold([name, param, body]);
    }
  }, {
    key: 'reduceShorthandProperty',
    value: function reduceShorthandProperty(node, _ref55) {
      var name = _ref55.name;

      return name;
    }
  }, {
    key: 'reduceSpreadElement',
    value: function reduceSpreadElement(node, _ref56) {
      var expression = _ref56.expression;

      return expression;
    }
  }, {
    key: 'reduceStaticMemberAssignmentTarget',
    value: function reduceStaticMemberAssignmentTarget(node, _ref57) {
      var object = _ref57.object;

      return object;
    }
  }, {
    key: 'reduceStaticMemberExpression',
    value: function reduceStaticMemberExpression(node, _ref58) {
      var object = _ref58.object;

      return object;
    }
  }, {
    key: 'reduceStaticPropertyName',
    value: function reduceStaticPropertyName(node) {
      return this.identity;
    }
  }, {
    key: 'reduceSuper',
    value: function reduceSuper(node) {
      return this.identity;
    }
  }, {
    key: 'reduceSwitchCase',
    value: function reduceSwitchCase(node, _ref59) {
      var test = _ref59.test,
          consequent = _ref59.consequent;

      return this.append(test, this.fold(consequent));
    }
  }, {
    key: 'reduceSwitchDefault',
    value: function reduceSwitchDefault(node, _ref60) {
      var consequent = _ref60.consequent;

      return this.fold(consequent);
    }
  }, {
    key: 'reduceSwitchStatement',
    value: function reduceSwitchStatement(node, _ref61) {
      var discriminant = _ref61.discriminant,
          cases = _ref61.cases;

      return this.append(discriminant, this.fold(cases));
    }
  }, {
    key: 'reduceSwitchStatementWithDefault',
    value: function reduceSwitchStatementWithDefault(node, _ref62) {
      var discriminant = _ref62.discriminant,
          preDefaultCases = _ref62.preDefaultCases,
          defaultCase = _ref62.defaultCase,
          postDefaultCases = _ref62.postDefaultCases;

      return this.fold([discriminant, this.fold(preDefaultCases), defaultCase, this.fold(postDefaultCases)]);
    }
  }, {
    key: 'reduceTemplateElement',
    value: function reduceTemplateElement(node) {
      return this.identity;
    }
  }, {
    key: 'reduceTemplateExpression',
    value: function reduceTemplateExpression(node, _ref63) {
      var tag = _ref63.tag,
          elements = _ref63.elements;

      return this.append(tag === null ? this.identity : tag, this.fold(elements));
    }
  }, {
    key: 'reduceThisExpression',
    value: function reduceThisExpression(node) {
      return this.identity;
    }
  }, {
    key: 'reduceThrowStatement',
    value: function reduceThrowStatement(node, _ref64) {
      var expression = _ref64.expression;

      return expression;
    }
  }, {
    key: 'reduceTryCatchStatement',
    value: function reduceTryCatchStatement(node, _ref65) {
      var body = _ref65.body,
          catchClause = _ref65.catchClause;

      return this.append(body, catchClause);
    }
  }, {
    key: 'reduceTryFinallyStatement',
    value: function reduceTryFinallyStatement(node, _ref66) {
      var body = _ref66.body,
          catchClause = _ref66.catchClause,
          finalizer = _ref66.finalizer;

      return this.fold([body, catchClause === null ? this.identity : catchClause, finalizer]);
    }
  }, {
    key: 'reduceUnaryExpression',
    value: function reduceUnaryExpression(node, _ref67) {
      var operand = _ref67.operand;

      return operand;
    }
  }, {
    key: 'reduceUpdateExpression',
    value: function reduceUpdateExpression(node, _ref68) {
      var operand = _ref68.operand;

      return operand;
    }
  }, {
    key: 'reduceVariableDeclaration',
    value: function reduceVariableDeclaration(node, _ref69) {
      var declarators = _ref69.declarators;

      return this.fold(declarators);
    }
  }, {
    key: 'reduceVariableDeclarationStatement',
    value: function reduceVariableDeclarationStatement(node, _ref70) {
      var declaration = _ref70.declaration;

      return declaration;
    }
  }, {
    key: 'reduceVariableDeclarator',
    value: function reduceVariableDeclarator(node, _ref71) {
      var binding = _ref71.binding,
          init = _ref71.init;

      return this.append(binding, init === null ? this.identity : init);
    }
  }, {
    key: 'reduceWhileStatement',
    value: function reduceWhileStatement(node, _ref72) {
      var test = _ref72.test,
          body = _ref72.body;

      return this.append(test, body);
    }
  }, {
    key: 'reduceWithStatement',
    value: function reduceWithStatement(node, _ref73) {
      var object = _ref73.object,
          body = _ref73.body;

      return this.append(object, body);
    }
  }, {
    key: 'reduceYieldExpression',
    value: function reduceYieldExpression(node, _ref74) {
      var expression = _ref74.expression;

      return expression === null ? this.identity : expression;
    }
  }, {
    key: 'reduceYieldGeneratorExpression',
    value: function reduceYieldGeneratorExpression(node, _ref75) {
      var expression = _ref75.expression;

      return expression;
    }
  }]);

  return MonoidalReducer;
}();

exports.default = MonoidalReducer;
},{"shift-ast":2}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = annotate;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Copyright 2017 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function insertInto(annotations, index, text, afterExisting) {
  for (var i = 0; i < annotations.length; ++i) {
    if (annotations[i].index >= index) {
      if (afterExisting) {
        while (i < annotations.length && annotations[i].index === index) {
          ++i;
        }
      }

      annotations.splice(i, 0, { index, text });
      return;
    }
  }
  annotations.push({ index, text });
}

class Info {
  constructor() {
    this.declares = [];
    this.reads = [];
    this.writes = [];
    this.deletes = [];
    this.scopes = [];
  }
}

class DefaultMap extends Map {
  constructor(thunk) {
    super();
    this.thunk = thunk;
  }

  get(v) {
    if (!this.has(v)) {
      this.set(v, this.thunk());
    }
    return super.get(v);
  }
}

function annotate(_ref) {
  var source = _ref.source,
      locations = _ref.locations,
      globalScope = _ref.globalScope,
      _ref$skipUnambiguous = _ref.skipUnambiguous,
      skipUnambiguous = _ref$skipUnambiguous === undefined ? false : _ref$skipUnambiguous,
      _ref$skipScopes = _ref.skipScopes,
      skipScopes = _ref$skipScopes === undefined ? false : _ref$skipScopes;


  var nodeInfo = new DefaultMap(function () {
    return new Info();
  });

  var vars = new DefaultMap(function () {
    return [];
  }); // MultiMap, I guess?

  function addVariable(v) {
    vars.get(v.name).push(v);
    v.declarations.forEach(function (d) {
      nodeInfo.get(d.node).declares.push(v);
    });
    v.references.forEach(function (r) {
      var info = nodeInfo.get(r.node);
      if (r.accessibility.isDelete) {
        if (r.accessibility.isRead || r.accessibility.isWrite) {
          throw new Error('some reference is a delete *and* something else');
        }
        info.deletes.push(v);
      } else {
        if (r.accessibility.isRead) {
          info.reads.push(v);
        }
        if (r.accessibility.isWrite) {
          info.writes.push(v);
        }
      }
    });
  }

  (function visit(scope) {
    if (!skipScopes) nodeInfo.get(scope.astNode).scopes.push(scope);
    scope.variables.forEach(addVariable);
    scope.children.forEach(visit);
  })(globalScope);

  // an annotation is { index, text }
  var annotations = [];

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = nodeInfo.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _ref2 = _step.value;

      var _ref3 = _slicedToArray(_ref2, 2);

      var node = _ref3[0];
      var info = _ref3[1];

      var location = locations.get(node);
      if (info.scopes.length > 0) {
        if (info.declares.length !== 0 || info.reads.length !== 0 || info.writes.length !== 0 || info.deletes.length !== 0) {
          throw new Error('unhandled condition: node is scope and reference');
        }

        var _arr = [].concat(_toConsumableArray(info.scopes));

        for (var _i = 0; _i < _arr.length; _i++) {
          var scope = _arr[_i];
          var scopeVars = [].concat(_toConsumableArray(scope.variables.values()));
          var _text = 'Scope (' + scope.type.name + ')';
          if (scopeVars.length > 0) {
            _text += ' declaring ' + scopeVars.map(function (v) {
              return v.name + '#' + vars.get(v.name).indexOf(v);
            }).join(', ');
          }
          insertInto(annotations, location.start.offset, '/* ' + _text + ' */', true);
          insertInto(annotations, location.end.offset, '/* end scope */', true);
        }
      } else if (info.deletes.length > 0) {
        var deletes = skipUnambiguous ? info.deletes.filter(function (v) {
          return vars.get(v.name).length > 1;
        }) : info.deletes;
        if (deletes.length > 0) {
          insertInto(annotations, location.end.offset, '/* deletes ' + deletes.map(function (v) {
            return v.name + '#' + vars.get(v.name).indexOf(v);
          }).join(', ') + ' */', false);
        }
      } else {
        var _text2 = '';
        var declares = skipUnambiguous ? info.declares.filter(function (v) {
          return vars.get(v.name).length > 1;
        }) : info.declares;
        if (declares.length > 0) {
          _text2 += 'declares ' + declares.map(function (v) {
            return v.name + '#' + vars.get(v.name).indexOf(v);
          }).join(', ');
        }
        var reads = skipUnambiguous ? info.reads.filter(function (v) {
          return vars.get(v.name).length > 1;
        }) : info.reads;
        if (reads.length > 0) {
          if (_text2.length > 0) _text2 += '; ';
          _text2 += 'reads ' + reads.map(function (v) {
            return v.name + '#' + vars.get(v.name).indexOf(v);
          }).join(', ');
        }
        var writes = skipUnambiguous ? info.writes.filter(function (v) {
          return vars.get(v.name).length > 1;
        }) : info.writes;
        if (writes.length > 0) {
          if (_text2.length > 0) _text2 += '; ';
          _text2 += 'writes ' + writes.map(function (v) {
            return v.name + '#' + vars.get(v.name).indexOf(v);
          }).join(', ');
        }
        if (_text2 !== '') {
          insertInto(annotations, location.end.offset, '/* ' + _text2 + ' */', false);
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var out = '';
  var previousIndex = 0;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = annotations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _ref4 = _step2.value;
      var index = _ref4.index;
      var text = _ref4.text;

      out += source.substring(previousIndex, index) + text;
      previousIndex = index;
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  out += source.substring(previousIndex);
  return out;
}
},{}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright 2015 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class DeclarationType {
  constructor(name, isBlockScoped) {
    this.name = name;
    this.isBlockScoped = !!isBlockScoped;
    this.isFunctionScoped = !isBlockScoped;
  }
}

exports.DeclarationType = DeclarationType;
class BlockScopedDeclaration extends DeclarationType {
  constructor(name) {
    super(name, true);
  }
}

exports.BlockScopedDeclaration = BlockScopedDeclaration;
class FunctionScopedDeclaration extends DeclarationType {
  constructor(name) {
    super(name, false);
  }
}

exports.FunctionScopedDeclaration = FunctionScopedDeclaration;
DeclarationType.VAR = new FunctionScopedDeclaration('Var');
DeclarationType.CONST = new BlockScopedDeclaration('Const');
DeclarationType.LET = new BlockScopedDeclaration('Let');
DeclarationType.FUNCTION_DECLARATION = new BlockScopedDeclaration('FunctionDeclaration'); // potentially also `FunctionScoped` versions of this, for functions at top of functions/etc?
DeclarationType.FUNCTION_VAR_DECLARATION = new FunctionScopedDeclaration('FunctionB33'); // The additional variable created by B.3.3.
DeclarationType.FUNCTION_NAME = new BlockScopedDeclaration('FunctionExpressionName');
DeclarationType.CLASS_DECLARATION = new BlockScopedDeclaration('ClassDeclaration');
DeclarationType.CLASS_NAME = new BlockScopedDeclaration('ClassName');
DeclarationType.PARAMETER = new FunctionScopedDeclaration('Parameter');
DeclarationType.CATCH_PARAMETER = new BlockScopedDeclaration('CatchParam');
DeclarationType.IMPORT = new BlockScopedDeclaration('Import');

DeclarationType.fromVarDeclKind = function (variableDeclarationKind) {
  switch (variableDeclarationKind) {
    case 'var':
      return DeclarationType.VAR;
    case 'const':
      return DeclarationType.CONST;
    case 'let':
      return DeclarationType.LET;
    default:
      throw new Error('Invalid VariableDeclarationKind: ' + JSON.stringify(variableDeclarationKind));
  }
};

class Declaration {
  constructor(node, type) {
    this.node = node;
    this.type = type;
  }
}
exports.Declaration = Declaration;
},{}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _shiftReducer = require('shift-reducer');

var _shiftReducer2 = _interopRequireDefault(_shiftReducer);

var _shiftSpec = require('shift-spec');

var _shiftSpec2 = _interopRequireDefault(_shiftSpec);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO this file should live elsewhere

/**
 * Copyright 2015 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class ListMonoid {
  constructor(list) {
    this.list = list;
  }

  static empty() {
    return new ListMonoid([]);
  }

  concat(b) {
    return new ListMonoid(this.list.concat(b.list));
  }

  extract() {
    return this.list;
  }
}

// Gives a flat list of all nodes rooted at the given node, in preorder: that is, a node appears before its children.
class Flattener extends _shiftReducer.MonoidalReducer {
  // We explicitly invoke Monoidal.prototype methods so that we can automatically generate methods from the spec.
  constructor() {
    super(ListMonoid);
  }

  static flatten(node) {
    return (0, _shiftReducer2.default)(new this(), node).extract();
  }
}

exports.default = Flattener;

var _loop = function _loop(typeName) {
  Object.defineProperty(Flattener.prototype, `reduce${typeName}`, {
    value(node, state) {
      return new ListMonoid([node]).concat(_shiftReducer.MonoidalReducer.prototype[`reduce${typeName}`].call(this, node, state));
    }
  });
};

var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = undefined;

try {
  for (var _iterator = Object.keys(_shiftSpec2.default)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    var typeName = _step.value;

    _loop(typeName);
  }
} catch (err) {
  _didIteratorError = true;
  _iteratorError = err;
} finally {
  try {
    if (!_iteratorNormalCompletion && _iterator.return) {
      _iterator.return();
    }
  } finally {
    if (_didIteratorError) {
      throw _iteratorError;
    }
  }
}
},{"shift-reducer":4,"shift-spec":19}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.serialize = exports.Accessibility = exports.DeclarationType = exports.ScopeType = exports.annotate = exports.ScopeLookup = undefined;

var _scopeLookup = require('./scope-lookup');

Object.defineProperty(exports, 'ScopeLookup', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_scopeLookup).default;
  }
});

var _annotateSource = require('./annotate-source');

Object.defineProperty(exports, 'annotate', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_annotateSource).default;
  }
});

var _scope = require('./scope');

Object.defineProperty(exports, 'ScopeType', {
  enumerable: true,
  get: function get() {
    return _scope.ScopeType;
  }
});

var _declaration = require('./declaration');

Object.defineProperty(exports, 'DeclarationType', {
  enumerable: true,
  get: function get() {
    return _declaration.DeclarationType;
  }
});

var _reference = require('./reference');

Object.defineProperty(exports, 'Accessibility', {
  enumerable: true,
  get: function get() {
    return _reference.Accessibility;
  }
});

var _scopeSerializer = require('./scope-serializer');

Object.defineProperty(exports, 'serialize', {
  enumerable: true,
  get: function get() {
    return _scopeSerializer.serialize;
  }
});
exports.default = analyze;

var _scopeAnalyzer = require('./scope-analyzer');

var _scopeAnalyzer2 = _interopRequireDefault(_scopeAnalyzer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function analyze(script) {
  return _scopeAnalyzer2.default.analyze(script);
}
},{"./annotate-source":6,"./declaration":7,"./reference":10,"./scope":15,"./scope-analyzer":11,"./scope-lookup":12,"./scope-serializer":13}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright 2015 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class Accessibility {
  constructor(isRead, isWrite, isDelete) {
    this.isRead = !!isRead;
    this.isWrite = !!isWrite;
    this.isReadWrite = !!(isRead && isWrite);
    this.isDelete = !!isDelete;
  }
}

exports.Accessibility = Accessibility;
Accessibility.READ = new Accessibility(true, false, false);
Accessibility.WRITE = new Accessibility(false, true, false);
Accessibility.READWRITE = new Accessibility(true, true, false);
Accessibility.DELETE = new Accessibility(false, false, true);

class Reference {
  constructor(node, accessibility) {
    this.node = node;
    this.accessibility = accessibility;
  }
}
exports.Reference = Reference;
},{}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _multimap = require('multimap');

var _multimap2 = _interopRequireDefault(_multimap);

var _shiftReducer = require('shift-reducer');

var _shiftReducer2 = _interopRequireDefault(_shiftReducer);

var _scopeState = require('./scope-state');

var _scopeState2 = _interopRequireDefault(_scopeState);

var _reference = require('./reference');

var _declaration = require('./declaration');

var _scope = require('./scope');

var _strictnessReducer = require('./strictness-reducer');

var _strictnessReducer2 = _interopRequireDefault(_strictnessReducer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /**
                                                                                                                                                                                                     * Copyright 2015 Shape Security, Inc.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * Licensed under the Apache License, Version 2.0 (the "License")
                                                                                                                                                                                                     * you may not use this file except in compliance with the License.
                                                                                                                                                                                                     * You may obtain a copy of the License at
                                                                                                                                                                                                     *
                                                                                                                                                                                                     *     http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                     * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                     * See the License for the specific language governing permissions and
                                                                                                                                                                                                     * limitations under the License.
                                                                                                                                                                                                     */

function getFunctionDeclarations(statements) {
  return statements.filter(function (s) {
    return s.type === 'FunctionDeclaration';
  }).map(function (f) {
    return f.name;
  });
}

class ScopeAnalyzer extends _shiftReducer.MonoidalReducer {
  constructor(program) {
    super(_scopeState2.default);
    this.sloppySet = program.type === 'Script' ? _strictnessReducer2.default.analyze(program) : new Set();
  }

  static analyze(program) {
    return (0, _shiftReducer2.default)(new this(program), program).children[0];
  }

  finishFunction(fnNode, params, body) {
    var isArrowFn = fnNode.type === 'ArrowExpression';
    var fnType = isArrowFn ? _scope.ScopeType.ARROW_FUNCTION : _scope.ScopeType.FUNCTION;
    var opts = { shouldResolveArguments: !isArrowFn, shouldB33: this.sloppySet.has(fnNode) };
    if (params.hasParameterExpressions) {
      return params.withoutParameterExpressions().concat(body.finish(fnNode, fnType, { isFunctionWithParameterExpressions: true })).finish(fnNode, _scope.ScopeType.PARAMETERS, opts);
    }
    return params.concat(body).finish(fnNode, fnType, opts);
  }

  reduceArrowExpression(node, _ref) {
    var params = _ref.params,
        body = _ref.body;

    return this.finishFunction(node, params, body);
  }

  reduceAssignmentExpression(node, _ref2) {
    var binding = _ref2.binding,
        expression = _ref2.expression;

    return super.reduceAssignmentExpression(node, {
      binding: binding.addReferences(_reference.Accessibility.WRITE),
      expression
    });
  }

  reduceAssignmentTargetIdentifier(node) {
    return new _scopeState2.default({ atsForParent: [node] });
  }

  reduceBindingIdentifier(node) {
    if (node.name === '*default*') {
      return new _scopeState2.default();
    }
    return new _scopeState2.default({ bindingsForParent: [node] });
  }

  reduceBindingPropertyIdentifier(node, _ref3) {
    var binding = _ref3.binding,
        init = _ref3.init;

    var s = super.reduceBindingPropertyIdentifier(node, { binding, init });
    if (init) {
      return s.withParameterExpressions();
    }
    return s;
  }

  reduceBindingWithDefault(node, _ref4) {
    var binding = _ref4.binding,
        init = _ref4.init;

    return super.reduceBindingWithDefault(node, { binding, init }).withParameterExpressions();
  }

  reduceBlock(node, _ref5) {
    var statements = _ref5.statements;

    return super.reduceBlock(node, { statements }).withPotentialVarFunctions(getFunctionDeclarations(node.statements)).finish(node, _scope.ScopeType.BLOCK);
  }

  reduceCallExpression(node, _ref6) {
    var callee = _ref6.callee,
        _arguments = _ref6.arguments;

    var s = super.reduceCallExpression(node, { callee, arguments: _arguments });
    if (node.callee.type === 'IdentifierExpression' && node.callee.name === 'eval') {
      return s.taint();
    }
    return s;
  }

  reduceCatchClause(node, _ref7) {
    var binding = _ref7.binding,
        body = _ref7.body;

    return super.reduceCatchClause(node, {
      binding: binding.addDeclarations(_declaration.DeclarationType.CATCH_PARAMETER),
      body
    }).finish(node, _scope.ScopeType.CATCH);
  }

  reduceClassDeclaration(node, _ref8) {
    var name = _ref8.name,
        _super = _ref8.super,
        elements = _ref8.elements;

    var s = super.reduceClassDeclaration(node, { name, super: _super, elements }).addDeclarations(_declaration.DeclarationType.CLASS_NAME).finish(node, _scope.ScopeType.CLASS_NAME);
    return s.concat(name.addDeclarations(_declaration.DeclarationType.CLASS_DECLARATION));
  }

  reduceClassExpression(node, _ref9) {
    var name = _ref9.name,
        _super = _ref9.super,
        elements = _ref9.elements;

    return super.reduceClassExpression(node, { name, super: _super, elements }).addDeclarations(_declaration.DeclarationType.CLASS_NAME).finish(node, _scope.ScopeType.CLASS_NAME);
  }

  reduceCompoundAssignmentExpression(node, _ref10) {
    var binding = _ref10.binding,
        expression = _ref10.expression;

    return super.reduceCompoundAssignmentExpression(node, {
      binding: binding.addReferences(_reference.Accessibility.READWRITE),
      expression
    });
  }

  reduceComputedMemberExpression(node, _ref11) {
    var object = _ref11.object,
        expression = _ref11.expression;

    return super.reduceComputedMemberExpression(node, { object, expression }).withParameterExpressions();
  }

  reduceForInStatement(node, _ref12) {
    var left = _ref12.left,
        right = _ref12.right,
        body = _ref12.body;

    return super.reduceForInStatement(node, { left: left.addReferences(_reference.Accessibility.WRITE), right, body }).finish(node, _scope.ScopeType.BLOCK);
  }

  reduceForOfStatement(node, _ref13) {
    var left = _ref13.left,
        right = _ref13.right,
        body = _ref13.body;

    return super.reduceForOfStatement(node, { left: left.addReferences(_reference.Accessibility.WRITE), right, body }).finish(node, _scope.ScopeType.BLOCK);
  }

  reduceForStatement(node, _ref14) {
    var init = _ref14.init,
        test = _ref14.test,
        update = _ref14.update,
        body = _ref14.body;

    return super.reduceForStatement(node, {
      init: init ? init.withoutBindingsForParent() : init,
      test,
      update,
      body
    }).finish(node, _scope.ScopeType.BLOCK);
  }

  reduceFormalParameters(node, _ref15) {
    var items = _ref15.items,
        rest = _ref15.rest;

    var s = rest ? rest : new _scopeState2.default();
    items.forEach(function (item, ind) {
      s = s.concat(item.hasParameterExpressions ? item.finish(node.items[ind], _scope.ScopeType.PARAMETER_EXPRESSION) : item);
    });
    return s.addDeclarations(_declaration.DeclarationType.PARAMETER);
  }

  reduceFunctionDeclaration(node, _ref16) {
    var name = _ref16.name,
        params = _ref16.params,
        body = _ref16.body;

    return name.concat(this.finishFunction(node, params, body)).addFunctionDeclaration();
  }

  reduceFunctionExpression(node, _ref17) {
    var name = _ref17.name,
        params = _ref17.params,
        body = _ref17.body;

    var s = this.finishFunction(node, params, body);
    if (name) {
      return name.concat(s).addDeclarations(_declaration.DeclarationType.FUNCTION_NAME).finish(node, _scope.ScopeType.FUNCTION_NAME);
    }
    return s;
  }

  reduceGetter(node, _ref18) {
    var name = _ref18.name,
        body = _ref18.body;

    return name.concat(body.finish(node, _scope.ScopeType.FUNCTION, {
      shouldResolveArguments: true,
      shouldB33: this.sloppySet.has(node)
    }));
  }

  reduceIdentifierExpression(node) {
    return new _scopeState2.default({
      freeIdentifiers: new _multimap2.default([[node.name, new _reference.Reference(node, _reference.Accessibility.READ)]])
    });
  }

  reduceIfStatement(node, _ref19) {
    var test = _ref19.test,
        consequent = _ref19.consequent,
        alternate = _ref19.alternate;

    var pvsfd = [];
    if (node.consequent.type === 'FunctionDeclaration') {
      pvsfd.push(node.consequent.name);
    }
    if (node.alternate && node.alternate.type === 'FunctionDeclaration') {
      pvsfd.push(node.alternate.name);
    }
    return super.reduceIfStatement(node, { test, consequent, alternate }).withPotentialVarFunctions(pvsfd);
  }

  reduceImport(node, _ref20) {
    var moduleSpecifier = _ref20.moduleSpecifier,
        defaultBinding = _ref20.defaultBinding,
        namedImports = _ref20.namedImports;

    return super.reduceImport(node, { moduleSpecifier, defaultBinding, namedImports }).addDeclarations(_declaration.DeclarationType.IMPORT);
  }

  reduceMethod(node, _ref21) {
    var name = _ref21.name,
        params = _ref21.params,
        body = _ref21.body;

    return name.concat(this.finishFunction(node, params, body));
  }

  reduceModule(node, _ref22) {
    var directives = _ref22.directives,
        items = _ref22.items;

    return super.reduceModule(node, { directives, items }).finish(node, _scope.ScopeType.MODULE);
  }

  reduceScript(node, _ref23) {
    var directives = _ref23.directives,
        statements = _ref23.statements;

    return super.reduceScript(node, { directives, statements }).finish(node, _scope.ScopeType.SCRIPT, { shouldB33: !node.directives.some(function (d) {
        return d.rawValue === 'use strict';
      }) });
  }

  reduceSetter(node, _ref24) {
    var name = _ref24.name,
        param = _ref24.param,
        body = _ref24.body;

    if (param.hasParameterExpressions) {
      param = param.finish(node, _scope.ScopeType.PARAMETER_EXPRESSION);
    }
    return name.concat(this.finishFunction(node, param.addDeclarations(_declaration.DeclarationType.PARAMETER), body));
  }

  reduceSwitchStatement(node, _ref25) {
    var discriminant = _ref25.discriminant,
        cases = _ref25.cases;

    return this.fold(cases).finish(node, _scope.ScopeType.BLOCK).withPotentialVarFunctions(getFunctionDeclarations([].concat(_toConsumableArray(node.cases.map(function (c) {
      return c.consequent;
    }))))).concat(discriminant);
  }

  reduceSwitchStatementWithDefault(node, _ref26) {
    var discriminant = _ref26.discriminant,
        preDefaultCases = _ref26.preDefaultCases,
        defaultCase = _ref26.defaultCase,
        postDefaultCases = _ref26.postDefaultCases;

    var functionDeclarations = getFunctionDeclarations([].concat(_toConsumableArray(node.preDefaultCases.concat([node.defaultCase], node.postDefaultCases).map(function (c) {
      return c.consequent;
    }))));
    var cases = preDefaultCases.concat([defaultCase], postDefaultCases);
    return this.fold(cases).finish(node, _scope.ScopeType.BLOCK).withPotentialVarFunctions(functionDeclarations).concat(discriminant);
  }

  reduceUnaryExpression(node, _ref27) {
    var operand = _ref27.operand;

    if (node.operator === 'delete' && node.operand.type === 'IdentifierExpression') {
      // 'delete x' is a special case.
      return new _scopeState2.default({ freeIdentifiers: new _multimap2.default([[node.operand.name, new _reference.Reference(node.operand, _reference.Accessibility.DELETE)]]) });
    }
    return super.reduceUnaryExpression(node, { operand });
  }

  reduceUpdateExpression(node, _ref28) {
    var operand = _ref28.operand;

    return operand.addReferences(_reference.Accessibility.READWRITE);
  }

  reduceVariableDeclaration(node, _ref29) {
    var declarators = _ref29.declarators;

    return super.reduceVariableDeclaration(node, { declarators }).addDeclarations(_declaration.DeclarationType.fromVarDeclKind(node.kind), true);
    // passes bindingsForParent up, for for-in and for-of to add their write-references
  }

  reduceVariableDeclarationStatement(node, _ref30) {
    var declaration = _ref30.declaration;

    return declaration.withoutBindingsForParent();
  }

  reduceVariableDeclarator(node, _ref31) {
    var binding = _ref31.binding,
        init = _ref31.init;

    var s = super.reduceVariableDeclarator(node, { binding, init });
    if (init) {
      return s.addReferences(_reference.Accessibility.WRITE, true);
    }
    return s;
  }

  reduceWithStatement(node, _ref32) {
    var object = _ref32.object,
        body = _ref32.body;

    return super.reduceWithStatement(node, { object, body: body.finish(node, _scope.ScopeType.WITH) });
  }
}
exports.default = ScopeAnalyzer;
},{"./declaration":7,"./reference":10,"./scope":15,"./scope-state":14,"./strictness-reducer":16,"multimap":18,"shift-reducer":4}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _multimap = require('multimap');

var _multimap2 = _interopRequireDefault(_multimap);

var _scope = require('./scope');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright 2015 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class ScopeLookup {
  constructor(globalScope) {
    var _this = this;

    this.scope = globalScope;
    this.variableMap = new _multimap2.default();

    var addVariable = function addVariable(v) {
      v.declarations.forEach(function (decl) {
        return _this.variableMap.set(decl.node, v);
      });
      v.references.forEach(function (ref) {
        if (!_this.variableMap.has(ref.node) || _this.variableMap.get(ref.node).indexOf(v) === -1) {
          _this.variableMap.set(ref.node, v);
        }
      });
    };
    (function addVariables(scope) {
      scope.children.forEach(addVariables);
      scope.variables.forEach(addVariable);
    })(globalScope);
  }

  lookup(node) {
    /* Gives a map from BindingIdentifiers and IdentifierExpressions to a list of Variables.
    Assuming that the given node is defined in the scope, the map always returns at least one Variable.
    It will return two in precisely three cases:
    `try{}catch(e){var e = ...}`, function declarations in blocks for which annex B.3.3 applies, and class declarations.
    In this case the same identifier refers to two variables.
    Both are returned, with the block-scoped variable being returned first in the first two cases, and the inner variable
    being returned first in the third case. */
    return this.variableMap.get(node);
  }

  isGlobal(node) {
    return this.scope instanceof _scope.GlobalScope && this.variableMap.has(node);
  }
}
exports.default = ScopeLookup;
},{"./scope":15,"multimap":18}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.serialize = serialize;

var _flattener = require('./flattener');

var _flattener2 = _interopRequireDefault(_flattener);

var _declaration = require('./declaration');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright 2015 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class Serializer {
  constructor(scope) {
    var _this = this;

    this.scope = scope;
    var nodes = _flattener2.default.flatten(scope.astNode);
    this.ids = new Map();
    nodes.forEach(function (n) {
      return _this.ids.set(n, _this.ids.size);
    });
    this.declarationCompare = declarationCompare.bind(this, this.ids);
    this.referenceCompare = referenceCompare.bind(this, this.ids);
    this.variableCompare = variableCompare.bind(this, this.ids);
  }

  serialize() {
    return this.serializeScope(this.scope);
  }

  serializeScope(scope) {
    return `{"node": "${this.serializeNode(scope.astNode)}"` + `, "type": "${scope.type.name}"` + `, "isDynamic": ${scope.dynamic}` + `, "through": ${this.serializeReferenceList(this.collectThrough(scope.through))}` + `, "variables": ${this.serializeVariableList(scope.variableList)}` + `, "children": [${scope.children.map(this.serializeScope.bind(this)).join(', ')}]` + '}';
  }

  serializeNode(node) {
    if (node.type === 'IdentifierExpression') {
      return 'IdentifierExpression(' + node.name + ')_' + this.ids.get(node);
    } else if (node.type === 'AssignmentTargetIdentifier') {
      return 'AssignmentTargetIdentifier(' + node.name + ')_' + this.ids.get(node);
    } else if (node.type === 'BindingIdentifier') {
      return 'BindingIdentifier(' + node.name + ')_' + this.ids.get(node);
    }
    return node.type + '_' + this.ids.get(node);
  }

  collectThrough(through) {
    var references = [];
    through.forEach(function (v) {
      return references.push(v);
    });
    return references.sort(this.referenceCompare);
  }

  serializeReference(reference) {
    return `{"node": "${this.serializeNode(reference.node)}"` + `, "accessibility": "${reference.accessibility.isDelete ? 'Delete' : ''}${reference.accessibility.isRead ? 'Read' : ''}${reference.accessibility.isWrite ? 'Write' : ''}"` + '}';
  }

  serializeReferenceList(references) {
    return `[${references.map(this.serializeReference.bind(this)).join(', ')}]`;
  }

  serializeDeclaration(declaration) {
    return `{"node": "${this.serializeNode(declaration.node)}"` + `, "kind": "${declaration.type.name}"` + '}';
  }

  serializeVariable(variable) {
    return `{"name": "${variable.name}"` + `, "references": ${this.serializeReferenceList(variable.references)}` + `, "declarations": [${variable.declarations.map(this.serializeDeclaration.bind(this)).join(', ')}]` + '}';
  }

  serializeVariableList(variables) {
    variables = variables.slice(0).sort(this.variableCompare);
    return `[${variables.map(this.serializeVariable.bind(this)).join(', ')}]`;
  }
}

function declarationCompare(ids, d1, d2) {
  function kindToInd(kind) {
    switch (kind) {
      case _declaration.DeclarationType.VAR:
        return 0;
      case _declaration.DeclarationType.CONST:
        return 1;
      case _declaration.DeclarationType.LET:
        return 2;
      case _declaration.DeclarationType.FUNCTION_DECLARATION:
        return 3;
      case _declaration.DeclarationType.FUNCTION_VAR_DECLARATION:
        return 4;
      case _declaration.DeclarationType.FUNCTION_NAME:
        return 5;
      case _declaration.DeclarationType.CLASS_NAME:
        return 6;
      case _declaration.DeclarationType.PARAMETER:
        return 7;
      case _declaration.DeclarationType.CATCH_PARAMETER:
        return 8;
      case _declaration.DeclarationType.IMPORT:
        return 9;
      default:
        throw 'Unrecognized declaration type';
    }
  }
  var comparison = kindToInd(d1.type) - kindToInd(d2.type);
  if (comparison !== 0) {
    return comparison;
  }
  return ids.get(d1.node) - ids.get(d2.node);
}

function referenceCompare(ids, r1, r2) {
  var comparison = (r1.accessibility.isRead ? 1 : 0) + (r1.accessibility.isWrite ? 2 : 0) + (r1.accessibility.isDelete ? 4 : 0) - ((r2.accessibility.isRead ? 1 : 0) + (r2.accessibility.isWrite ? 2 : 0) + (r2.accessibility.isDelete ? 4 : 0));
  if (comparison !== 0) {
    return comparison;
  }
  return ids.get(r1.node) - ids.get(r2.node);
}

function variableCompare(ids, v1, v2) {
  if (v1.name < v2.name) {
    return -1;
  }
  if (v1.name > v2.name) {
    return 1;
  }
  var comparison = v1.declarations.length - v2.declarations.length;
  if (comparison !== 0) {
    return comparison;
  }
  comparison = v1.references.length - v2.references.length;
  if (comparison !== 0) {
    return comparison;
  }
  for (var i = 0; i < v1.declarations.length; ++i) {
    var d1 = v1.declarations[i];
    var d2 = v2.declarations[i];
    comparison = declarationCompare(ids, d1, d2);
    if (comparison !== 0) {
      return comparison;
    }
  }
  for (var _i = 0; _i < v1.references.length; ++_i) {
    var r1 = v1.references[_i];
    var r2 = v2.references[_i];
    comparison = referenceCompare(ids, r1, r2);
    if (comparison !== 0) {
      return comparison;
    }
  }
  return 0;
}

function serialize(scope) {
  return new Serializer(scope).serialize();
}
},{"./declaration":7,"./flattener":8}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _multimap = require('multimap');

var _multimap2 = _interopRequireDefault(_multimap);

var _declaration = require('./declaration');

var _reference = require('./reference');

var _scope = require('./scope');

var _variable = require('./variable');

var _variable2 = _interopRequireDefault(_variable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function merge(multiMap, otherMultiMap) {
  otherMultiMap.forEachEntry(function (v, k) {
    multiMap.set.apply(multiMap, [k].concat(v));
  });
  return multiMap;
} /**
   * Copyright 2015 Shape Security, Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License")
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

function resolveDeclarations(freeIdentifiers, decls, variables) {
  decls.forEachEntry(function (declarations, name) {
    var references = freeIdentifiers.get(name) || [];
    variables = variables.concat(new _variable2.default(name, references, declarations));
    freeIdentifiers.delete(name);
  });
  return variables;
}

class ScopeState {
  constructor() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$freeIdentifiers = _ref.freeIdentifiers,
        freeIdentifiers = _ref$freeIdentifiers === undefined ? new _multimap2.default() : _ref$freeIdentifiers,
        _ref$functionScopedDe = _ref.functionScopedDeclarations,
        functionScopedDeclarations = _ref$functionScopedDe === undefined ? new _multimap2.default() : _ref$functionScopedDe,
        _ref$blockScopedDecla = _ref.blockScopedDeclarations,
        blockScopedDeclarations = _ref$blockScopedDecla === undefined ? new _multimap2.default() : _ref$blockScopedDecla,
        _ref$functionDeclarat = _ref.functionDeclarations,
        functionDeclarations = _ref$functionDeclarat === undefined ? new _multimap2.default() : _ref$functionDeclarat,
        _ref$children = _ref.children,
        children = _ref$children === undefined ? [] : _ref$children,
        _ref$dynamic = _ref.dynamic,
        dynamic = _ref$dynamic === undefined ? false : _ref$dynamic,
        _ref$bindingsForParen = _ref.bindingsForParent,
        bindingsForParent = _ref$bindingsForParen === undefined ? [] : _ref$bindingsForParen,
        _ref$atsForParent = _ref.atsForParent,
        atsForParent = _ref$atsForParent === undefined ? [] : _ref$atsForParent,
        _ref$potentiallyVarSc = _ref.potentiallyVarScopedFunctionDeclarations,
        potentiallyVarScopedFunctionDeclarations = _ref$potentiallyVarSc === undefined ? new _multimap2.default() : _ref$potentiallyVarSc,
        _ref$hasParameterExpr = _ref.hasParameterExpressions,
        hasParameterExpressions = _ref$hasParameterExpr === undefined ? false : _ref$hasParameterExpr;

    this.freeIdentifiers = freeIdentifiers;
    this.functionScopedDeclarations = functionScopedDeclarations;
    this.blockScopedDeclarations = blockScopedDeclarations;
    this.functionDeclarations = functionDeclarations;
    this.children = children;
    this.dynamic = dynamic;
    this.bindingsForParent = bindingsForParent;
    this.atsForParent = atsForParent;
    this.potentiallyVarScopedFunctionDeclarations = potentiallyVarScopedFunctionDeclarations;
    this.hasParameterExpressions = hasParameterExpressions;
  }

  static empty() {
    return new ScopeState({});
  }

  /*
   * Monoidal append: merges the two states together
   */
  concat(b) {
    if (this === b) {
      return this;
    }
    return new ScopeState({
      freeIdentifiers: merge(merge(new _multimap2.default(), this.freeIdentifiers), b.freeIdentifiers),
      functionScopedDeclarations: merge(merge(new _multimap2.default(), this.functionScopedDeclarations), b.functionScopedDeclarations),
      blockScopedDeclarations: merge(merge(new _multimap2.default(), this.blockScopedDeclarations), b.blockScopedDeclarations),
      functionDeclarations: merge(merge(new _multimap2.default(), this.functionDeclarations), b.functionDeclarations),
      children: this.children.concat(b.children),
      dynamic: this.dynamic || b.dynamic,
      bindingsForParent: this.bindingsForParent.concat(b.bindingsForParent),
      atsForParent: this.atsForParent.concat(b.atsForParent),
      potentiallyVarScopedFunctionDeclarations: merge(merge(new _multimap2.default(), this.potentiallyVarScopedFunctionDeclarations), b.potentiallyVarScopedFunctionDeclarations),
      hasParameterExpressions: this.hasParameterExpressions || b.hasParameterExpressions
    });
  }

  /*
   * Observe variables entering scope
   */
  addDeclarations(kind) {
    var keepBindingsForParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var declMap = new _multimap2.default();
    merge(declMap, kind.isBlockScoped ? this.blockScopedDeclarations : this.functionScopedDeclarations);
    this.bindingsForParent.forEach(function (binding) {
      return declMap.set(binding.name, new _declaration.Declaration(binding, kind));
    });
    var s = new ScopeState(this);
    if (kind.isBlockScoped) {
      s.blockScopedDeclarations = declMap;
    } else {
      s.functionScopedDeclarations = declMap;
    }
    if (!keepBindingsForParent) {
      s.bindingsForParent = [];
      s.atsForParent = [];
    }
    return s;
  }

  addFunctionDeclaration() {
    if (this.bindingsForParent.length === 0) {
      return this; // i.e., this function declaration is `export default function () {...}`
    }
    var binding = this.bindingsForParent[0];
    var s = new ScopeState(this);
    merge(s.functionDeclarations, new _multimap2.default([[binding.name, new _declaration.Declaration(binding, _declaration.DeclarationType.FUNCTION_DECLARATION)]]));
    s.bindingsForParent = [];
    return s;
  }

  /*
   * Observe a reference to a variable
   */
  addReferences(accessibility) {
    var keepBindingsForParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var freeMap = new _multimap2.default();
    merge(freeMap, this.freeIdentifiers);
    this.bindingsForParent.forEach(function (binding) {
      return freeMap.set(binding.name, new _reference.Reference(binding, accessibility));
    });
    this.atsForParent.forEach(function (binding) {
      return freeMap.set(binding.name, new _reference.Reference(binding, accessibility));
    });
    var s = new ScopeState(this);
    s.freeIdentifiers = freeMap;
    if (!keepBindingsForParent) {
      s.bindingsForParent = [];
      s.atsForParent = [];
    }
    return s;
  }

  taint() {
    var s = new ScopeState(this);
    s.dynamic = true;
    return s;
  }

  withoutBindingsForParent() {
    var s = new ScopeState(this);
    s.bindingsForParent = [];
    return s;
  }

  withParameterExpressions() {
    var s = new ScopeState(this);
    s.hasParameterExpressions = true;
    return s;
  }

  withoutParameterExpressions() {
    var s = new ScopeState(this);
    s.hasParameterExpressions = false;
    return s;
  }

  withPotentialVarFunctions(functions) {
    var pvsfd = merge(new _multimap2.default(), this.potentiallyVarScopedFunctionDeclarations);
    functions.forEach(function (f) {
      return pvsfd.set(f.name, new _declaration.Declaration(f, _declaration.DeclarationType.FUNCTION_VAR_DECLARATION));
    });
    var s = new ScopeState(this);
    s.potentiallyVarScopedFunctionDeclarations = pvsfd;
    return s;
  }

  /*
   * Used when a scope boundary is encountered. Resolves found free identifiers
   * and declarations into variable objects. Any free identifiers remaining are
   * carried forward into the new state object.
   */
  finish(astNode, scopeType) {
    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref2$shouldResolveAr = _ref2.shouldResolveArguments,
        shouldResolveArguments = _ref2$shouldResolveAr === undefined ? false : _ref2$shouldResolveAr,
        _ref2$shouldB = _ref2.shouldB33,
        shouldB33 = _ref2$shouldB === undefined ? false : _ref2$shouldB,
        _ref2$isFunctionWithP = _ref2.isFunctionWithParameterExpressions,
        isFunctionWithParameterExpressions = _ref2$isFunctionWithP === undefined ? false : _ref2$isFunctionWithP;

    var variables = [];
    var functionScoped = new _multimap2.default();
    var freeIdentifiers = merge(new _multimap2.default(), this.freeIdentifiers);
    var pvsfd = merge(new _multimap2.default(), this.potentiallyVarScopedFunctionDeclarations);
    var children = this.children;

    var hasSimpleCatchBinding = scopeType.name === 'Catch' && astNode.binding.type === 'BindingIdentifier';
    this.blockScopedDeclarations.forEachEntry(function (v, k) {
      if (hasSimpleCatchBinding && v.length === 1 && v[0].node === astNode.binding) {
        // A simple catch binding is the only type of lexical binding which does *not* block B.3.3 hoisting.
        // See B.3.5: https://tc39.github.io/ecma262/#sec-variablestatements-in-catch-blocks
        return;
      }
      pvsfd.delete(k);
    });
    this.functionDeclarations.forEachEntry(function (v, k) {
      var existing = pvsfd.get(k);
      if (existing && (v.length > 1 || v[0].node !== existing[0].node)) {
        // Note that this is *currently* the spec'd behavior, but is regarded as a bug; see https://github.com/tc39/ecma262/issues/913
        pvsfd.delete(k);
      }
    });
    this.functionScopedDeclarations.forEachEntry(function (v, k) {
      var existing = pvsfd.get(k);
      if (existing && v.some(function (d) {
        return d.type === _declaration.DeclarationType.PARAMETER;
      })) {
        // Despite being function scoped, parameters *do* block B.3.3 hoisting.
        // See B.3.3.1.a.ii: https://tc39.github.io/ecma262/#sec-web-compat-functiondeclarationinstantiation
        // "If replacing the FunctionDeclaration f with a VariableStatement that has F as a BindingIdentifier would not produce any Early Errors for func and F is not an element of parameterNames, then"
        pvsfd.delete(k);
      }
    });

    var declarations = new _multimap2.default();

    switch (scopeType) {
      case _scope.ScopeType.BLOCK:
      case _scope.ScopeType.CATCH:
      case _scope.ScopeType.WITH:
      case _scope.ScopeType.FUNCTION_NAME:
      case _scope.ScopeType.CLASS_NAME:
      case _scope.ScopeType.PARAMETER_EXPRESSION:
        // resolve references to only block-scoped free declarations
        merge(declarations, this.blockScopedDeclarations);
        merge(declarations, this.functionDeclarations);
        variables = resolveDeclarations(freeIdentifiers, declarations, variables);
        merge(functionScoped, this.functionScopedDeclarations);
        break;
      case _scope.ScopeType.PARAMETERS:
      case _scope.ScopeType.ARROW_FUNCTION:
      case _scope.ScopeType.FUNCTION:
      case _scope.ScopeType.MODULE:
      case _scope.ScopeType.SCRIPT:
        // resolve references to both block-scoped and function-scoped free declarations

        // top-level lexical declarations in scripts are not globals, so create a separate scope for them
        // otherwise lexical and variable declarations go in the same scope.
        if (scopeType === _scope.ScopeType.SCRIPT) {
          children = [new _scope.Scope({
            children,
            variables: resolveDeclarations(freeIdentifiers, this.blockScopedDeclarations, []),
            through: merge(new _multimap2.default(), freeIdentifiers),
            type: _scope.ScopeType.SCRIPT,
            isDynamic: this.dynamic,
            astNode
          })];
        } else {
          merge(declarations, this.blockScopedDeclarations);
        }

        if (shouldResolveArguments) {
          declarations.set('arguments');
        }
        merge(declarations, this.functionScopedDeclarations);
        merge(declarations, this.functionDeclarations);

        if (shouldB33) {
          merge(declarations, pvsfd);
        }
        if (!isFunctionWithParameterExpressions) {
          pvsfd = new _multimap2.default();
        }

        variables = resolveDeclarations(freeIdentifiers, declarations, variables);

        // no declarations in a module are global
        if (scopeType === _scope.ScopeType.MODULE) {
          children = [new _scope.Scope({
            children,
            variables,
            through: freeIdentifiers,
            type: _scope.ScopeType.MODULE,
            isDynamic: this.dynamic,
            astNode
          })];
          variables = [];
        }
        break;
      default:
        throw new Error('not reached');
    }

    var scope = scopeType === _scope.ScopeType.SCRIPT || scopeType === _scope.ScopeType.MODULE ? new _scope.GlobalScope({ children, variables, through: freeIdentifiers, astNode }) : new _scope.Scope({
      children,
      variables,
      through: freeIdentifiers,
      type: scopeType,
      isDynamic: this.dynamic,
      astNode
    });

    return new ScopeState({
      freeIdentifiers,
      functionScopedDeclarations: functionScoped,
      children: [scope],
      bindingsForParent: this.bindingsForParent,
      potentiallyVarScopedFunctionDeclarations: pvsfd,
      hasParameterExpressions: this.hasParameterExpressions
    });
  }
}
exports.default = ScopeState;
},{"./declaration":7,"./reference":10,"./scope":15,"./variable":17,"multimap":18}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GlobalScope = exports.Scope = exports.ScopeType = undefined;

var _variable = require('./variable');

var _variable2 = _interopRequireDefault(_variable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ScopeType {
  constructor(name) {
    this.name = name;
  }
}

exports.ScopeType = ScopeType; /**
                                * Copyright 2015 Shape Security, Inc.
                                *
                                * Licensed under the Apache License, Version 2.0 (the "License")
                                * you may not use this file except in compliance with the License.
                                * You may obtain a copy of the License at
                                *
                                *     http://www.apache.org/licenses/LICENSE-2.0
                                *
                                * Unless required by applicable law or agreed to in writing, software
                                * distributed under the License is distributed on an "AS IS" BASIS,
                                * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                * See the License for the specific language governing permissions and
                                * limitations under the License.
                                */

ScopeType.GLOBAL = new ScopeType('Global');
ScopeType.MODULE = new ScopeType('Module');
ScopeType.SCRIPT = new ScopeType('Script');
ScopeType.ARROW_FUNCTION = new ScopeType('ArrowFunction');
ScopeType.FUNCTION = new ScopeType('Function');
ScopeType.FUNCTION_NAME = new ScopeType('FunctionName'); // named function expressions
ScopeType.CLASS_NAME = new ScopeType('ClassName'); // named class expressions
ScopeType.PARAMETERS = new ScopeType('Parameters');
ScopeType.PARAMETER_EXPRESSION = new ScopeType('ParameterExpression');
ScopeType.WITH = new ScopeType('With');
ScopeType.CATCH = new ScopeType('Catch');
ScopeType.BLOCK = new ScopeType('Block');

class Scope {
  constructor(_ref) {
    var _this = this;

    var children = _ref.children,
        variables = _ref.variables,
        through = _ref.through,
        type = _ref.type,
        isDynamic = _ref.isDynamic,
        astNode = _ref.astNode;

    this.children = children;
    this.through = through;
    this.type = type;
    this.astNode = astNode;

    this.variables = new Map();
    variables.forEach(function (v) {
      return _this.variables.set(v.name, v);
    });

    this.variableList = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = this.variables.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var x = _step.value;

        this.variableList.push(x);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    this.dynamic = isDynamic || type === ScopeType.WITH || type === ScopeType.GLOBAL;
  }

  isGlobal() {
    return this.type === ScopeType.GLOBAL;
  }

  lookupVariable(name) {
    return this.variables.get(name);
  }
}

exports.Scope = Scope;
class GlobalScope extends Scope {
  constructor(_ref2) {
    var _this2;

    var children = _ref2.children,
        variables = _ref2.variables,
        through = _ref2.through,
        astNode = _ref2.astNode;

    _this2 = super({ children, variables, through, type: ScopeType.GLOBAL, isDynamic: true, astNode });
    through.forEachEntry(function (v, k) {
      _this2.variables.set(k, new _variable2.default(k, v, []));
    });
    this.variableList = [];
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = this.variables.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var x = _step2.value;

        this.variableList.push(x);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }
}
exports.GlobalScope = GlobalScope;
},{"./variable":17}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _shiftReducer = require('shift-reducer');

var _shiftReducer2 = _interopRequireDefault(_shiftReducer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO this file should live elsewhere

class SetMonoid {
  // nb not immutable
  constructor(set) {
    this.set = set;
  }

  static empty() {
    return new SetMonoid(new Set());
  }

  concat(b) {
    return new SetMonoid(merge(this.set, b.set));
  }

  extract() {
    return this.set;
  }

  add(e) {
    // this happens to work, since, as used in StrictnessReducer, .add is never called until after something has been merged, so the identity element is never mutated.
    // to do this in an immutable fashion, uncomment the line below. 
    // this.set = merge(new Set, this.set);
    this.set.add(e);
    return this;
  }
}

function hasStrict(directives) {
  return directives.some(function (d) {
    return d.rawValue === 'use strict';
  });
}

function merge(s1, s2) {
  var out = new Set();
  s1.forEach(function (v) {
    return out.add(v);
  });
  s2.forEach(function (v) {
    return out.add(v);
  });
  return out;
}

// Given a Script, the analyze method returns a set containing all ArrowExpression, FunctionDeclaration, FunctionExpression, and Script nodes which are sloppy mode. All other ArrowExpression, FunctionDeclaration, FunctionExpression, and Script nodes are strict.
class StrictnessReducer extends _shiftReducer.MonoidalReducer {
  constructor() {
    super(SetMonoid);
  }

  static analyze(script) {
    return (0, _shiftReducer2.default)(new this(), script).extract();
  }

  reduceArrowExpression(node, _ref) {
    var params = _ref.params,
        body = _ref.body;

    if (node.body.type === 'FunctionBody' && hasStrict(node.body.directives)) {
      return SetMonoid.empty();
    }
    return super.reduceArrowExpression(node, { params, body }).add(node);
  }

  reduceClassDeclaration() {
    return SetMonoid.empty();
  }

  reduceClassExpression() {
    return SetMonoid.empty();
  }

  reduceFunctionDeclaration(node, _ref2) {
    var name = _ref2.name,
        params = _ref2.params,
        body = _ref2.body;

    if (hasStrict(node.body.directives)) {
      return SetMonoid.empty();
    }
    return super.reduceFunctionDeclaration(node, { name, params, body }).add(node);
  }

  reduceFunctionExpression(node, _ref3) {
    var name = _ref3.name,
        params = _ref3.params,
        body = _ref3.body;

    if (hasStrict(node.body.directives)) {
      return SetMonoid.empty();
    }
    return super.reduceFunctionExpression(node, { name, params, body }).add(node);
  }

  reduceGetter(node, _ref4) {
    var name = _ref4.name,
        body = _ref4.body;

    if (hasStrict(node.body.directives)) {
      return SetMonoid.empty();
    }
    return super.reduceGetter(node, { name, body }).add(node);
  }

  reduceMethod(node, _ref5) {
    var name = _ref5.name,
        params = _ref5.params,
        body = _ref5.body;

    if (hasStrict(node.body.directives)) {
      return SetMonoid.empty();
    }
    return super.reduceMethod(node, { name, params, body }).add(node);
  }

  reduceScript(node, _ref6) {
    var directives = _ref6.directives,
        statements = _ref6.statements;

    if (hasStrict(node.directives)) {
      return SetMonoid.empty();
    }
    return super.reduceScript(node, { directives, statements }).add(node);
  }

  reduceSetter(node, _ref7) {
    var name = _ref7.name,
        param = _ref7.param,
        body = _ref7.body;

    if (hasStrict(node.body.directives)) {
      return SetMonoid.empty();
    }
    return super.reduceSetter(node, { name, param, body }).add(node);
  }
}
exports.default = StrictnessReducer;
},{"shift-reducer":4}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Copyright 2014 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class Variable {
  constructor(name, references, declarations) {
    this.name = name;
    this.references = references;
    this.declarations = declarations;
  }
}
exports.default = Variable;
},{}],18:[function(require,module,exports){
"use strict";

/* global module, define */

function mapEach(map, operation){
  var keys = map.keys();
  var next;
  while(!(next = keys.next()).done) {
    operation(map.get(next.value), next.value, map);
  }
}

var Multimap = (function() {
  var mapCtor;
  if (typeof Map !== 'undefined') {
    mapCtor = Map;

    if (!Map.prototype.keys) {
      Map.prototype.keys = function() {
        var keys = [];
        this.forEach(function(item, key) {
          keys.push(key);
        });
        return keys;
      };
    }
  }

  function Multimap(iterable) {
    var self = this;

    self._map = mapCtor;

    if (Multimap.Map) {
      self._map = Multimap.Map;
    }

    self._ = self._map ? new self._map() : {};

    if (iterable) {
      iterable.forEach(function(i) {
        self.set(i[0], i[1]);
      });
    }
  }

  /**
   * @param {Object} key
   * @return {Array} An array of values, undefined if no such a key;
   */
  Multimap.prototype.get = function(key) {
    return this._map ? this._.get(key) : this._[key];
  };

  /**
   * @param {Object} key
   * @param {Object} val...
   */
  Multimap.prototype.set = function(key, val) {
    var args = Array.prototype.slice.call(arguments);

    key = args.shift();

    var entry = this.get(key);
    if (!entry) {
      entry = [];
      if (this._map)
        this._.set(key, entry);
      else
        this._[key] = entry;
    }

    Array.prototype.push.apply(entry, args);
    return this;
  };

  /**
   * @param {Object} key
   * @param {Object=} val
   * @return {boolean} true if any thing changed
   */
  Multimap.prototype.delete = function(key, val) {
    if (!this.has(key))
      return false;

    if (arguments.length == 1) {
      this._map ? (this._.delete(key)) : (delete this._[key]);
      return true;
    } else {
      var entry = this.get(key);
      var idx = entry.indexOf(val);
      if (idx != -1) {
        entry.splice(idx, 1);
        return true;
      }
    }

    return false;
  };

  /**
   * @param {Object} key
   * @param {Object=} val
   * @return {boolean} whether the map contains 'key' or 'key=>val' pair
   */
  Multimap.prototype.has = function(key, val) {
    var hasKey = this._map ? this._.has(key) : this._.hasOwnProperty(key);

    if (arguments.length == 1 || !hasKey)
      return hasKey;

    var entry = this.get(key) || [];
    return entry.indexOf(val) != -1;
  };


  /**
   * @return {Array} all the keys in the map
   */
  Multimap.prototype.keys = function() {
    if (this._map)
      return makeIterator(this._.keys());

    return makeIterator(Object.keys(this._));
  };

  /**
   * @return {Array} all the values in the map
   */
  Multimap.prototype.values = function() {
    var vals = [];
    this.forEachEntry(function(entry) {
      Array.prototype.push.apply(vals, entry);
    });

    return makeIterator(vals);
  };

  /**
   *
   */
  Multimap.prototype.forEachEntry = function(iter) {
    mapEach(this, iter);
  };

  Multimap.prototype.forEach = function(iter) {
    var self = this;
    self.forEachEntry(function(entry, key) {
      entry.forEach(function(item) {
        iter(item, key, self);
      });
    });
  };


  Multimap.prototype.clear = function() {
    if (this._map) {
      this._.clear();
    } else {
      this._ = {};
    }
  };

  Object.defineProperty(
    Multimap.prototype,
    "size", {
      configurable: false,
      enumerable: true,
      get: function() {
        var total = 0;

        mapEach(this, function(value){
          total += value.length;
        });

        return total;
      }
    });

  var safariNext;

  try{
    safariNext = new Function('iterator', 'makeIterator', 'var keysArray = []; for(var key of iterator){keysArray.push(key);} return makeIterator(keysArray).next;');
  }catch(error){
    // for of not implemented;
  }

  function makeIterator(iterator){
    if(Array.isArray(iterator)){
      var nextIndex = 0;

      return {
        next: function(){
          return nextIndex < iterator.length ?
            {value: iterator[nextIndex++], done: false} :
          {done: true};
        }
      };
    }

    // Only an issue in safari
    if(!iterator.next && safariNext){
      iterator.next = safariNext(iterator, makeIterator);
    }

    return iterator;
  }

  return Multimap;
})();


if(typeof exports === 'object' && module && module.exports)
  module.exports = Multimap;
else if(typeof define === 'function' && define.amd)
  define(function() { return Multimap; });

},{}],19:[function(require,module,exports){
// Generated by src/generate-spec.js. 

/**
 * Copyright 2016 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Hack to make Babel6 import this as a module.
Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = (function() {
  var SPEC = {};

  var BOOLEAN = { typeName: "Boolean" };
  var DOUBLE = { typeName: "Number" };
  var STRING = { typeName: "String" };
  function Maybe(arg) { return { typeName: "Maybe", argument: arg }; }
  function List(arg) { return { typeName: "List", argument: arg }; }
  function Const(arg) { return { typeName: "Const", argument: arg }; }
  function Union() { return { typeName: "Union", arguments: [].slice.call(arguments, 0) }; }


  var TYPE_INDICATOR = {
    typeName: "Enum",
    values: ["ArrayAssignmentTarget", "ArrayBinding", "ArrayExpression", "ArrowExpression", "AssignmentExpression", "AssignmentTargetIdentifier", "AssignmentTargetPropertyIdentifier", "AssignmentTargetPropertyProperty", "AssignmentTargetWithDefault", "BinaryExpression", "BindingIdentifier", "BindingPropertyIdentifier", "BindingPropertyProperty", "BindingWithDefault", "Block", "BlockStatement", "BreakStatement", "CallExpression", "CatchClause", "ClassDeclaration", "ClassElement", "ClassExpression", "CompoundAssignmentExpression", "ComputedMemberAssignmentTarget", "ComputedMemberExpression", "ComputedPropertyName", "ConditionalExpression", "ContinueStatement", "DataProperty", "DebuggerStatement", "Directive", "DoWhileStatement", "EmptyStatement", "Export", "ExportAllFrom", "ExportDefault", "ExportFrom", "ExportFromSpecifier", "ExportLocalSpecifier", "ExportLocals", "ExpressionStatement", "ForInStatement", "ForOfStatement", "ForStatement", "FormalParameters", "FunctionBody", "FunctionDeclaration", "FunctionExpression", "Getter", "IdentifierExpression", "IfStatement", "Import", "ImportNamespace", "ImportSpecifier", "LabeledStatement", "LiteralBooleanExpression", "LiteralInfinityExpression", "LiteralNullExpression", "LiteralNumericExpression", "LiteralRegExpExpression", "LiteralStringExpression", "Method", "Module", "NewExpression", "NewTargetExpression", "ObjectAssignmentTarget", "ObjectBinding", "ObjectExpression", "ReturnStatement", "Script", "Setter", "ShorthandProperty", "SpreadElement", "StaticMemberAssignmentTarget", "StaticMemberExpression", "StaticPropertyName", "Super", "SwitchCase", "SwitchDefault", "SwitchStatement", "SwitchStatementWithDefault", "TemplateElement", "TemplateExpression", "ThisExpression", "ThrowStatement", "TryCatchStatement", "TryFinallyStatement", "UnaryExpression", "UpdateExpression", "VariableDeclaration", "VariableDeclarationStatement", "VariableDeclarator", "WhileStatement", "WithStatement", "YieldExpression", "YieldGeneratorExpression"]
  };

  var BinaryOperator = {
    typeName: "Enum",
    values: ["==", "!=", "===", "!==", "<", "<=", ">", ">=", "in", "instanceof", "<<", ">>", ">>>", "+", "-", "*", "/", "%", "**", ",", "||", "&&", "|", "^", "&"]
  }
  
  var CompoundAssignmentOperator = {
    typeName: "Enum",
    values: ["+=", "-=", "*=", "/=", "%=", "**=", "<<=", ">>=", ">>>=", "|=", "^=", "&="]
  }
  
  var UnaryOperator = {
    typeName: "Enum",
    values: ["+", "-", "!", "~", "typeof", "void", "delete"]
  }
  
  var UpdateOperator = {
    typeName: "Enum",
    values: ["++", "--"]
  }
  
  var VariableDeclarationKind = {
    typeName: "Enum",
    values: ["var", "let", "const"]
  }
  

  var ArrayAssignmentTarget = SPEC.ArrayAssignmentTarget = {};
  var ArrayBinding = SPEC.ArrayBinding = {};
  var ArrayExpression = SPEC.ArrayExpression = {};
  var ArrowExpression = SPEC.ArrowExpression = {};
  var AssignmentExpression = SPEC.AssignmentExpression = {};
  var AssignmentTargetIdentifier = SPEC.AssignmentTargetIdentifier = {};
  var AssignmentTargetPropertyIdentifier = SPEC.AssignmentTargetPropertyIdentifier = {};
  var AssignmentTargetPropertyProperty = SPEC.AssignmentTargetPropertyProperty = {};
  var AssignmentTargetWithDefault = SPEC.AssignmentTargetWithDefault = {};
  var BinaryExpression = SPEC.BinaryExpression = {};
  var BindingIdentifier = SPEC.BindingIdentifier = {};
  var BindingPropertyIdentifier = SPEC.BindingPropertyIdentifier = {};
  var BindingPropertyProperty = SPEC.BindingPropertyProperty = {};
  var BindingWithDefault = SPEC.BindingWithDefault = {};
  var Block = SPEC.Block = {};
  var BlockStatement = SPEC.BlockStatement = {};
  var BreakStatement = SPEC.BreakStatement = {};
  var CallExpression = SPEC.CallExpression = {};
  var CatchClause = SPEC.CatchClause = {};
  var ClassDeclaration = SPEC.ClassDeclaration = {};
  var ClassElement = SPEC.ClassElement = {};
  var ClassExpression = SPEC.ClassExpression = {};
  var CompoundAssignmentExpression = SPEC.CompoundAssignmentExpression = {};
  var ComputedMemberAssignmentTarget = SPEC.ComputedMemberAssignmentTarget = {};
  var ComputedMemberExpression = SPEC.ComputedMemberExpression = {};
  var ComputedPropertyName = SPEC.ComputedPropertyName = {};
  var ConditionalExpression = SPEC.ConditionalExpression = {};
  var ContinueStatement = SPEC.ContinueStatement = {};
  var DataProperty = SPEC.DataProperty = {};
  var DebuggerStatement = SPEC.DebuggerStatement = {};
  var Directive = SPEC.Directive = {};
  var DoWhileStatement = SPEC.DoWhileStatement = {};
  var EmptyStatement = SPEC.EmptyStatement = {};
  var Export = SPEC.Export = {};
  var ExportAllFrom = SPEC.ExportAllFrom = {};
  var ExportDefault = SPEC.ExportDefault = {};
  var ExportFrom = SPEC.ExportFrom = {};
  var ExportFromSpecifier = SPEC.ExportFromSpecifier = {};
  var ExportLocalSpecifier = SPEC.ExportLocalSpecifier = {};
  var ExportLocals = SPEC.ExportLocals = {};
  var ExpressionStatement = SPEC.ExpressionStatement = {};
  var ForInStatement = SPEC.ForInStatement = {};
  var ForOfStatement = SPEC.ForOfStatement = {};
  var ForStatement = SPEC.ForStatement = {};
  var FormalParameters = SPEC.FormalParameters = {};
  var FunctionBody = SPEC.FunctionBody = {};
  var FunctionDeclaration = SPEC.FunctionDeclaration = {};
  var FunctionExpression = SPEC.FunctionExpression = {};
  var Getter = SPEC.Getter = {};
  var IdentifierExpression = SPEC.IdentifierExpression = {};
  var IfStatement = SPEC.IfStatement = {};
  var Import = SPEC.Import = {};
  var ImportNamespace = SPEC.ImportNamespace = {};
  var ImportSpecifier = SPEC.ImportSpecifier = {};
  var LabeledStatement = SPEC.LabeledStatement = {};
  var LiteralBooleanExpression = SPEC.LiteralBooleanExpression = {};
  var LiteralInfinityExpression = SPEC.LiteralInfinityExpression = {};
  var LiteralNullExpression = SPEC.LiteralNullExpression = {};
  var LiteralNumericExpression = SPEC.LiteralNumericExpression = {};
  var LiteralRegExpExpression = SPEC.LiteralRegExpExpression = {};
  var LiteralStringExpression = SPEC.LiteralStringExpression = {};
  var Method = SPEC.Method = {};
  var Module = SPEC.Module = {};
  var NewExpression = SPEC.NewExpression = {};
  var NewTargetExpression = SPEC.NewTargetExpression = {};
  var ObjectAssignmentTarget = SPEC.ObjectAssignmentTarget = {};
  var ObjectBinding = SPEC.ObjectBinding = {};
  var ObjectExpression = SPEC.ObjectExpression = {};
  var ReturnStatement = SPEC.ReturnStatement = {};
  var Script = SPEC.Script = {};
  var Setter = SPEC.Setter = {};
  var ShorthandProperty = SPEC.ShorthandProperty = {};
  var SpreadElement = SPEC.SpreadElement = {};
  var StaticMemberAssignmentTarget = SPEC.StaticMemberAssignmentTarget = {};
  var StaticMemberExpression = SPEC.StaticMemberExpression = {};
  var StaticPropertyName = SPEC.StaticPropertyName = {};
  var Super = SPEC.Super = {};
  var SwitchCase = SPEC.SwitchCase = {};
  var SwitchDefault = SPEC.SwitchDefault = {};
  var SwitchStatement = SPEC.SwitchStatement = {};
  var SwitchStatementWithDefault = SPEC.SwitchStatementWithDefault = {};
  var TemplateElement = SPEC.TemplateElement = {};
  var TemplateExpression = SPEC.TemplateExpression = {};
  var ThisExpression = SPEC.ThisExpression = {};
  var ThrowStatement = SPEC.ThrowStatement = {};
  var TryCatchStatement = SPEC.TryCatchStatement = {};
  var TryFinallyStatement = SPEC.TryFinallyStatement = {};
  var UnaryExpression = SPEC.UnaryExpression = {};
  var UpdateExpression = SPEC.UpdateExpression = {};
  var VariableDeclaration = SPEC.VariableDeclaration = {};
  var VariableDeclarationStatement = SPEC.VariableDeclarationStatement = {};
  var VariableDeclarator = SPEC.VariableDeclarator = {};
  var WhileStatement = SPEC.WhileStatement = {};
  var WithStatement = SPEC.WithStatement = {};
  var YieldExpression = SPEC.YieldExpression = {};
  var YieldGeneratorExpression = SPEC.YieldGeneratorExpression = {};

  var MemberExpression = Union(ComputedMemberExpression, StaticMemberExpression);
  var AssignmentTargetProperty = Union(AssignmentTargetPropertyIdentifier, AssignmentTargetPropertyProperty);
  var Class = Union(ClassDeclaration, ClassExpression);
  var ExportDeclaration = Union(Export, ExportAllFrom, ExportDefault, ExportFrom, ExportLocals);
  var PropertyName = Union(ComputedPropertyName, StaticPropertyName);
  var Function = Union(FunctionDeclaration, FunctionExpression);
  var ImportDeclaration = Union(Import, ImportNamespace);
  var IterationStatement = Union(DoWhileStatement, ForInStatement, ForOfStatement, ForStatement, WhileStatement);
  var MemberAssignmentTarget = Union(ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget);
  var BindingProperty = Union(BindingPropertyIdentifier, BindingPropertyProperty);
  var MethodDefinition = Union(Getter, Method, Setter);
  var Program = Union(Module, Script);
  var VariableReference = Union(AssignmentTargetIdentifier, BindingIdentifier, IdentifierExpression);
  var NamedObjectProperty = Union(DataProperty, MethodDefinition);
  var Expression = Union(ArrayExpression, ArrowExpression, AssignmentExpression, BinaryExpression, CallExpression, ClassExpression, CompoundAssignmentExpression, ConditionalExpression, FunctionExpression, IdentifierExpression, LiteralBooleanExpression, LiteralInfinityExpression, LiteralNullExpression, LiteralNumericExpression, LiteralRegExpExpression, LiteralStringExpression, MemberExpression, NewExpression, NewTargetExpression, ObjectExpression, TemplateExpression, ThisExpression, UnaryExpression, UpdateExpression, YieldExpression, YieldGeneratorExpression);
  var Statement = Union(BlockStatement, BreakStatement, ClassDeclaration, ContinueStatement, DebuggerStatement, EmptyStatement, ExpressionStatement, FunctionDeclaration, IfStatement, IterationStatement, LabeledStatement, ReturnStatement, SwitchStatement, SwitchStatementWithDefault, ThrowStatement, TryCatchStatement, TryFinallyStatement, VariableDeclarationStatement, WithStatement);
  var ObjectProperty = Union(NamedObjectProperty, ShorthandProperty);
  var Node = Union(ArrayAssignmentTarget, ArrayBinding, AssignmentTargetProperty, AssignmentTargetWithDefault, BindingProperty, BindingWithDefault, Block, CatchClause, ClassElement, Directive, ExportDeclaration, ExportFromSpecifier, ExportLocalSpecifier, Expression, FormalParameters, FunctionBody, ImportDeclaration, ImportSpecifier, MemberAssignmentTarget, ObjectAssignmentTarget, ObjectBinding, ObjectProperty, Program, PropertyName, SpreadElement, Statement, Super, SwitchCase, SwitchDefault, TemplateElement, VariableDeclaration, VariableDeclarator, VariableReference);

  ArrayAssignmentTarget.typeName = "ArrayAssignmentTarget";
  ArrayAssignmentTarget.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ArrayAssignmentTarget" },
    { name: "elements", type: List(Maybe(Union(AssignmentTargetWithDefault, Union(Union(ArrayAssignmentTarget, ObjectAssignmentTarget), Union(AssignmentTargetIdentifier, MemberAssignmentTarget))))) },
    { name: "rest", type: Maybe(Union(Union(ArrayAssignmentTarget, ObjectAssignmentTarget), Union(AssignmentTargetIdentifier, MemberAssignmentTarget))) }
  ];

  ArrayBinding.typeName = "ArrayBinding";
  ArrayBinding.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ArrayBinding" },
    { name: "elements", type: List(Maybe(Union(BindingWithDefault, Union(BindingIdentifier, Union(ArrayBinding, ObjectBinding))))) },
    { name: "rest", type: Maybe(Union(BindingIdentifier, Union(ArrayBinding, ObjectBinding))) }
  ];

  ArrayExpression.typeName = "ArrayExpression";
  ArrayExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ArrayExpression" },
    { name: "elements", type: List(Maybe(Union(Expression, SpreadElement))) }
  ];

  ArrowExpression.typeName = "ArrowExpression";
  ArrowExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ArrowExpression" },
    { name: "params", type: FormalParameters },
    { name: "body", type: Union(Expression, FunctionBody) }
  ];

  AssignmentExpression.typeName = "AssignmentExpression";
  AssignmentExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "AssignmentExpression" },
    { name: "binding", type: Union(Union(ArrayAssignmentTarget, ObjectAssignmentTarget), Union(AssignmentTargetIdentifier, MemberAssignmentTarget)) },
    { name: "expression", type: Expression }
  ];

  AssignmentTargetIdentifier.typeName = "AssignmentTargetIdentifier";
  AssignmentTargetIdentifier.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "AssignmentTargetIdentifier" },
    { name: "name", type: STRING }
  ];

  AssignmentTargetPropertyIdentifier.typeName = "AssignmentTargetPropertyIdentifier";
  AssignmentTargetPropertyIdentifier.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "AssignmentTargetPropertyIdentifier" },
    { name: "binding", type: AssignmentTargetIdentifier },
    { name: "init", type: Maybe(Expression) }
  ];

  AssignmentTargetPropertyProperty.typeName = "AssignmentTargetPropertyProperty";
  AssignmentTargetPropertyProperty.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "AssignmentTargetPropertyProperty" },
    { name: "name", type: PropertyName },
    { name: "binding", type: Union(AssignmentTargetWithDefault, Union(Union(ArrayAssignmentTarget, ObjectAssignmentTarget), Union(AssignmentTargetIdentifier, MemberAssignmentTarget))) }
  ];

  AssignmentTargetWithDefault.typeName = "AssignmentTargetWithDefault";
  AssignmentTargetWithDefault.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "AssignmentTargetWithDefault" },
    { name: "binding", type: Union(Union(ArrayAssignmentTarget, ObjectAssignmentTarget), Union(AssignmentTargetIdentifier, MemberAssignmentTarget)) },
    { name: "init", type: Expression }
  ];

  BinaryExpression.typeName = "BinaryExpression";
  BinaryExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "BinaryExpression" },
    { name: "left", type: Expression },
    { name: "operator", type: BinaryOperator },
    { name: "right", type: Expression }
  ];

  BindingIdentifier.typeName = "BindingIdentifier";
  BindingIdentifier.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingIdentifier" },
    { name: "name", type: STRING }
  ];

  BindingPropertyIdentifier.typeName = "BindingPropertyIdentifier";
  BindingPropertyIdentifier.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingPropertyIdentifier" },
    { name: "binding", type: BindingIdentifier },
    { name: "init", type: Maybe(Expression) }
  ];

  BindingPropertyProperty.typeName = "BindingPropertyProperty";
  BindingPropertyProperty.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingPropertyProperty" },
    { name: "name", type: PropertyName },
    { name: "binding", type: Union(BindingWithDefault, Union(BindingIdentifier, Union(ArrayBinding, ObjectBinding))) }
  ];

  BindingWithDefault.typeName = "BindingWithDefault";
  BindingWithDefault.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "BindingWithDefault" },
    { name: "binding", type: Union(BindingIdentifier, Union(ArrayBinding, ObjectBinding)) },
    { name: "init", type: Expression }
  ];

  Block.typeName = "Block";
  Block.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "Block" },
    { name: "statements", type: List(Statement) }
  ];

  BlockStatement.typeName = "BlockStatement";
  BlockStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "BlockStatement" },
    { name: "block", type: Block }
  ];

  BreakStatement.typeName = "BreakStatement";
  BreakStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "BreakStatement" },
    { name: "label", type: Maybe(STRING) }
  ];

  CallExpression.typeName = "CallExpression";
  CallExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "CallExpression" },
    { name: "callee", type: Union(Expression, Super) },
    { name: "arguments", type: List(Union(Expression, SpreadElement)) }
  ];

  CatchClause.typeName = "CatchClause";
  CatchClause.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "CatchClause" },
    { name: "binding", type: Union(BindingIdentifier, Union(ArrayBinding, ObjectBinding)) },
    { name: "body", type: Block }
  ];

  ClassDeclaration.typeName = "ClassDeclaration";
  ClassDeclaration.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ClassDeclaration" },
    { name: "name", type: BindingIdentifier },
    { name: "super", type: Maybe(Expression) },
    { name: "elements", type: List(ClassElement) }
  ];

  ClassElement.typeName = "ClassElement";
  ClassElement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ClassElement" },
    { name: "isStatic", type: BOOLEAN },
    { name: "method", type: MethodDefinition }
  ];

  ClassExpression.typeName = "ClassExpression";
  ClassExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ClassExpression" },
    { name: "name", type: Maybe(BindingIdentifier) },
    { name: "super", type: Maybe(Expression) },
    { name: "elements", type: List(ClassElement) }
  ];

  CompoundAssignmentExpression.typeName = "CompoundAssignmentExpression";
  CompoundAssignmentExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "CompoundAssignmentExpression" },
    { name: "binding", type: Union(AssignmentTargetIdentifier, MemberAssignmentTarget) },
    { name: "operator", type: CompoundAssignmentOperator },
    { name: "expression", type: Expression }
  ];

  ComputedMemberAssignmentTarget.typeName = "ComputedMemberAssignmentTarget";
  ComputedMemberAssignmentTarget.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ComputedMemberAssignmentTarget" },
    { name: "object", type: Union(Expression, Super) },
    { name: "expression", type: Expression }
  ];

  ComputedMemberExpression.typeName = "ComputedMemberExpression";
  ComputedMemberExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ComputedMemberExpression" },
    { name: "object", type: Union(Expression, Super) },
    { name: "expression", type: Expression }
  ];

  ComputedPropertyName.typeName = "ComputedPropertyName";
  ComputedPropertyName.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ComputedPropertyName" },
    { name: "expression", type: Expression }
  ];

  ConditionalExpression.typeName = "ConditionalExpression";
  ConditionalExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ConditionalExpression" },
    { name: "test", type: Expression },
    { name: "consequent", type: Expression },
    { name: "alternate", type: Expression }
  ];

  ContinueStatement.typeName = "ContinueStatement";
  ContinueStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ContinueStatement" },
    { name: "label", type: Maybe(STRING) }
  ];

  DataProperty.typeName = "DataProperty";
  DataProperty.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "DataProperty" },
    { name: "name", type: PropertyName },
    { name: "expression", type: Expression }
  ];

  DebuggerStatement.typeName = "DebuggerStatement";
  DebuggerStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "DebuggerStatement" }
  ];

  Directive.typeName = "Directive";
  Directive.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "Directive" },
    { name: "rawValue", type: STRING }
  ];

  DoWhileStatement.typeName = "DoWhileStatement";
  DoWhileStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "DoWhileStatement" },
    { name: "body", type: Statement },
    { name: "test", type: Expression }
  ];

  EmptyStatement.typeName = "EmptyStatement";
  EmptyStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "EmptyStatement" }
  ];

  Export.typeName = "Export";
  Export.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "Export" },
    { name: "declaration", type: Union(ClassDeclaration, FunctionDeclaration, VariableDeclaration) }
  ];

  ExportAllFrom.typeName = "ExportAllFrom";
  ExportAllFrom.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportAllFrom" },
    { name: "moduleSpecifier", type: STRING }
  ];

  ExportDefault.typeName = "ExportDefault";
  ExportDefault.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportDefault" },
    { name: "body", type: Union(ClassDeclaration, Expression, FunctionDeclaration) }
  ];

  ExportFrom.typeName = "ExportFrom";
  ExportFrom.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportFrom" },
    { name: "namedExports", type: List(ExportFromSpecifier) },
    { name: "moduleSpecifier", type: STRING }
  ];

  ExportFromSpecifier.typeName = "ExportFromSpecifier";
  ExportFromSpecifier.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportFromSpecifier" },
    { name: "name", type: STRING },
    { name: "exportedName", type: Maybe(STRING) }
  ];

  ExportLocalSpecifier.typeName = "ExportLocalSpecifier";
  ExportLocalSpecifier.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportLocalSpecifier" },
    { name: "name", type: IdentifierExpression },
    { name: "exportedName", type: Maybe(STRING) }
  ];

  ExportLocals.typeName = "ExportLocals";
  ExportLocals.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ExportLocals" },
    { name: "namedExports", type: List(ExportLocalSpecifier) }
  ];

  ExpressionStatement.typeName = "ExpressionStatement";
  ExpressionStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ExpressionStatement" },
    { name: "expression", type: Expression }
  ];

  ForInStatement.typeName = "ForInStatement";
  ForInStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ForInStatement" },
    { name: "left", type: Union(Union(Union(ArrayAssignmentTarget, ObjectAssignmentTarget), Union(AssignmentTargetIdentifier, MemberAssignmentTarget)), VariableDeclaration) },
    { name: "right", type: Expression },
    { name: "body", type: Statement }
  ];

  ForOfStatement.typeName = "ForOfStatement";
  ForOfStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ForOfStatement" },
    { name: "left", type: Union(Union(Union(ArrayAssignmentTarget, ObjectAssignmentTarget), Union(AssignmentTargetIdentifier, MemberAssignmentTarget)), VariableDeclaration) },
    { name: "right", type: Expression },
    { name: "body", type: Statement }
  ];

  ForStatement.typeName = "ForStatement";
  ForStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ForStatement" },
    { name: "init", type: Maybe(Union(Expression, VariableDeclaration)) },
    { name: "test", type: Maybe(Expression) },
    { name: "update", type: Maybe(Expression) },
    { name: "body", type: Statement }
  ];

  FormalParameters.typeName = "FormalParameters";
  FormalParameters.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "FormalParameters" },
    { name: "items", type: List(Union(BindingWithDefault, Union(BindingIdentifier, Union(ArrayBinding, ObjectBinding)))) },
    { name: "rest", type: Maybe(Union(BindingIdentifier, Union(ArrayBinding, ObjectBinding))) }
  ];

  FunctionBody.typeName = "FunctionBody";
  FunctionBody.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "FunctionBody" },
    { name: "directives", type: List(Directive) },
    { name: "statements", type: List(Statement) }
  ];

  FunctionDeclaration.typeName = "FunctionDeclaration";
  FunctionDeclaration.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "FunctionDeclaration" },
    { name: "isGenerator", type: BOOLEAN },
    { name: "name", type: BindingIdentifier },
    { name: "params", type: FormalParameters },
    { name: "body", type: FunctionBody }
  ];

  FunctionExpression.typeName = "FunctionExpression";
  FunctionExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "FunctionExpression" },
    { name: "isGenerator", type: BOOLEAN },
    { name: "name", type: Maybe(BindingIdentifier) },
    { name: "params", type: FormalParameters },
    { name: "body", type: FunctionBody }
  ];

  Getter.typeName = "Getter";
  Getter.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "Getter" },
    { name: "name", type: PropertyName },
    { name: "body", type: FunctionBody }
  ];

  IdentifierExpression.typeName = "IdentifierExpression";
  IdentifierExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "IdentifierExpression" },
    { name: "name", type: STRING }
  ];

  IfStatement.typeName = "IfStatement";
  IfStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "IfStatement" },
    { name: "test", type: Expression },
    { name: "consequent", type: Statement },
    { name: "alternate", type: Maybe(Statement) }
  ];

  Import.typeName = "Import";
  Import.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "Import" },
    { name: "defaultBinding", type: Maybe(BindingIdentifier) },
    { name: "namedImports", type: List(ImportSpecifier) },
    { name: "moduleSpecifier", type: STRING }
  ];

  ImportNamespace.typeName = "ImportNamespace";
  ImportNamespace.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ImportNamespace" },
    { name: "defaultBinding", type: Maybe(BindingIdentifier) },
    { name: "namespaceBinding", type: BindingIdentifier },
    { name: "moduleSpecifier", type: STRING }
  ];

  ImportSpecifier.typeName = "ImportSpecifier";
  ImportSpecifier.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ImportSpecifier" },
    { name: "name", type: Maybe(STRING) },
    { name: "binding", type: BindingIdentifier }
  ];

  LabeledStatement.typeName = "LabeledStatement";
  LabeledStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "LabeledStatement" },
    { name: "label", type: STRING },
    { name: "body", type: Statement }
  ];

  LiteralBooleanExpression.typeName = "LiteralBooleanExpression";
  LiteralBooleanExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralBooleanExpression" },
    { name: "value", type: BOOLEAN }
  ];

  LiteralInfinityExpression.typeName = "LiteralInfinityExpression";
  LiteralInfinityExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralInfinityExpression" }
  ];

  LiteralNullExpression.typeName = "LiteralNullExpression";
  LiteralNullExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralNullExpression" }
  ];

  LiteralNumericExpression.typeName = "LiteralNumericExpression";
  LiteralNumericExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralNumericExpression" },
    { name: "value", type: DOUBLE }
  ];

  LiteralRegExpExpression.typeName = "LiteralRegExpExpression";
  LiteralRegExpExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralRegExpExpression" },
    { name: "pattern", type: STRING },
    { name: "global", type: BOOLEAN },
    { name: "ignoreCase", type: BOOLEAN },
    { name: "multiLine", type: BOOLEAN },
    { name: "sticky", type: BOOLEAN },
    { name: "unicode", type: BOOLEAN }
  ];

  LiteralStringExpression.typeName = "LiteralStringExpression";
  LiteralStringExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "LiteralStringExpression" },
    { name: "value", type: STRING }
  ];

  Method.typeName = "Method";
  Method.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "Method" },
    { name: "isGenerator", type: BOOLEAN },
    { name: "name", type: PropertyName },
    { name: "params", type: FormalParameters },
    { name: "body", type: FunctionBody }
  ];

  Module.typeName = "Module";
  Module.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "Module" },
    { name: "directives", type: List(Directive) },
    { name: "items", type: List(Union(ExportDeclaration, ImportDeclaration, Statement)) }
  ];

  NewExpression.typeName = "NewExpression";
  NewExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "NewExpression" },
    { name: "callee", type: Expression },
    { name: "arguments", type: List(Union(Expression, SpreadElement)) }
  ];

  NewTargetExpression.typeName = "NewTargetExpression";
  NewTargetExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "NewTargetExpression" }
  ];

  ObjectAssignmentTarget.typeName = "ObjectAssignmentTarget";
  ObjectAssignmentTarget.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ObjectAssignmentTarget" },
    { name: "properties", type: List(AssignmentTargetProperty) }
  ];

  ObjectBinding.typeName = "ObjectBinding";
  ObjectBinding.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ObjectBinding" },
    { name: "properties", type: List(BindingProperty) }
  ];

  ObjectExpression.typeName = "ObjectExpression";
  ObjectExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ObjectExpression" },
    { name: "properties", type: List(ObjectProperty) }
  ];

  ReturnStatement.typeName = "ReturnStatement";
  ReturnStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ReturnStatement" },
    { name: "expression", type: Maybe(Expression) }
  ];

  Script.typeName = "Script";
  Script.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "Script" },
    { name: "directives", type: List(Directive) },
    { name: "statements", type: List(Statement) }
  ];

  Setter.typeName = "Setter";
  Setter.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "Setter" },
    { name: "name", type: PropertyName },
    { name: "param", type: Union(BindingWithDefault, Union(BindingIdentifier, Union(ArrayBinding, ObjectBinding))) },
    { name: "body", type: FunctionBody }
  ];

  ShorthandProperty.typeName = "ShorthandProperty";
  ShorthandProperty.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ShorthandProperty" },
    { name: "name", type: IdentifierExpression }
  ];

  SpreadElement.typeName = "SpreadElement";
  SpreadElement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "SpreadElement" },
    { name: "expression", type: Expression }
  ];

  StaticMemberAssignmentTarget.typeName = "StaticMemberAssignmentTarget";
  StaticMemberAssignmentTarget.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "StaticMemberAssignmentTarget" },
    { name: "object", type: Union(Expression, Super) },
    { name: "property", type: STRING }
  ];

  StaticMemberExpression.typeName = "StaticMemberExpression";
  StaticMemberExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "StaticMemberExpression" },
    { name: "object", type: Union(Expression, Super) },
    { name: "property", type: STRING }
  ];

  StaticPropertyName.typeName = "StaticPropertyName";
  StaticPropertyName.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "StaticPropertyName" },
    { name: "value", type: STRING }
  ];

  Super.typeName = "Super";
  Super.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "Super" }
  ];

  SwitchCase.typeName = "SwitchCase";
  SwitchCase.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchCase" },
    { name: "test", type: Expression },
    { name: "consequent", type: List(Statement) }
  ];

  SwitchDefault.typeName = "SwitchDefault";
  SwitchDefault.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchDefault" },
    { name: "consequent", type: List(Statement) }
  ];

  SwitchStatement.typeName = "SwitchStatement";
  SwitchStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchStatement" },
    { name: "discriminant", type: Expression },
    { name: "cases", type: List(SwitchCase) }
  ];

  SwitchStatementWithDefault.typeName = "SwitchStatementWithDefault";
  SwitchStatementWithDefault.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "SwitchStatementWithDefault" },
    { name: "discriminant", type: Expression },
    { name: "preDefaultCases", type: List(SwitchCase) },
    { name: "defaultCase", type: SwitchDefault },
    { name: "postDefaultCases", type: List(SwitchCase) }
  ];

  TemplateElement.typeName = "TemplateElement";
  TemplateElement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "TemplateElement" },
    { name: "rawValue", type: STRING }
  ];

  TemplateExpression.typeName = "TemplateExpression";
  TemplateExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "TemplateExpression" },
    { name: "tag", type: Maybe(Expression) },
    { name: "elements", type: List(Union(Expression, TemplateElement)) }
  ];

  ThisExpression.typeName = "ThisExpression";
  ThisExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ThisExpression" }
  ];

  ThrowStatement.typeName = "ThrowStatement";
  ThrowStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "ThrowStatement" },
    { name: "expression", type: Expression }
  ];

  TryCatchStatement.typeName = "TryCatchStatement";
  TryCatchStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "TryCatchStatement" },
    { name: "body", type: Block },
    { name: "catchClause", type: CatchClause }
  ];

  TryFinallyStatement.typeName = "TryFinallyStatement";
  TryFinallyStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "TryFinallyStatement" },
    { name: "body", type: Block },
    { name: "catchClause", type: Maybe(CatchClause) },
    { name: "finalizer", type: Block }
  ];

  UnaryExpression.typeName = "UnaryExpression";
  UnaryExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "UnaryExpression" },
    { name: "operator", type: UnaryOperator },
    { name: "operand", type: Expression }
  ];

  UpdateExpression.typeName = "UpdateExpression";
  UpdateExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "UpdateExpression" },
    { name: "isPrefix", type: BOOLEAN },
    { name: "operator", type: UpdateOperator },
    { name: "operand", type: Union(AssignmentTargetIdentifier, MemberAssignmentTarget) }
  ];

  VariableDeclaration.typeName = "VariableDeclaration";
  VariableDeclaration.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "VariableDeclaration" },
    { name: "kind", type: VariableDeclarationKind },
    { name: "declarators", type: List(VariableDeclarator) }
  ];

  VariableDeclarationStatement.typeName = "VariableDeclarationStatement";
  VariableDeclarationStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "VariableDeclarationStatement" },
    { name: "declaration", type: VariableDeclaration }
  ];

  VariableDeclarator.typeName = "VariableDeclarator";
  VariableDeclarator.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "VariableDeclarator" },
    { name: "binding", type: Union(BindingIdentifier, Union(ArrayBinding, ObjectBinding)) },
    { name: "init", type: Maybe(Expression) }
  ];

  WhileStatement.typeName = "WhileStatement";
  WhileStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "WhileStatement" },
    { name: "test", type: Expression },
    { name: "body", type: Statement }
  ];

  WithStatement.typeName = "WithStatement";
  WithStatement.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "WithStatement" },
    { name: "object", type: Expression },
    { name: "body", type: Statement }
  ];

  YieldExpression.typeName = "YieldExpression";
  YieldExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "YieldExpression" },
    { name: "expression", type: Maybe(Expression) }
  ];

  YieldGeneratorExpression.typeName = "YieldGeneratorExpression";
  YieldGeneratorExpression.fields = [
    { name: "type", type: Const(TYPE_INDICATOR), value: "YieldGeneratorExpression" },
    { name: "expression", type: Expression }
  ];

  return SPEC;
}());

},{}]},{},[1]);
