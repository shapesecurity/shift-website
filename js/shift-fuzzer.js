(()=>{var e=Object.getOwnPropertyNames,t=(t,r)=>function(){return r||(0,t[e(t)[0]])((r={exports:{}}).exports,r),r.exports},r=t({"node_modules/shift-ast/gen/checked.js"(e){function t(e){return void 0===e||"ArrayExpression"!==e.type&&"ArrowExpression"!==e.type&&"AssignmentExpression"!==e.type&&"AwaitExpression"!==e.type&&"BinaryExpression"!==e.type&&"CallExpression"!==e.type&&"ClassExpression"!==e.type&&"CompoundAssignmentExpression"!==e.type&&"ConditionalExpression"!==e.type&&"FunctionExpression"!==e.type&&"IdentifierExpression"!==e.type&&"LiteralBooleanExpression"!==e.type&&"LiteralInfinityExpression"!==e.type&&"LiteralNullExpression"!==e.type&&"LiteralNumericExpression"!==e.type&&"LiteralRegExpExpression"!==e.type&&"LiteralStringExpression"!==e.type&&"ComputedMemberExpression"!==e.type&&"StaticMemberExpression"!==e.type&&"NewExpression"!==e.type&&"NewTargetExpression"!==e.type&&"ObjectExpression"!==e.type&&"TemplateExpression"!==e.type&&"ThisExpression"!==e.type&&"UnaryExpression"!==e.type&&"UpdateExpression"!==e.type&&"YieldExpression"!==e.type&&"YieldGeneratorExpression"!==e.type}function r(e){return void 0===e||"BlockStatement"!==e.type&&"BreakStatement"!==e.type&&"ClassDeclaration"!==e.type&&"ContinueStatement"!==e.type&&"DebuggerStatement"!==e.type&&"EmptyStatement"!==e.type&&"ExpressionStatement"!==e.type&&"FunctionDeclaration"!==e.type&&"IfStatement"!==e.type&&"DoWhileStatement"!==e.type&&"ForAwaitStatement"!==e.type&&"ForInStatement"!==e.type&&"ForOfStatement"!==e.type&&"ForStatement"!==e.type&&"WhileStatement"!==e.type&&"LabeledStatement"!==e.type&&"ReturnStatement"!==e.type&&"SwitchStatement"!==e.type&&"SwitchStatementWithDefault"!==e.type&&"ThrowStatement"!==e.type&&"TryCatchStatement"!==e.type&&"TryFinallyStatement"!==e.type&&"VariableDeclarationStatement"!==e.type&&"WithStatement"!==e.type}function o(e){return"object"!=typeof e?typeof e:Array.isArray(e)?`[${e.map(o).join(", ")}]`:null===e?null:e.type?e.type:JSON.stringify(e)}function n(e,t){return e.length===t.length&&e.every(((e,r)=>e===t[r]))}e.ArrayAssignmentTarget=class{constructor(e,...t){const{elements:r,rest:i}=e;if(0!==t.length)throw new TypeError("ArrayAssignmentTarget constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["elements","rest"]))throw new TypeError("Argument to ArrayAssignmentTarget constructor has wrong keys: expected {elements, rest}, got {"+Object.keys(e).join(", ")+"}");if(!Array.isArray(r)||r.some((e=>void 0===e||null!==e&&"AssignmentTargetWithDefault"!==e.type&&"ArrayAssignmentTarget"!==e.type&&"ObjectAssignmentTarget"!==e.type&&"AssignmentTargetIdentifier"!==e.type&&"ComputedMemberAssignmentTarget"!==e.type&&"StaticMemberAssignmentTarget"!==e.type)))throw new TypeError('Field "elements" of ArrayAssignmentTarget constructor argument is of incorrect type (expected [null or one of {AssignmentTargetWithDefault, ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}], got '+o(r)+")");if(void 0===i||null!==i&&"ArrayAssignmentTarget"!==i.type&&"ObjectAssignmentTarget"!==i.type&&"AssignmentTargetIdentifier"!==i.type&&"ComputedMemberAssignmentTarget"!==i.type&&"StaticMemberAssignmentTarget"!==i.type)throw new TypeError('Field "rest" of ArrayAssignmentTarget constructor argument is of incorrect type (expected null or one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got '+o(i)+")");this.type="ArrayAssignmentTarget",this.elements=r,this.rest=i}},e.ArrayBinding=class{constructor(e,...t){const{elements:r,rest:i}=e;if(0!==t.length)throw new TypeError("ArrayBinding constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["elements","rest"]))throw new TypeError("Argument to ArrayBinding constructor has wrong keys: expected {elements, rest}, got {"+Object.keys(e).join(", ")+"}");if(!Array.isArray(r)||r.some((e=>void 0===e||null!==e&&"BindingWithDefault"!==e.type&&"BindingIdentifier"!==e.type&&"ArrayBinding"!==e.type&&"ObjectBinding"!==e.type)))throw new TypeError('Field "elements" of ArrayBinding constructor argument is of incorrect type (expected [null or one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}], got '+o(r)+")");if(void 0===i||null!==i&&"BindingIdentifier"!==i.type&&"ArrayBinding"!==i.type&&"ObjectBinding"!==i.type)throw new TypeError('Field "rest" of ArrayBinding constructor argument is of incorrect type (expected null or one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got '+o(i)+")");this.type="ArrayBinding",this.elements=r,this.rest=i}},e.ArrayExpression=class{constructor(e,...r){const{elements:i}=e;if(0!==r.length)throw new TypeError("ArrayExpression constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["elements"]))throw new TypeError("Argument to ArrayExpression constructor has wrong keys: expected {elements}, got {"+Object.keys(e).join(", ")+"}");if(!Array.isArray(i)||i.some((e=>void 0===e||null!==e&&t(e)&&"SpreadElement"!==e.type)))throw new TypeError('Field "elements" of ArrayExpression constructor argument is of incorrect type (expected [null or one of {Expression, SpreadElement}], got '+o(i)+")");this.type="ArrayExpression",this.elements=i}},e.ArrowExpression=class{constructor(e,...r){const{isAsync:i,params:s,body:u}=e;if(0!==r.length)throw new TypeError("ArrowExpression constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["body","isAsync","params"]))throw new TypeError("Argument to ArrowExpression constructor has wrong keys: expected {isAsync, params, body}, got {"+Object.keys(e).join(", ")+"}");if("boolean"!=typeof i)throw new TypeError('Field "isAsync" of ArrowExpression constructor argument is of incorrect type (expected boolean, got '+o(i)+")");if(void 0===s||"FormalParameters"!==s.type)throw new TypeError('Field "params" of ArrowExpression constructor argument is of incorrect type (expected FormalParameters, got '+o(s)+")");if(void 0===u||t(u)&&"FunctionBody"!==u.type)throw new TypeError('Field "body" of ArrowExpression constructor argument is of incorrect type (expected one of {Expression, FunctionBody}, got '+o(u)+")");this.type="ArrowExpression",this.isAsync=i,this.params=s,this.body=u}},e.AssignmentExpression=class{constructor(e,...r){const{binding:i,expression:s}=e;if(0!==r.length)throw new TypeError("AssignmentExpression constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["binding","expression"]))throw new TypeError("Argument to AssignmentExpression constructor has wrong keys: expected {binding, expression}, got {"+Object.keys(e).join(", ")+"}");if(void 0===i||"ArrayAssignmentTarget"!==i.type&&"ObjectAssignmentTarget"!==i.type&&"AssignmentTargetIdentifier"!==i.type&&"ComputedMemberAssignmentTarget"!==i.type&&"StaticMemberAssignmentTarget"!==i.type)throw new TypeError('Field "binding" of AssignmentExpression constructor argument is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got '+o(i)+")");if(t(s))throw new TypeError('Field "expression" of AssignmentExpression constructor argument is of incorrect type (expected Expression, got '+o(s)+")");this.type="AssignmentExpression",this.binding=i,this.expression=s}},e.AssignmentTargetIdentifier=class{constructor(e,...t){const{name:r}=e;if(0!==t.length)throw new TypeError("AssignmentTargetIdentifier constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["name"]))throw new TypeError("Argument to AssignmentTargetIdentifier constructor has wrong keys: expected {name}, got {"+Object.keys(e).join(", ")+"}");if("string"!=typeof r)throw new TypeError('Field "name" of AssignmentTargetIdentifier constructor argument is of incorrect type (expected string, got '+o(r)+")");this.type="AssignmentTargetIdentifier",this.name=r}},e.AssignmentTargetPropertyIdentifier=class{constructor(e,...r){const{binding:i,init:s}=e;if(0!==r.length)throw new TypeError("AssignmentTargetPropertyIdentifier constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["binding","init"]))throw new TypeError("Argument to AssignmentTargetPropertyIdentifier constructor has wrong keys: expected {binding, init}, got {"+Object.keys(e).join(", ")+"}");if(void 0===i||"AssignmentTargetIdentifier"!==i.type)throw new TypeError('Field "binding" of AssignmentTargetPropertyIdentifier constructor argument is of incorrect type (expected AssignmentTargetIdentifier, got '+o(i)+")");if(void 0===s||null!==s&&t(s))throw new TypeError('Field "init" of AssignmentTargetPropertyIdentifier constructor argument is of incorrect type (expected null or Expression, got '+o(s)+")");this.type="AssignmentTargetPropertyIdentifier",this.binding=i,this.init=s}},e.AssignmentTargetPropertyProperty=class{constructor(e,...t){const{name:r,binding:i}=e;if(0!==t.length)throw new TypeError("AssignmentTargetPropertyProperty constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["binding","name"]))throw new TypeError("Argument to AssignmentTargetPropertyProperty constructor has wrong keys: expected {name, binding}, got {"+Object.keys(e).join(", ")+"}");if(void 0===r||"ComputedPropertyName"!==r.type&&"StaticPropertyName"!==r.type)throw new TypeError('Field "name" of AssignmentTargetPropertyProperty constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got '+o(r)+")");if(void 0===i||"AssignmentTargetWithDefault"!==i.type&&"ArrayAssignmentTarget"!==i.type&&"ObjectAssignmentTarget"!==i.type&&"AssignmentTargetIdentifier"!==i.type&&"ComputedMemberAssignmentTarget"!==i.type&&"StaticMemberAssignmentTarget"!==i.type)throw new TypeError('Field "binding" of AssignmentTargetPropertyProperty constructor argument is of incorrect type (expected one of {AssignmentTargetWithDefault, ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got '+o(i)+")");this.type="AssignmentTargetPropertyProperty",this.name=r,this.binding=i}},e.AssignmentTargetWithDefault=class{constructor(e,...r){const{binding:i,init:s}=e;if(0!==r.length)throw new TypeError("AssignmentTargetWithDefault constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["binding","init"]))throw new TypeError("Argument to AssignmentTargetWithDefault constructor has wrong keys: expected {binding, init}, got {"+Object.keys(e).join(", ")+"}");if(void 0===i||"ArrayAssignmentTarget"!==i.type&&"ObjectAssignmentTarget"!==i.type&&"AssignmentTargetIdentifier"!==i.type&&"ComputedMemberAssignmentTarget"!==i.type&&"StaticMemberAssignmentTarget"!==i.type)throw new TypeError('Field "binding" of AssignmentTargetWithDefault constructor argument is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got '+o(i)+")");if(t(s))throw new TypeError('Field "init" of AssignmentTargetWithDefault constructor argument is of incorrect type (expected Expression, got '+o(s)+")");this.type="AssignmentTargetWithDefault",this.binding=i,this.init=s}},e.AwaitExpression=class{constructor(e,...r){const{expression:i}=e;if(0!==r.length)throw new TypeError("AwaitExpression constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["expression"]))throw new TypeError("Argument to AwaitExpression constructor has wrong keys: expected {expression}, got {"+Object.keys(e).join(", ")+"}");if(t(i))throw new TypeError('Field "expression" of AwaitExpression constructor argument is of incorrect type (expected Expression, got '+o(i)+")");this.type="AwaitExpression",this.expression=i}},e.BinaryExpression=class{constructor(e,...r){const{left:i,operator:s,right:u}=e;if(0!==r.length)throw new TypeError("BinaryExpression constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["left","operator","right"]))throw new TypeError("Argument to BinaryExpression constructor has wrong keys: expected {left, operator, right}, got {"+Object.keys(e).join(", ")+"}");if(t(i))throw new TypeError('Field "left" of BinaryExpression constructor argument is of incorrect type (expected Expression, got '+o(i)+")");if(void 0===s||-1===["==","!=","===","!==","<","<=",">",">=","in","instanceof","<<",">>",">>>","+","-","*","/","%","**",",","||","&&","|","^","&"].indexOf(s))throw new TypeError('Field "operator" of BinaryExpression constructor argument is of incorrect type (expected one of {"==", "!=", "===", "!==", "<", "<=", ">", ">=", "in", "instanceof", "<<", ">>", ">>>", "+", "-", "*", "/", "%", "**", ",", "||", "&&", "|", "^", "&"}, got '+o(s)+")");if(t(u))throw new TypeError('Field "right" of BinaryExpression constructor argument is of incorrect type (expected Expression, got '+o(u)+")");this.type="BinaryExpression",this.left=i,this.operator=s,this.right=u}},e.BindingIdentifier=class{constructor(e,...t){const{name:r}=e;if(0!==t.length)throw new TypeError("BindingIdentifier constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["name"]))throw new TypeError("Argument to BindingIdentifier constructor has wrong keys: expected {name}, got {"+Object.keys(e).join(", ")+"}");if("string"!=typeof r)throw new TypeError('Field "name" of BindingIdentifier constructor argument is of incorrect type (expected string, got '+o(r)+")");this.type="BindingIdentifier",this.name=r}},e.BindingPropertyIdentifier=class{constructor(e,...r){const{binding:i,init:s}=e;if(0!==r.length)throw new TypeError("BindingPropertyIdentifier constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["binding","init"]))throw new TypeError("Argument to BindingPropertyIdentifier constructor has wrong keys: expected {binding, init}, got {"+Object.keys(e).join(", ")+"}");if(void 0===i||"BindingIdentifier"!==i.type)throw new TypeError('Field "binding" of BindingPropertyIdentifier constructor argument is of incorrect type (expected BindingIdentifier, got '+o(i)+")");if(void 0===s||null!==s&&t(s))throw new TypeError('Field "init" of BindingPropertyIdentifier constructor argument is of incorrect type (expected null or Expression, got '+o(s)+")");this.type="BindingPropertyIdentifier",this.binding=i,this.init=s}},e.BindingPropertyProperty=class{constructor(e,...t){const{name:r,binding:i}=e;if(0!==t.length)throw new TypeError("BindingPropertyProperty constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["binding","name"]))throw new TypeError("Argument to BindingPropertyProperty constructor has wrong keys: expected {name, binding}, got {"+Object.keys(e).join(", ")+"}");if(void 0===r||"ComputedPropertyName"!==r.type&&"StaticPropertyName"!==r.type)throw new TypeError('Field "name" of BindingPropertyProperty constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got '+o(r)+")");if(void 0===i||"BindingWithDefault"!==i.type&&"BindingIdentifier"!==i.type&&"ArrayBinding"!==i.type&&"ObjectBinding"!==i.type)throw new TypeError('Field "binding" of BindingPropertyProperty constructor argument is of incorrect type (expected one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}, got '+o(i)+")");this.type="BindingPropertyProperty",this.name=r,this.binding=i}},e.BindingWithDefault=class{constructor(e,...r){const{binding:i,init:s}=e;if(0!==r.length)throw new TypeError("BindingWithDefault constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["binding","init"]))throw new TypeError("Argument to BindingWithDefault constructor has wrong keys: expected {binding, init}, got {"+Object.keys(e).join(", ")+"}");if(void 0===i||"BindingIdentifier"!==i.type&&"ArrayBinding"!==i.type&&"ObjectBinding"!==i.type)throw new TypeError('Field "binding" of BindingWithDefault constructor argument is of incorrect type (expected one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got '+o(i)+")");if(t(s))throw new TypeError('Field "init" of BindingWithDefault constructor argument is of incorrect type (expected Expression, got '+o(s)+")");this.type="BindingWithDefault",this.binding=i,this.init=s}},e.Block=class{constructor(e,...t){const{statements:i}=e;if(0!==t.length)throw new TypeError("Block constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["statements"]))throw new TypeError("Argument to Block constructor has wrong keys: expected {statements}, got {"+Object.keys(e).join(", ")+"}");if(!Array.isArray(i)||i.some((e=>r(e))))throw new TypeError('Field "statements" of Block constructor argument is of incorrect type (expected [Statement], got '+o(i)+")");this.type="Block",this.statements=i}},e.BlockStatement=class{constructor(e,...t){const{block:r}=e;if(0!==t.length)throw new TypeError("BlockStatement constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["block"]))throw new TypeError("Argument to BlockStatement constructor has wrong keys: expected {block}, got {"+Object.keys(e).join(", ")+"}");if(void 0===r||"Block"!==r.type)throw new TypeError('Field "block" of BlockStatement constructor argument is of incorrect type (expected Block, got '+o(r)+")");this.type="BlockStatement",this.block=r}},e.BreakStatement=class{constructor(e,...t){const{label:r}=e;if(0!==t.length)throw new TypeError("BreakStatement constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["label"]))throw new TypeError("Argument to BreakStatement constructor has wrong keys: expected {label}, got {"+Object.keys(e).join(", ")+"}");if(void 0===r||null!==r&&"string"!=typeof r)throw new TypeError('Field "label" of BreakStatement constructor argument is of incorrect type (expected null or string, got '+o(r)+")");this.type="BreakStatement",this.label=r}},e.CallExpression=class{constructor(e,...r){const{callee:i,arguments:s}=e;if(0!==r.length)throw new TypeError("CallExpression constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["arguments","callee"]))throw new TypeError("Argument to CallExpression constructor has wrong keys: expected {callee, arguments}, got {"+Object.keys(e).join(", ")+"}");if(void 0===i||t(i)&&"Super"!==i.type)throw new TypeError('Field "callee" of CallExpression constructor argument is of incorrect type (expected one of {Expression, Super}, got '+o(i)+")");if(!Array.isArray(s)||s.some((e=>void 0===e||t(e)&&"SpreadElement"!==e.type)))throw new TypeError('Field "arguments" of CallExpression constructor argument is of incorrect type (expected [one of {Expression, SpreadElement}], got '+o(s)+")");this.type="CallExpression",this.callee=i,this.arguments=s}},e.CatchClause=class{constructor(e,...t){const{binding:r,body:i}=e;if(0!==t.length)throw new TypeError("CatchClause constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["binding","body"]))throw new TypeError("Argument to CatchClause constructor has wrong keys: expected {binding, body}, got {"+Object.keys(e).join(", ")+"}");if(void 0===r||null!==r&&"BindingIdentifier"!==r.type&&"ArrayBinding"!==r.type&&"ObjectBinding"!==r.type)throw new TypeError('Field "binding" of CatchClause constructor argument is of incorrect type (expected null or one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got '+o(r)+")");if(void 0===i||"Block"!==i.type)throw new TypeError('Field "body" of CatchClause constructor argument is of incorrect type (expected Block, got '+o(i)+")");this.type="CatchClause",this.binding=r,this.body=i}},e.ClassDeclaration=class{constructor(e,...r){const{name:i,super:s,elements:u}=e;if(0!==r.length)throw new TypeError("ClassDeclaration constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["elements","name","super"]))throw new TypeError("Argument to ClassDeclaration constructor has wrong keys: expected {name, super, elements}, got {"+Object.keys(e).join(", ")+"}");if(void 0===i||"BindingIdentifier"!==i.type)throw new TypeError('Field "name" of ClassDeclaration constructor argument is of incorrect type (expected BindingIdentifier, got '+o(i)+")");if(void 0===s||null!==s&&t(s))throw new TypeError('Field "super" of ClassDeclaration constructor argument is of incorrect type (expected null or Expression, got '+o(s)+")");if(!Array.isArray(u)||u.some((e=>void 0===e||"ClassElement"!==e.type)))throw new TypeError('Field "elements" of ClassDeclaration constructor argument is of incorrect type (expected [ClassElement], got '+o(u)+")");this.type="ClassDeclaration",this.name=i,this.super=s,this.elements=u}},e.ClassElement=class{constructor(e,...t){const{isStatic:r,method:i}=e;if(0!==t.length)throw new TypeError("ClassElement constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["isStatic","method"]))throw new TypeError("Argument to ClassElement constructor has wrong keys: expected {isStatic, method}, got {"+Object.keys(e).join(", ")+"}");if("boolean"!=typeof r)throw new TypeError('Field "isStatic" of ClassElement constructor argument is of incorrect type (expected boolean, got '+o(r)+")");if(void 0===i||"Getter"!==i.type&&"Method"!==i.type&&"Setter"!==i.type)throw new TypeError('Field "method" of ClassElement constructor argument is of incorrect type (expected one of {Getter, Method, Setter}, got '+o(i)+")");this.type="ClassElement",this.isStatic=r,this.method=i}},e.ClassExpression=class{constructor(e,...r){const{name:i,super:s,elements:u}=e;if(0!==r.length)throw new TypeError("ClassExpression constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["elements","name","super"]))throw new TypeError("Argument to ClassExpression constructor has wrong keys: expected {name, super, elements}, got {"+Object.keys(e).join(", ")+"}");if(void 0===i||null!==i&&"BindingIdentifier"!==i.type)throw new TypeError('Field "name" of ClassExpression constructor argument is of incorrect type (expected null or BindingIdentifier, got '+o(i)+")");if(void 0===s||null!==s&&t(s))throw new TypeError('Field "super" of ClassExpression constructor argument is of incorrect type (expected null or Expression, got '+o(s)+")");if(!Array.isArray(u)||u.some((e=>void 0===e||"ClassElement"!==e.type)))throw new TypeError('Field "elements" of ClassExpression constructor argument is of incorrect type (expected [ClassElement], got '+o(u)+")");this.type="ClassExpression",this.name=i,this.super=s,this.elements=u}},e.CompoundAssignmentExpression=class{constructor(e,...r){const{binding:i,operator:s,expression:u}=e;if(0!==r.length)throw new TypeError("CompoundAssignmentExpression constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["binding","expression","operator"]))throw new TypeError("Argument to CompoundAssignmentExpression constructor has wrong keys: expected {binding, operator, expression}, got {"+Object.keys(e).join(", ")+"}");if(void 0===i||"AssignmentTargetIdentifier"!==i.type&&"ComputedMemberAssignmentTarget"!==i.type&&"StaticMemberAssignmentTarget"!==i.type)throw new TypeError('Field "binding" of CompoundAssignmentExpression constructor argument is of incorrect type (expected one of {AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got '+o(i)+")");if(void 0===s||-1===["+=","-=","*=","/=","%=","**=","<<=",">>=",">>>=","|=","^=","&="].indexOf(s))throw new TypeError('Field "operator" of CompoundAssignmentExpression constructor argument is of incorrect type (expected one of {"+=", "-=", "*=", "/=", "%=", "**=", "<<=", ">>=", ">>>=", "|=", "^=", "&="}, got '+o(s)+")");if(t(u))throw new TypeError('Field "expression" of CompoundAssignmentExpression constructor argument is of incorrect type (expected Expression, got '+o(u)+")");this.type="CompoundAssignmentExpression",this.binding=i,this.operator=s,this.expression=u}},e.ComputedMemberAssignmentTarget=class{constructor(e,...r){const{object:i,expression:s}=e;if(0!==r.length)throw new TypeError("ComputedMemberAssignmentTarget constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["expression","object"]))throw new TypeError("Argument to ComputedMemberAssignmentTarget constructor has wrong keys: expected {object, expression}, got {"+Object.keys(e).join(", ")+"}");if(void 0===i||t(i)&&"Super"!==i.type)throw new TypeError('Field "object" of ComputedMemberAssignmentTarget constructor argument is of incorrect type (expected one of {Expression, Super}, got '+o(i)+")");if(t(s))throw new TypeError('Field "expression" of ComputedMemberAssignmentTarget constructor argument is of incorrect type (expected Expression, got '+o(s)+")");this.type="ComputedMemberAssignmentTarget",this.object=i,this.expression=s}},e.ComputedMemberExpression=class{constructor(e,...r){const{object:i,expression:s}=e;if(0!==r.length)throw new TypeError("ComputedMemberExpression constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["expression","object"]))throw new TypeError("Argument to ComputedMemberExpression constructor has wrong keys: expected {object, expression}, got {"+Object.keys(e).join(", ")+"}");if(void 0===i||t(i)&&"Super"!==i.type)throw new TypeError('Field "object" of ComputedMemberExpression constructor argument is of incorrect type (expected one of {Expression, Super}, got '+o(i)+")");if(t(s))throw new TypeError('Field "expression" of ComputedMemberExpression constructor argument is of incorrect type (expected Expression, got '+o(s)+")");this.type="ComputedMemberExpression",this.object=i,this.expression=s}},e.ComputedPropertyName=class{constructor(e,...r){const{expression:i}=e;if(0!==r.length)throw new TypeError("ComputedPropertyName constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["expression"]))throw new TypeError("Argument to ComputedPropertyName constructor has wrong keys: expected {expression}, got {"+Object.keys(e).join(", ")+"}");if(t(i))throw new TypeError('Field "expression" of ComputedPropertyName constructor argument is of incorrect type (expected Expression, got '+o(i)+")");this.type="ComputedPropertyName",this.expression=i}},e.ConditionalExpression=class{constructor(e,...r){const{test:i,consequent:s,alternate:u}=e;if(0!==r.length)throw new TypeError("ConditionalExpression constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["alternate","consequent","test"]))throw new TypeError("Argument to ConditionalExpression constructor has wrong keys: expected {test, consequent, alternate}, got {"+Object.keys(e).join(", ")+"}");if(t(i))throw new TypeError('Field "test" of ConditionalExpression constructor argument is of incorrect type (expected Expression, got '+o(i)+")");if(t(s))throw new TypeError('Field "consequent" of ConditionalExpression constructor argument is of incorrect type (expected Expression, got '+o(s)+")");if(t(u))throw new TypeError('Field "alternate" of ConditionalExpression constructor argument is of incorrect type (expected Expression, got '+o(u)+")");this.type="ConditionalExpression",this.test=i,this.consequent=s,this.alternate=u}},e.ContinueStatement=class{constructor(e,...t){const{label:r}=e;if(0!==t.length)throw new TypeError("ContinueStatement constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["label"]))throw new TypeError("Argument to ContinueStatement constructor has wrong keys: expected {label}, got {"+Object.keys(e).join(", ")+"}");if(void 0===r||null!==r&&"string"!=typeof r)throw new TypeError('Field "label" of ContinueStatement constructor argument is of incorrect type (expected null or string, got '+o(r)+")");this.type="ContinueStatement",this.label=r}},e.DataProperty=class{constructor(e,...r){const{name:i,expression:s}=e;if(0!==r.length)throw new TypeError("DataProperty constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["expression","name"]))throw new TypeError("Argument to DataProperty constructor has wrong keys: expected {name, expression}, got {"+Object.keys(e).join(", ")+"}");if(void 0===i||"ComputedPropertyName"!==i.type&&"StaticPropertyName"!==i.type)throw new TypeError('Field "name" of DataProperty constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got '+o(i)+")");if(t(s))throw new TypeError('Field "expression" of DataProperty constructor argument is of incorrect type (expected Expression, got '+o(s)+")");this.type="DataProperty",this.name=i,this.expression=s}},e.DebuggerStatement=class{constructor(...e){if(e.length>1||1===e.length&&("object"!=typeof e[0]||null===e[0]||0!==Object.keys(e[0]).length))throw new TypeError("DebuggerStatement constructor takes no arguments");this.type="DebuggerStatement"}},e.Directive=class{constructor(e,...t){const{rawValue:r}=e;if(0!==t.length)throw new TypeError("Directive constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["rawValue"]))throw new TypeError("Argument to Directive constructor has wrong keys: expected {rawValue}, got {"+Object.keys(e).join(", ")+"}");if("string"!=typeof r)throw new TypeError('Field "rawValue" of Directive constructor argument is of incorrect type (expected string, got '+o(r)+")");this.type="Directive",this.rawValue=r}},e.DoWhileStatement=class{constructor(e,...i){const{body:s,test:u}=e;if(0!==i.length)throw new TypeError("DoWhileStatement constructor takes exactly one argument ("+(1+i.length)+" given)");if(!n(Object.keys(e).sort(),["body","test"]))throw new TypeError("Argument to DoWhileStatement constructor has wrong keys: expected {body, test}, got {"+Object.keys(e).join(", ")+"}");if(r(s))throw new TypeError('Field "body" of DoWhileStatement constructor argument is of incorrect type (expected Statement, got '+o(s)+")");if(t(u))throw new TypeError('Field "test" of DoWhileStatement constructor argument is of incorrect type (expected Expression, got '+o(u)+")");this.type="DoWhileStatement",this.body=s,this.test=u}},e.EmptyStatement=class{constructor(...e){if(e.length>1||1===e.length&&("object"!=typeof e[0]||null===e[0]||0!==Object.keys(e[0]).length))throw new TypeError("EmptyStatement constructor takes no arguments");this.type="EmptyStatement"}},e.Export=class{constructor(e,...t){const{declaration:r}=e;if(0!==t.length)throw new TypeError("Export constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["declaration"]))throw new TypeError("Argument to Export constructor has wrong keys: expected {declaration}, got {"+Object.keys(e).join(", ")+"}");if(void 0===r||"ClassDeclaration"!==r.type&&"FunctionDeclaration"!==r.type&&"VariableDeclaration"!==r.type)throw new TypeError('Field "declaration" of Export constructor argument is of incorrect type (expected one of {ClassDeclaration, FunctionDeclaration, VariableDeclaration}, got '+o(r)+")");this.type="Export",this.declaration=r}},e.ExportAllFrom=class{constructor(e,...t){const{moduleSpecifier:r}=e;if(0!==t.length)throw new TypeError("ExportAllFrom constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["moduleSpecifier"]))throw new TypeError("Argument to ExportAllFrom constructor has wrong keys: expected {moduleSpecifier}, got {"+Object.keys(e).join(", ")+"}");if("string"!=typeof r)throw new TypeError('Field "moduleSpecifier" of ExportAllFrom constructor argument is of incorrect type (expected string, got '+o(r)+")");this.type="ExportAllFrom",this.moduleSpecifier=r}},e.ExportDefault=class{constructor(e,...r){const{body:i}=e;if(0!==r.length)throw new TypeError("ExportDefault constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["body"]))throw new TypeError("Argument to ExportDefault constructor has wrong keys: expected {body}, got {"+Object.keys(e).join(", ")+"}");if(void 0===i||"ClassDeclaration"!==i.type&&t(i)&&"FunctionDeclaration"!==i.type)throw new TypeError('Field "body" of ExportDefault constructor argument is of incorrect type (expected one of {ClassDeclaration, Expression, FunctionDeclaration}, got '+o(i)+")");this.type="ExportDefault",this.body=i}},e.ExportFrom=class{constructor(e,...t){const{namedExports:r,moduleSpecifier:i}=e;if(0!==t.length)throw new TypeError("ExportFrom constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["moduleSpecifier","namedExports"]))throw new TypeError("Argument to ExportFrom constructor has wrong keys: expected {namedExports, moduleSpecifier}, got {"+Object.keys(e).join(", ")+"}");if(!Array.isArray(r)||r.some((e=>void 0===e||"ExportFromSpecifier"!==e.type)))throw new TypeError('Field "namedExports" of ExportFrom constructor argument is of incorrect type (expected [ExportFromSpecifier], got '+o(r)+")");if("string"!=typeof i)throw new TypeError('Field "moduleSpecifier" of ExportFrom constructor argument is of incorrect type (expected string, got '+o(i)+")");this.type="ExportFrom",this.namedExports=r,this.moduleSpecifier=i}},e.ExportFromSpecifier=class{constructor(e,...t){const{name:r,exportedName:i}=e;if(0!==t.length)throw new TypeError("ExportFromSpecifier constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["exportedName","name"]))throw new TypeError("Argument to ExportFromSpecifier constructor has wrong keys: expected {name, exportedName}, got {"+Object.keys(e).join(", ")+"}");if("string"!=typeof r)throw new TypeError('Field "name" of ExportFromSpecifier constructor argument is of incorrect type (expected string, got '+o(r)+")");if(void 0===i||null!==i&&"string"!=typeof i)throw new TypeError('Field "exportedName" of ExportFromSpecifier constructor argument is of incorrect type (expected null or string, got '+o(i)+")");this.type="ExportFromSpecifier",this.name=r,this.exportedName=i}},e.ExportLocalSpecifier=class{constructor(e,...t){const{name:r,exportedName:i}=e;if(0!==t.length)throw new TypeError("ExportLocalSpecifier constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["exportedName","name"]))throw new TypeError("Argument to ExportLocalSpecifier constructor has wrong keys: expected {name, exportedName}, got {"+Object.keys(e).join(", ")+"}");if(void 0===r||"IdentifierExpression"!==r.type)throw new TypeError('Field "name" of ExportLocalSpecifier constructor argument is of incorrect type (expected IdentifierExpression, got '+o(r)+")");if(void 0===i||null!==i&&"string"!=typeof i)throw new TypeError('Field "exportedName" of ExportLocalSpecifier constructor argument is of incorrect type (expected null or string, got '+o(i)+")");this.type="ExportLocalSpecifier",this.name=r,this.exportedName=i}},e.ExportLocals=class{constructor(e,...t){const{namedExports:r}=e;if(0!==t.length)throw new TypeError("ExportLocals constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["namedExports"]))throw new TypeError("Argument to ExportLocals constructor has wrong keys: expected {namedExports}, got {"+Object.keys(e).join(", ")+"}");if(!Array.isArray(r)||r.some((e=>void 0===e||"ExportLocalSpecifier"!==e.type)))throw new TypeError('Field "namedExports" of ExportLocals constructor argument is of incorrect type (expected [ExportLocalSpecifier], got '+o(r)+")");this.type="ExportLocals",this.namedExports=r}},e.ExpressionStatement=class{constructor(e,...r){const{expression:i}=e;if(0!==r.length)throw new TypeError("ExpressionStatement constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["expression"]))throw new TypeError("Argument to ExpressionStatement constructor has wrong keys: expected {expression}, got {"+Object.keys(e).join(", ")+"}");if(t(i))throw new TypeError('Field "expression" of ExpressionStatement constructor argument is of incorrect type (expected Expression, got '+o(i)+")");this.type="ExpressionStatement",this.expression=i}},e.ForAwaitStatement=class{constructor(e,...i){const{left:s,right:u,body:a}=e;if(0!==i.length)throw new TypeError("ForAwaitStatement constructor takes exactly one argument ("+(1+i.length)+" given)");if(!n(Object.keys(e).sort(),["body","left","right"]))throw new TypeError("Argument to ForAwaitStatement constructor has wrong keys: expected {left, right, body}, got {"+Object.keys(e).join(", ")+"}");if(void 0===s||"ArrayAssignmentTarget"!==s.type&&"ObjectAssignmentTarget"!==s.type&&"AssignmentTargetIdentifier"!==s.type&&"ComputedMemberAssignmentTarget"!==s.type&&"StaticMemberAssignmentTarget"!==s.type&&"VariableDeclaration"!==s.type)throw new TypeError('Field "left" of ForAwaitStatement constructor argument is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget, VariableDeclaration}, got '+o(s)+")");if(t(u))throw new TypeError('Field "right" of ForAwaitStatement constructor argument is of incorrect type (expected Expression, got '+o(u)+")");if(r(a))throw new TypeError('Field "body" of ForAwaitStatement constructor argument is of incorrect type (expected Statement, got '+o(a)+")");this.type="ForAwaitStatement",this.left=s,this.right=u,this.body=a}},e.ForInStatement=class{constructor(e,...i){const{left:s,right:u,body:a}=e;if(0!==i.length)throw new TypeError("ForInStatement constructor takes exactly one argument ("+(1+i.length)+" given)");if(!n(Object.keys(e).sort(),["body","left","right"]))throw new TypeError("Argument to ForInStatement constructor has wrong keys: expected {left, right, body}, got {"+Object.keys(e).join(", ")+"}");if(void 0===s||"ArrayAssignmentTarget"!==s.type&&"ObjectAssignmentTarget"!==s.type&&"AssignmentTargetIdentifier"!==s.type&&"ComputedMemberAssignmentTarget"!==s.type&&"StaticMemberAssignmentTarget"!==s.type&&"VariableDeclaration"!==s.type)throw new TypeError('Field "left" of ForInStatement constructor argument is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget, VariableDeclaration}, got '+o(s)+")");if(t(u))throw new TypeError('Field "right" of ForInStatement constructor argument is of incorrect type (expected Expression, got '+o(u)+")");if(r(a))throw new TypeError('Field "body" of ForInStatement constructor argument is of incorrect type (expected Statement, got '+o(a)+")");this.type="ForInStatement",this.left=s,this.right=u,this.body=a}},e.ForOfStatement=class{constructor(e,...i){const{left:s,right:u,body:a}=e;if(0!==i.length)throw new TypeError("ForOfStatement constructor takes exactly one argument ("+(1+i.length)+" given)");if(!n(Object.keys(e).sort(),["body","left","right"]))throw new TypeError("Argument to ForOfStatement constructor has wrong keys: expected {left, right, body}, got {"+Object.keys(e).join(", ")+"}");if(void 0===s||"ArrayAssignmentTarget"!==s.type&&"ObjectAssignmentTarget"!==s.type&&"AssignmentTargetIdentifier"!==s.type&&"ComputedMemberAssignmentTarget"!==s.type&&"StaticMemberAssignmentTarget"!==s.type&&"VariableDeclaration"!==s.type)throw new TypeError('Field "left" of ForOfStatement constructor argument is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget, VariableDeclaration}, got '+o(s)+")");if(t(u))throw new TypeError('Field "right" of ForOfStatement constructor argument is of incorrect type (expected Expression, got '+o(u)+")");if(r(a))throw new TypeError('Field "body" of ForOfStatement constructor argument is of incorrect type (expected Statement, got '+o(a)+")");this.type="ForOfStatement",this.left=s,this.right=u,this.body=a}},e.ForStatement=class{constructor(e,...i){const{init:s,test:u,update:a,body:c}=e;if(0!==i.length)throw new TypeError("ForStatement constructor takes exactly one argument ("+(1+i.length)+" given)");if(!n(Object.keys(e).sort(),["body","init","test","update"]))throw new TypeError("Argument to ForStatement constructor has wrong keys: expected {init, test, update, body}, got {"+Object.keys(e).join(", ")+"}");if(void 0===s||null!==s&&t(s)&&"VariableDeclaration"!==s.type)throw new TypeError('Field "init" of ForStatement constructor argument is of incorrect type (expected null or one of {Expression, VariableDeclaration}, got '+o(s)+")");if(void 0===u||null!==u&&t(u))throw new TypeError('Field "test" of ForStatement constructor argument is of incorrect type (expected null or Expression, got '+o(u)+")");if(void 0===a||null!==a&&t(a))throw new TypeError('Field "update" of ForStatement constructor argument is of incorrect type (expected null or Expression, got '+o(a)+")");if(r(c))throw new TypeError('Field "body" of ForStatement constructor argument is of incorrect type (expected Statement, got '+o(c)+")");this.type="ForStatement",this.init=s,this.test=u,this.update=a,this.body=c}},e.FormalParameters=class{constructor(e,...t){const{items:r,rest:i}=e;if(0!==t.length)throw new TypeError("FormalParameters constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["items","rest"]))throw new TypeError("Argument to FormalParameters constructor has wrong keys: expected {items, rest}, got {"+Object.keys(e).join(", ")+"}");if(!Array.isArray(r)||r.some((e=>void 0===e||"BindingWithDefault"!==e.type&&"BindingIdentifier"!==e.type&&"ArrayBinding"!==e.type&&"ObjectBinding"!==e.type)))throw new TypeError('Field "items" of FormalParameters constructor argument is of incorrect type (expected [one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}], got '+o(r)+")");if(void 0===i||null!==i&&"BindingIdentifier"!==i.type&&"ArrayBinding"!==i.type&&"ObjectBinding"!==i.type)throw new TypeError('Field "rest" of FormalParameters constructor argument is of incorrect type (expected null or one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got '+o(i)+")");this.type="FormalParameters",this.items=r,this.rest=i}},e.FunctionBody=class{constructor(e,...t){const{directives:i,statements:s}=e;if(0!==t.length)throw new TypeError("FunctionBody constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["directives","statements"]))throw new TypeError("Argument to FunctionBody constructor has wrong keys: expected {directives, statements}, got {"+Object.keys(e).join(", ")+"}");if(!Array.isArray(i)||i.some((e=>void 0===e||"Directive"!==e.type)))throw new TypeError('Field "directives" of FunctionBody constructor argument is of incorrect type (expected [Directive], got '+o(i)+")");if(!Array.isArray(s)||s.some((e=>r(e))))throw new TypeError('Field "statements" of FunctionBody constructor argument is of incorrect type (expected [Statement], got '+o(s)+")");this.type="FunctionBody",this.directives=i,this.statements=s}},e.FunctionDeclaration=class{constructor(e,...t){const{isAsync:r,isGenerator:i,name:s,params:u,body:a}=e;if(0!==t.length)throw new TypeError("FunctionDeclaration constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["body","isAsync","isGenerator","name","params"]))throw new TypeError("Argument to FunctionDeclaration constructor has wrong keys: expected {isAsync, isGenerator, name, params, body}, got {"+Object.keys(e).join(", ")+"}");if("boolean"!=typeof r)throw new TypeError('Field "isAsync" of FunctionDeclaration constructor argument is of incorrect type (expected boolean, got '+o(r)+")");if("boolean"!=typeof i)throw new TypeError('Field "isGenerator" of FunctionDeclaration constructor argument is of incorrect type (expected boolean, got '+o(i)+")");if(void 0===s||"BindingIdentifier"!==s.type)throw new TypeError('Field "name" of FunctionDeclaration constructor argument is of incorrect type (expected BindingIdentifier, got '+o(s)+")");if(void 0===u||"FormalParameters"!==u.type)throw new TypeError('Field "params" of FunctionDeclaration constructor argument is of incorrect type (expected FormalParameters, got '+o(u)+")");if(void 0===a||"FunctionBody"!==a.type)throw new TypeError('Field "body" of FunctionDeclaration constructor argument is of incorrect type (expected FunctionBody, got '+o(a)+")");this.type="FunctionDeclaration",this.isAsync=r,this.isGenerator=i,this.name=s,this.params=u,this.body=a}},e.FunctionExpression=class{constructor(e,...t){const{isAsync:r,isGenerator:i,name:s,params:u,body:a}=e;if(0!==t.length)throw new TypeError("FunctionExpression constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["body","isAsync","isGenerator","name","params"]))throw new TypeError("Argument to FunctionExpression constructor has wrong keys: expected {isAsync, isGenerator, name, params, body}, got {"+Object.keys(e).join(", ")+"}");if("boolean"!=typeof r)throw new TypeError('Field "isAsync" of FunctionExpression constructor argument is of incorrect type (expected boolean, got '+o(r)+")");if("boolean"!=typeof i)throw new TypeError('Field "isGenerator" of FunctionExpression constructor argument is of incorrect type (expected boolean, got '+o(i)+")");if(void 0===s||null!==s&&"BindingIdentifier"!==s.type)throw new TypeError('Field "name" of FunctionExpression constructor argument is of incorrect type (expected null or BindingIdentifier, got '+o(s)+")");if(void 0===u||"FormalParameters"!==u.type)throw new TypeError('Field "params" of FunctionExpression constructor argument is of incorrect type (expected FormalParameters, got '+o(u)+")");if(void 0===a||"FunctionBody"!==a.type)throw new TypeError('Field "body" of FunctionExpression constructor argument is of incorrect type (expected FunctionBody, got '+o(a)+")");this.type="FunctionExpression",this.isAsync=r,this.isGenerator=i,this.name=s,this.params=u,this.body=a}},e.Getter=class{constructor(e,...t){const{name:r,body:i}=e;if(0!==t.length)throw new TypeError("Getter constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["body","name"]))throw new TypeError("Argument to Getter constructor has wrong keys: expected {name, body}, got {"+Object.keys(e).join(", ")+"}");if(void 0===r||"ComputedPropertyName"!==r.type&&"StaticPropertyName"!==r.type)throw new TypeError('Field "name" of Getter constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got '+o(r)+")");if(void 0===i||"FunctionBody"!==i.type)throw new TypeError('Field "body" of Getter constructor argument is of incorrect type (expected FunctionBody, got '+o(i)+")");this.type="Getter",this.name=r,this.body=i}},e.IdentifierExpression=class{constructor(e,...t){const{name:r}=e;if(0!==t.length)throw new TypeError("IdentifierExpression constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["name"]))throw new TypeError("Argument to IdentifierExpression constructor has wrong keys: expected {name}, got {"+Object.keys(e).join(", ")+"}");if("string"!=typeof r)throw new TypeError('Field "name" of IdentifierExpression constructor argument is of incorrect type (expected string, got '+o(r)+")");this.type="IdentifierExpression",this.name=r}},e.IfStatement=class{constructor(e,...i){const{test:s,consequent:u,alternate:a}=e;if(0!==i.length)throw new TypeError("IfStatement constructor takes exactly one argument ("+(1+i.length)+" given)");if(!n(Object.keys(e).sort(),["alternate","consequent","test"]))throw new TypeError("Argument to IfStatement constructor has wrong keys: expected {test, consequent, alternate}, got {"+Object.keys(e).join(", ")+"}");if(t(s))throw new TypeError('Field "test" of IfStatement constructor argument is of incorrect type (expected Expression, got '+o(s)+")");if(r(u))throw new TypeError('Field "consequent" of IfStatement constructor argument is of incorrect type (expected Statement, got '+o(u)+")");if(void 0===a||null!==a&&r(a))throw new TypeError('Field "alternate" of IfStatement constructor argument is of incorrect type (expected null or Statement, got '+o(a)+")");this.type="IfStatement",this.test=s,this.consequent=u,this.alternate=a}},e.Import=class{constructor(e,...t){const{defaultBinding:r,namedImports:i,moduleSpecifier:s}=e;if(0!==t.length)throw new TypeError("Import constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["defaultBinding","moduleSpecifier","namedImports"]))throw new TypeError("Argument to Import constructor has wrong keys: expected {defaultBinding, namedImports, moduleSpecifier}, got {"+Object.keys(e).join(", ")+"}");if(void 0===r||null!==r&&"BindingIdentifier"!==r.type)throw new TypeError('Field "defaultBinding" of Import constructor argument is of incorrect type (expected null or BindingIdentifier, got '+o(r)+")");if(!Array.isArray(i)||i.some((e=>void 0===e||"ImportSpecifier"!==e.type)))throw new TypeError('Field "namedImports" of Import constructor argument is of incorrect type (expected [ImportSpecifier], got '+o(i)+")");if("string"!=typeof s)throw new TypeError('Field "moduleSpecifier" of Import constructor argument is of incorrect type (expected string, got '+o(s)+")");this.type="Import",this.defaultBinding=r,this.namedImports=i,this.moduleSpecifier=s}},e.ImportNamespace=class{constructor(e,...t){const{defaultBinding:r,namespaceBinding:i,moduleSpecifier:s}=e;if(0!==t.length)throw new TypeError("ImportNamespace constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["defaultBinding","moduleSpecifier","namespaceBinding"]))throw new TypeError("Argument to ImportNamespace constructor has wrong keys: expected {defaultBinding, namespaceBinding, moduleSpecifier}, got {"+Object.keys(e).join(", ")+"}");if(void 0===r||null!==r&&"BindingIdentifier"!==r.type)throw new TypeError('Field "defaultBinding" of ImportNamespace constructor argument is of incorrect type (expected null or BindingIdentifier, got '+o(r)+")");if(void 0===i||"BindingIdentifier"!==i.type)throw new TypeError('Field "namespaceBinding" of ImportNamespace constructor argument is of incorrect type (expected BindingIdentifier, got '+o(i)+")");if("string"!=typeof s)throw new TypeError('Field "moduleSpecifier" of ImportNamespace constructor argument is of incorrect type (expected string, got '+o(s)+")");this.type="ImportNamespace",this.defaultBinding=r,this.namespaceBinding=i,this.moduleSpecifier=s}},e.ImportSpecifier=class{constructor(e,...t){const{name:r,binding:i}=e;if(0!==t.length)throw new TypeError("ImportSpecifier constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["binding","name"]))throw new TypeError("Argument to ImportSpecifier constructor has wrong keys: expected {name, binding}, got {"+Object.keys(e).join(", ")+"}");if(void 0===r||null!==r&&"string"!=typeof r)throw new TypeError('Field "name" of ImportSpecifier constructor argument is of incorrect type (expected null or string, got '+o(r)+")");if(void 0===i||"BindingIdentifier"!==i.type)throw new TypeError('Field "binding" of ImportSpecifier constructor argument is of incorrect type (expected BindingIdentifier, got '+o(i)+")");this.type="ImportSpecifier",this.name=r,this.binding=i}},e.LabeledStatement=class{constructor(e,...t){const{label:i,body:s}=e;if(0!==t.length)throw new TypeError("LabeledStatement constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["body","label"]))throw new TypeError("Argument to LabeledStatement constructor has wrong keys: expected {label, body}, got {"+Object.keys(e).join(", ")+"}");if("string"!=typeof i)throw new TypeError('Field "label" of LabeledStatement constructor argument is of incorrect type (expected string, got '+o(i)+")");if(r(s))throw new TypeError('Field "body" of LabeledStatement constructor argument is of incorrect type (expected Statement, got '+o(s)+")");this.type="LabeledStatement",this.label=i,this.body=s}},e.LiteralBooleanExpression=class{constructor(e,...t){const{value:r}=e;if(0!==t.length)throw new TypeError("LiteralBooleanExpression constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["value"]))throw new TypeError("Argument to LiteralBooleanExpression constructor has wrong keys: expected {value}, got {"+Object.keys(e).join(", ")+"}");if("boolean"!=typeof r)throw new TypeError('Field "value" of LiteralBooleanExpression constructor argument is of incorrect type (expected boolean, got '+o(r)+")");this.type="LiteralBooleanExpression",this.value=r}},e.LiteralInfinityExpression=class{constructor(...e){if(e.length>1||1===e.length&&("object"!=typeof e[0]||null===e[0]||0!==Object.keys(e[0]).length))throw new TypeError("LiteralInfinityExpression constructor takes no arguments");this.type="LiteralInfinityExpression"}},e.LiteralNullExpression=class{constructor(...e){if(e.length>1||1===e.length&&("object"!=typeof e[0]||null===e[0]||0!==Object.keys(e[0]).length))throw new TypeError("LiteralNullExpression constructor takes no arguments");this.type="LiteralNullExpression"}},e.LiteralNumericExpression=class{constructor(e,...t){const{value:r}=e;if(0!==t.length)throw new TypeError("LiteralNumericExpression constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["value"]))throw new TypeError("Argument to LiteralNumericExpression constructor has wrong keys: expected {value}, got {"+Object.keys(e).join(", ")+"}");if("number"!=typeof r)throw new TypeError('Field "value" of LiteralNumericExpression constructor argument is of incorrect type (expected number, got '+o(r)+")");this.type="LiteralNumericExpression",this.value=r}},e.LiteralRegExpExpression=class{constructor(e,...t){const{pattern:r,global:i,ignoreCase:s,multiLine:u,dotAll:a,unicode:c,sticky:p}=e;if(0!==t.length)throw new TypeError("LiteralRegExpExpression constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["dotAll","global","ignoreCase","multiLine","pattern","sticky","unicode"]))throw new TypeError("Argument to LiteralRegExpExpression constructor has wrong keys: expected {pattern, global, ignoreCase, multiLine, dotAll, unicode, sticky}, got {"+Object.keys(e).join(", ")+"}");if("string"!=typeof r)throw new TypeError('Field "pattern" of LiteralRegExpExpression constructor argument is of incorrect type (expected string, got '+o(r)+")");if("boolean"!=typeof i)throw new TypeError('Field "global" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got '+o(i)+")");if("boolean"!=typeof s)throw new TypeError('Field "ignoreCase" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got '+o(s)+")");if("boolean"!=typeof u)throw new TypeError('Field "multiLine" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got '+o(u)+")");if("boolean"!=typeof a)throw new TypeError('Field "dotAll" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got '+o(a)+")");if("boolean"!=typeof c)throw new TypeError('Field "unicode" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got '+o(c)+")");if("boolean"!=typeof p)throw new TypeError('Field "sticky" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got '+o(p)+")");this.type="LiteralRegExpExpression",this.pattern=r,this.global=i,this.ignoreCase=s,this.multiLine=u,this.dotAll=a,this.unicode=c,this.sticky=p}},e.LiteralStringExpression=class{constructor(e,...t){const{value:r}=e;if(0!==t.length)throw new TypeError("LiteralStringExpression constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["value"]))throw new TypeError("Argument to LiteralStringExpression constructor has wrong keys: expected {value}, got {"+Object.keys(e).join(", ")+"}");if("string"!=typeof r)throw new TypeError('Field "value" of LiteralStringExpression constructor argument is of incorrect type (expected string, got '+o(r)+")");this.type="LiteralStringExpression",this.value=r}},e.Method=class{constructor(e,...t){const{isAsync:r,isGenerator:i,name:s,params:u,body:a}=e;if(0!==t.length)throw new TypeError("Method constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["body","isAsync","isGenerator","name","params"]))throw new TypeError("Argument to Method constructor has wrong keys: expected {isAsync, isGenerator, name, params, body}, got {"+Object.keys(e).join(", ")+"}");if("boolean"!=typeof r)throw new TypeError('Field "isAsync" of Method constructor argument is of incorrect type (expected boolean, got '+o(r)+")");if("boolean"!=typeof i)throw new TypeError('Field "isGenerator" of Method constructor argument is of incorrect type (expected boolean, got '+o(i)+")");if(void 0===s||"ComputedPropertyName"!==s.type&&"StaticPropertyName"!==s.type)throw new TypeError('Field "name" of Method constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got '+o(s)+")");if(void 0===u||"FormalParameters"!==u.type)throw new TypeError('Field "params" of Method constructor argument is of incorrect type (expected FormalParameters, got '+o(u)+")");if(void 0===a||"FunctionBody"!==a.type)throw new TypeError('Field "body" of Method constructor argument is of incorrect type (expected FunctionBody, got '+o(a)+")");this.type="Method",this.isAsync=r,this.isGenerator=i,this.name=s,this.params=u,this.body=a}},e.Module=class{constructor(e,...t){const{directives:i,items:s}=e;if(0!==t.length)throw new TypeError("Module constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["directives","items"]))throw new TypeError("Argument to Module constructor has wrong keys: expected {directives, items}, got {"+Object.keys(e).join(", ")+"}");if(!Array.isArray(i)||i.some((e=>void 0===e||"Directive"!==e.type)))throw new TypeError('Field "directives" of Module constructor argument is of incorrect type (expected [Directive], got '+o(i)+")");if(!Array.isArray(s)||s.some((e=>void 0===e||"Export"!==e.type&&"ExportAllFrom"!==e.type&&"ExportDefault"!==e.type&&"ExportFrom"!==e.type&&"ExportLocals"!==e.type&&"Import"!==e.type&&"ImportNamespace"!==e.type&&r(e))))throw new TypeError('Field "items" of Module constructor argument is of incorrect type (expected [one of {Export, ExportAllFrom, ExportDefault, ExportFrom, ExportLocals, Import, ImportNamespace, Statement}], got '+o(s)+")");this.type="Module",this.directives=i,this.items=s}},e.NewExpression=class{constructor(e,...r){const{callee:i,arguments:s}=e;if(0!==r.length)throw new TypeError("NewExpression constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["arguments","callee"]))throw new TypeError("Argument to NewExpression constructor has wrong keys: expected {callee, arguments}, got {"+Object.keys(e).join(", ")+"}");if(t(i))throw new TypeError('Field "callee" of NewExpression constructor argument is of incorrect type (expected Expression, got '+o(i)+")");if(!Array.isArray(s)||s.some((e=>void 0===e||t(e)&&"SpreadElement"!==e.type)))throw new TypeError('Field "arguments" of NewExpression constructor argument is of incorrect type (expected [one of {Expression, SpreadElement}], got '+o(s)+")");this.type="NewExpression",this.callee=i,this.arguments=s}},e.NewTargetExpression=class{constructor(...e){if(e.length>1||1===e.length&&("object"!=typeof e[0]||null===e[0]||0!==Object.keys(e[0]).length))throw new TypeError("NewTargetExpression constructor takes no arguments");this.type="NewTargetExpression"}},e.ObjectAssignmentTarget=class{constructor(e,...t){const{properties:r,rest:i}=e;if(0!==t.length)throw new TypeError("ObjectAssignmentTarget constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["properties","rest"]))throw new TypeError("Argument to ObjectAssignmentTarget constructor has wrong keys: expected {properties, rest}, got {"+Object.keys(e).join(", ")+"}");if(!Array.isArray(r)||r.some((e=>void 0===e||"AssignmentTargetPropertyIdentifier"!==e.type&&"AssignmentTargetPropertyProperty"!==e.type)))throw new TypeError('Field "properties" of ObjectAssignmentTarget constructor argument is of incorrect type (expected [one of {AssignmentTargetPropertyIdentifier, AssignmentTargetPropertyProperty}], got '+o(r)+")");if(void 0===i||null!==i&&"AssignmentTargetIdentifier"!==i.type&&"ComputedMemberAssignmentTarget"!==i.type&&"StaticMemberAssignmentTarget"!==i.type)throw new TypeError('Field "rest" of ObjectAssignmentTarget constructor argument is of incorrect type (expected null or one of {AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got '+o(i)+")");this.type="ObjectAssignmentTarget",this.properties=r,this.rest=i}},e.ObjectBinding=class{constructor(e,...t){const{properties:r,rest:i}=e;if(0!==t.length)throw new TypeError("ObjectBinding constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["properties","rest"]))throw new TypeError("Argument to ObjectBinding constructor has wrong keys: expected {properties, rest}, got {"+Object.keys(e).join(", ")+"}");if(!Array.isArray(r)||r.some((e=>void 0===e||"BindingPropertyIdentifier"!==e.type&&"BindingPropertyProperty"!==e.type)))throw new TypeError('Field "properties" of ObjectBinding constructor argument is of incorrect type (expected [one of {BindingPropertyIdentifier, BindingPropertyProperty}], got '+o(r)+")");if(void 0===i||null!==i&&"BindingIdentifier"!==i.type)throw new TypeError('Field "rest" of ObjectBinding constructor argument is of incorrect type (expected null or BindingIdentifier, got '+o(i)+")");this.type="ObjectBinding",this.properties=r,this.rest=i}},e.ObjectExpression=class{constructor(e,...t){const{properties:r}=e;if(0!==t.length)throw new TypeError("ObjectExpression constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["properties"]))throw new TypeError("Argument to ObjectExpression constructor has wrong keys: expected {properties}, got {"+Object.keys(e).join(", ")+"}");if(!Array.isArray(r)||r.some((e=>void 0===e||"DataProperty"!==e.type&&"Getter"!==e.type&&"Method"!==e.type&&"Setter"!==e.type&&"ShorthandProperty"!==e.type&&"SpreadProperty"!==e.type)))throw new TypeError('Field "properties" of ObjectExpression constructor argument is of incorrect type (expected [one of {DataProperty, Getter, Method, Setter, ShorthandProperty, SpreadProperty}], got '+o(r)+")");this.type="ObjectExpression",this.properties=r}},e.ReturnStatement=class{constructor(e,...r){const{expression:i}=e;if(0!==r.length)throw new TypeError("ReturnStatement constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["expression"]))throw new TypeError("Argument to ReturnStatement constructor has wrong keys: expected {expression}, got {"+Object.keys(e).join(", ")+"}");if(void 0===i||null!==i&&t(i))throw new TypeError('Field "expression" of ReturnStatement constructor argument is of incorrect type (expected null or Expression, got '+o(i)+")");this.type="ReturnStatement",this.expression=i}},e.Script=class{constructor(e,...t){const{directives:i,statements:s}=e;if(0!==t.length)throw new TypeError("Script constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["directives","statements"]))throw new TypeError("Argument to Script constructor has wrong keys: expected {directives, statements}, got {"+Object.keys(e).join(", ")+"}");if(!Array.isArray(i)||i.some((e=>void 0===e||"Directive"!==e.type)))throw new TypeError('Field "directives" of Script constructor argument is of incorrect type (expected [Directive], got '+o(i)+")");if(!Array.isArray(s)||s.some((e=>r(e))))throw new TypeError('Field "statements" of Script constructor argument is of incorrect type (expected [Statement], got '+o(s)+")");this.type="Script",this.directives=i,this.statements=s}},e.Setter=class{constructor(e,...t){const{name:r,param:i,body:s}=e;if(0!==t.length)throw new TypeError("Setter constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["body","name","param"]))throw new TypeError("Argument to Setter constructor has wrong keys: expected {name, param, body}, got {"+Object.keys(e).join(", ")+"}");if(void 0===r||"ComputedPropertyName"!==r.type&&"StaticPropertyName"!==r.type)throw new TypeError('Field "name" of Setter constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got '+o(r)+")");if(void 0===i||"BindingWithDefault"!==i.type&&"BindingIdentifier"!==i.type&&"ArrayBinding"!==i.type&&"ObjectBinding"!==i.type)throw new TypeError('Field "param" of Setter constructor argument is of incorrect type (expected one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}, got '+o(i)+")");if(void 0===s||"FunctionBody"!==s.type)throw new TypeError('Field "body" of Setter constructor argument is of incorrect type (expected FunctionBody, got '+o(s)+")");this.type="Setter",this.name=r,this.param=i,this.body=s}},e.ShorthandProperty=class{constructor(e,...t){const{name:r}=e;if(0!==t.length)throw new TypeError("ShorthandProperty constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["name"]))throw new TypeError("Argument to ShorthandProperty constructor has wrong keys: expected {name}, got {"+Object.keys(e).join(", ")+"}");if(void 0===r||"IdentifierExpression"!==r.type)throw new TypeError('Field "name" of ShorthandProperty constructor argument is of incorrect type (expected IdentifierExpression, got '+o(r)+")");this.type="ShorthandProperty",this.name=r}},e.SpreadElement=class{constructor(e,...r){const{expression:i}=e;if(0!==r.length)throw new TypeError("SpreadElement constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["expression"]))throw new TypeError("Argument to SpreadElement constructor has wrong keys: expected {expression}, got {"+Object.keys(e).join(", ")+"}");if(t(i))throw new TypeError('Field "expression" of SpreadElement constructor argument is of incorrect type (expected Expression, got '+o(i)+")");this.type="SpreadElement",this.expression=i}},e.SpreadProperty=class{constructor(e,...r){const{expression:i}=e;if(0!==r.length)throw new TypeError("SpreadProperty constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["expression"]))throw new TypeError("Argument to SpreadProperty constructor has wrong keys: expected {expression}, got {"+Object.keys(e).join(", ")+"}");if(t(i))throw new TypeError('Field "expression" of SpreadProperty constructor argument is of incorrect type (expected Expression, got '+o(i)+")");this.type="SpreadProperty",this.expression=i}},e.StaticMemberAssignmentTarget=class{constructor(e,...r){const{object:i,property:s}=e;if(0!==r.length)throw new TypeError("StaticMemberAssignmentTarget constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["object","property"]))throw new TypeError("Argument to StaticMemberAssignmentTarget constructor has wrong keys: expected {object, property}, got {"+Object.keys(e).join(", ")+"}");if(void 0===i||t(i)&&"Super"!==i.type)throw new TypeError('Field "object" of StaticMemberAssignmentTarget constructor argument is of incorrect type (expected one of {Expression, Super}, got '+o(i)+")");if("string"!=typeof s)throw new TypeError('Field "property" of StaticMemberAssignmentTarget constructor argument is of incorrect type (expected string, got '+o(s)+")");this.type="StaticMemberAssignmentTarget",this.object=i,this.property=s}},e.StaticMemberExpression=class{constructor(e,...r){const{object:i,property:s}=e;if(0!==r.length)throw new TypeError("StaticMemberExpression constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["object","property"]))throw new TypeError("Argument to StaticMemberExpression constructor has wrong keys: expected {object, property}, got {"+Object.keys(e).join(", ")+"}");if(void 0===i||t(i)&&"Super"!==i.type)throw new TypeError('Field "object" of StaticMemberExpression constructor argument is of incorrect type (expected one of {Expression, Super}, got '+o(i)+")");if("string"!=typeof s)throw new TypeError('Field "property" of StaticMemberExpression constructor argument is of incorrect type (expected string, got '+o(s)+")");this.type="StaticMemberExpression",this.object=i,this.property=s}},e.StaticPropertyName=class{constructor(e,...t){const{value:r}=e;if(0!==t.length)throw new TypeError("StaticPropertyName constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["value"]))throw new TypeError("Argument to StaticPropertyName constructor has wrong keys: expected {value}, got {"+Object.keys(e).join(", ")+"}");if("string"!=typeof r)throw new TypeError('Field "value" of StaticPropertyName constructor argument is of incorrect type (expected string, got '+o(r)+")");this.type="StaticPropertyName",this.value=r}},e.Super=class{constructor(...e){if(e.length>1||1===e.length&&("object"!=typeof e[0]||null===e[0]||0!==Object.keys(e[0]).length))throw new TypeError("Super constructor takes no arguments");this.type="Super"}},e.SwitchCase=class{constructor(e,...i){const{test:s,consequent:u}=e;if(0!==i.length)throw new TypeError("SwitchCase constructor takes exactly one argument ("+(1+i.length)+" given)");if(!n(Object.keys(e).sort(),["consequent","test"]))throw new TypeError("Argument to SwitchCase constructor has wrong keys: expected {test, consequent}, got {"+Object.keys(e).join(", ")+"}");if(t(s))throw new TypeError('Field "test" of SwitchCase constructor argument is of incorrect type (expected Expression, got '+o(s)+")");if(!Array.isArray(u)||u.some((e=>r(e))))throw new TypeError('Field "consequent" of SwitchCase constructor argument is of incorrect type (expected [Statement], got '+o(u)+")");this.type="SwitchCase",this.test=s,this.consequent=u}},e.SwitchDefault=class{constructor(e,...t){const{consequent:i}=e;if(0!==t.length)throw new TypeError("SwitchDefault constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["consequent"]))throw new TypeError("Argument to SwitchDefault constructor has wrong keys: expected {consequent}, got {"+Object.keys(e).join(", ")+"}");if(!Array.isArray(i)||i.some((e=>r(e))))throw new TypeError('Field "consequent" of SwitchDefault constructor argument is of incorrect type (expected [Statement], got '+o(i)+")");this.type="SwitchDefault",this.consequent=i}},e.SwitchStatement=class{constructor(e,...r){const{discriminant:i,cases:s}=e;if(0!==r.length)throw new TypeError("SwitchStatement constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["cases","discriminant"]))throw new TypeError("Argument to SwitchStatement constructor has wrong keys: expected {discriminant, cases}, got {"+Object.keys(e).join(", ")+"}");if(t(i))throw new TypeError('Field "discriminant" of SwitchStatement constructor argument is of incorrect type (expected Expression, got '+o(i)+")");if(!Array.isArray(s)||s.some((e=>void 0===e||"SwitchCase"!==e.type)))throw new TypeError('Field "cases" of SwitchStatement constructor argument is of incorrect type (expected [SwitchCase], got '+o(s)+")");this.type="SwitchStatement",this.discriminant=i,this.cases=s}},e.SwitchStatementWithDefault=class{constructor(e,...r){const{discriminant:i,preDefaultCases:s,defaultCase:u,postDefaultCases:a}=e;if(0!==r.length)throw new TypeError("SwitchStatementWithDefault constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["defaultCase","discriminant","postDefaultCases","preDefaultCases"]))throw new TypeError("Argument to SwitchStatementWithDefault constructor has wrong keys: expected {discriminant, preDefaultCases, defaultCase, postDefaultCases}, got {"+Object.keys(e).join(", ")+"}");if(t(i))throw new TypeError('Field "discriminant" of SwitchStatementWithDefault constructor argument is of incorrect type (expected Expression, got '+o(i)+")");if(!Array.isArray(s)||s.some((e=>void 0===e||"SwitchCase"!==e.type)))throw new TypeError('Field "preDefaultCases" of SwitchStatementWithDefault constructor argument is of incorrect type (expected [SwitchCase], got '+o(s)+")");if(void 0===u||"SwitchDefault"!==u.type)throw new TypeError('Field "defaultCase" of SwitchStatementWithDefault constructor argument is of incorrect type (expected SwitchDefault, got '+o(u)+")");if(!Array.isArray(a)||a.some((e=>void 0===e||"SwitchCase"!==e.type)))throw new TypeError('Field "postDefaultCases" of SwitchStatementWithDefault constructor argument is of incorrect type (expected [SwitchCase], got '+o(a)+")");this.type="SwitchStatementWithDefault",this.discriminant=i,this.preDefaultCases=s,this.defaultCase=u,this.postDefaultCases=a}},e.TemplateElement=class{constructor(e,...t){const{rawValue:r}=e;if(0!==t.length)throw new TypeError("TemplateElement constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["rawValue"]))throw new TypeError("Argument to TemplateElement constructor has wrong keys: expected {rawValue}, got {"+Object.keys(e).join(", ")+"}");if("string"!=typeof r)throw new TypeError('Field "rawValue" of TemplateElement constructor argument is of incorrect type (expected string, got '+o(r)+")");this.type="TemplateElement",this.rawValue=r}},e.TemplateExpression=class{constructor(e,...r){const{tag:i,elements:s}=e;if(0!==r.length)throw new TypeError("TemplateExpression constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["elements","tag"]))throw new TypeError("Argument to TemplateExpression constructor has wrong keys: expected {tag, elements}, got {"+Object.keys(e).join(", ")+"}");if(void 0===i||null!==i&&t(i))throw new TypeError('Field "tag" of TemplateExpression constructor argument is of incorrect type (expected null or Expression, got '+o(i)+")");if(!Array.isArray(s)||s.some((e=>void 0===e||t(e)&&"TemplateElement"!==e.type)))throw new TypeError('Field "elements" of TemplateExpression constructor argument is of incorrect type (expected [one of {Expression, TemplateElement}], got '+o(s)+")");this.type="TemplateExpression",this.tag=i,this.elements=s}},e.ThisExpression=class{constructor(...e){if(e.length>1||1===e.length&&("object"!=typeof e[0]||null===e[0]||0!==Object.keys(e[0]).length))throw new TypeError("ThisExpression constructor takes no arguments");this.type="ThisExpression"}},e.ThrowStatement=class{constructor(e,...r){const{expression:i}=e;if(0!==r.length)throw new TypeError("ThrowStatement constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["expression"]))throw new TypeError("Argument to ThrowStatement constructor has wrong keys: expected {expression}, got {"+Object.keys(e).join(", ")+"}");if(t(i))throw new TypeError('Field "expression" of ThrowStatement constructor argument is of incorrect type (expected Expression, got '+o(i)+")");this.type="ThrowStatement",this.expression=i}},e.TryCatchStatement=class{constructor(e,...t){const{body:r,catchClause:i}=e;if(0!==t.length)throw new TypeError("TryCatchStatement constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["body","catchClause"]))throw new TypeError("Argument to TryCatchStatement constructor has wrong keys: expected {body, catchClause}, got {"+Object.keys(e).join(", ")+"}");if(void 0===r||"Block"!==r.type)throw new TypeError('Field "body" of TryCatchStatement constructor argument is of incorrect type (expected Block, got '+o(r)+")");if(void 0===i||"CatchClause"!==i.type)throw new TypeError('Field "catchClause" of TryCatchStatement constructor argument is of incorrect type (expected CatchClause, got '+o(i)+")");this.type="TryCatchStatement",this.body=r,this.catchClause=i}},e.TryFinallyStatement=class{constructor(e,...t){const{body:r,catchClause:i,finalizer:s}=e;if(0!==t.length)throw new TypeError("TryFinallyStatement constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["body","catchClause","finalizer"]))throw new TypeError("Argument to TryFinallyStatement constructor has wrong keys: expected {body, catchClause, finalizer}, got {"+Object.keys(e).join(", ")+"}");if(void 0===r||"Block"!==r.type)throw new TypeError('Field "body" of TryFinallyStatement constructor argument is of incorrect type (expected Block, got '+o(r)+")");if(void 0===i||null!==i&&"CatchClause"!==i.type)throw new TypeError('Field "catchClause" of TryFinallyStatement constructor argument is of incorrect type (expected null or CatchClause, got '+o(i)+")");if(void 0===s||"Block"!==s.type)throw new TypeError('Field "finalizer" of TryFinallyStatement constructor argument is of incorrect type (expected Block, got '+o(s)+")");this.type="TryFinallyStatement",this.body=r,this.catchClause=i,this.finalizer=s}},e.UnaryExpression=class{constructor(e,...r){const{operator:i,operand:s}=e;if(0!==r.length)throw new TypeError("UnaryExpression constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["operand","operator"]))throw new TypeError("Argument to UnaryExpression constructor has wrong keys: expected {operator, operand}, got {"+Object.keys(e).join(", ")+"}");if(void 0===i||-1===["+","-","!","~","typeof","void","delete"].indexOf(i))throw new TypeError('Field "operator" of UnaryExpression constructor argument is of incorrect type (expected one of {"+", "-", "!", "~", "typeof", "void", "delete"}, got '+o(i)+")");if(t(s))throw new TypeError('Field "operand" of UnaryExpression constructor argument is of incorrect type (expected Expression, got '+o(s)+")");this.type="UnaryExpression",this.operator=i,this.operand=s}},e.UpdateExpression=class{constructor(e,...t){const{isPrefix:r,operator:i,operand:s}=e;if(0!==t.length)throw new TypeError("UpdateExpression constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["isPrefix","operand","operator"]))throw new TypeError("Argument to UpdateExpression constructor has wrong keys: expected {isPrefix, operator, operand}, got {"+Object.keys(e).join(", ")+"}");if("boolean"!=typeof r)throw new TypeError('Field "isPrefix" of UpdateExpression constructor argument is of incorrect type (expected boolean, got '+o(r)+")");if(void 0===i||-1===["++","--"].indexOf(i))throw new TypeError('Field "operator" of UpdateExpression constructor argument is of incorrect type (expected one of {"++", "--"}, got '+o(i)+")");if(void 0===s||"AssignmentTargetIdentifier"!==s.type&&"ComputedMemberAssignmentTarget"!==s.type&&"StaticMemberAssignmentTarget"!==s.type)throw new TypeError('Field "operand" of UpdateExpression constructor argument is of incorrect type (expected one of {AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got '+o(s)+")");this.type="UpdateExpression",this.isPrefix=r,this.operator=i,this.operand=s}},e.VariableDeclaration=class{constructor(e,...t){const{kind:r,declarators:i}=e;if(0!==t.length)throw new TypeError("VariableDeclaration constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["declarators","kind"]))throw new TypeError("Argument to VariableDeclaration constructor has wrong keys: expected {kind, declarators}, got {"+Object.keys(e).join(", ")+"}");if(void 0===r||-1===["var","let","const"].indexOf(r))throw new TypeError('Field "kind" of VariableDeclaration constructor argument is of incorrect type (expected one of {"var", "let", "const"}, got '+o(r)+")");if(!Array.isArray(i)||i.some((e=>void 0===e||"VariableDeclarator"!==e.type)))throw new TypeError('Field "declarators" of VariableDeclaration constructor argument is of incorrect type (expected [VariableDeclarator], got '+o(i)+")");this.type="VariableDeclaration",this.kind=r,this.declarators=i}},e.VariableDeclarationStatement=class{constructor(e,...t){const{declaration:r}=e;if(0!==t.length)throw new TypeError("VariableDeclarationStatement constructor takes exactly one argument ("+(1+t.length)+" given)");if(!n(Object.keys(e).sort(),["declaration"]))throw new TypeError("Argument to VariableDeclarationStatement constructor has wrong keys: expected {declaration}, got {"+Object.keys(e).join(", ")+"}");if(void 0===r||"VariableDeclaration"!==r.type)throw new TypeError('Field "declaration" of VariableDeclarationStatement constructor argument is of incorrect type (expected VariableDeclaration, got '+o(r)+")");this.type="VariableDeclarationStatement",this.declaration=r}},e.VariableDeclarator=class{constructor(e,...r){const{binding:i,init:s}=e;if(0!==r.length)throw new TypeError("VariableDeclarator constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["binding","init"]))throw new TypeError("Argument to VariableDeclarator constructor has wrong keys: expected {binding, init}, got {"+Object.keys(e).join(", ")+"}");if(void 0===i||"BindingIdentifier"!==i.type&&"ArrayBinding"!==i.type&&"ObjectBinding"!==i.type)throw new TypeError('Field "binding" of VariableDeclarator constructor argument is of incorrect type (expected one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got '+o(i)+")");if(void 0===s||null!==s&&t(s))throw new TypeError('Field "init" of VariableDeclarator constructor argument is of incorrect type (expected null or Expression, got '+o(s)+")");this.type="VariableDeclarator",this.binding=i,this.init=s}},e.WhileStatement=class{constructor(e,...i){const{test:s,body:u}=e;if(0!==i.length)throw new TypeError("WhileStatement constructor takes exactly one argument ("+(1+i.length)+" given)");if(!n(Object.keys(e).sort(),["body","test"]))throw new TypeError("Argument to WhileStatement constructor has wrong keys: expected {test, body}, got {"+Object.keys(e).join(", ")+"}");if(t(s))throw new TypeError('Field "test" of WhileStatement constructor argument is of incorrect type (expected Expression, got '+o(s)+")");if(r(u))throw new TypeError('Field "body" of WhileStatement constructor argument is of incorrect type (expected Statement, got '+o(u)+")");this.type="WhileStatement",this.test=s,this.body=u}},e.WithStatement=class{constructor(e,...i){const{object:s,body:u}=e;if(0!==i.length)throw new TypeError("WithStatement constructor takes exactly one argument ("+(1+i.length)+" given)");if(!n(Object.keys(e).sort(),["body","object"]))throw new TypeError("Argument to WithStatement constructor has wrong keys: expected {object, body}, got {"+Object.keys(e).join(", ")+"}");if(t(s))throw new TypeError('Field "object" of WithStatement constructor argument is of incorrect type (expected Expression, got '+o(s)+")");if(r(u))throw new TypeError('Field "body" of WithStatement constructor argument is of incorrect type (expected Statement, got '+o(u)+")");this.type="WithStatement",this.object=s,this.body=u}},e.YieldExpression=class{constructor(e,...r){const{expression:i}=e;if(0!==r.length)throw new TypeError("YieldExpression constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["expression"]))throw new TypeError("Argument to YieldExpression constructor has wrong keys: expected {expression}, got {"+Object.keys(e).join(", ")+"}");if(void 0===i||null!==i&&t(i))throw new TypeError('Field "expression" of YieldExpression constructor argument is of incorrect type (expected null or Expression, got '+o(i)+")");this.type="YieldExpression",this.expression=i}},e.YieldGeneratorExpression=class{constructor(e,...r){const{expression:i}=e;if(0!==r.length)throw new TypeError("YieldGeneratorExpression constructor takes exactly one argument ("+(1+r.length)+" given)");if(!n(Object.keys(e).sort(),["expression"]))throw new TypeError("Argument to YieldGeneratorExpression constructor has wrong keys: expected {expression}, got {"+Object.keys(e).join(", ")+"}");if(t(i))throw new TypeError('Field "expression" of YieldGeneratorExpression constructor argument is of incorrect type (expected Expression, got '+o(i)+")");this.type="YieldGeneratorExpression",this.expression=i}}}}),o=t({"node_modules/shift-ast/checked.js"(e,t){t.exports=r()}}),n=t({"node_modules/shift-fuzzer/src/random.js"(e,t){t.exports=class{constructor(e){this.rng=e}nextBoolean(e=.5){return this.rng()<e}nextInt(e){return Math.floor(this.rng()*e)}nextDouble(){return this.rng()}nextString(){let e=this.nextInt(6),t="";for(;e-- >0;)t+=String.fromCharCode(this.nextInt(255));return t}}}}),i=t({"node_modules/shift-fuzzer/src/fuzzer-state.js"(e,t){var r=n(),o=class{constructor({maxDepth:e=7,rng:t=Math.random}={}){this.maxDepth=e,this.rng=new r(t),this.depth=0,this.inLoop=!1,this.inSwitch=!1,this.strict=!1,this.allowReturn=!1,this.allowNewTarget=!1,this.allowSuperCall=!1,this.allowSuperProp=!1,this.allowMissingElse=!0,this.declKind=null,this.allowYieldIdentifier=!0,this.allowYieldExpr=!1,this.allowAwaitIdentifier=!0,this.allowAwaitExpr=!1,this.isModule=!1,this.labels=[],this.loopLabels=[]}clone(){let e=Object.create(o.prototype);return e.maxDepth=this.maxDepth,e.rng=this.rng,e.depth=this.depth,e.inLoop=this.inLoop,e.inSwitch=this.inSwitch,e.strict=this.strict,e.allowReturn=this.allowReturn,e.allowNewTarget=this.allowNewTarget,e.allowSuperCall=this.allowSuperCall,e.allowSuperProp=this.allowSuperProp,e.allowMissingElse=this.allowMissingElse,e.declKind=this.declKind,e.allowYieldIdentifier=this.allowYieldIdentifier,e.allowYieldExpr=this.allowYieldExpr,e.allowAwaitIdentifier=this.allowAwaitIdentifier,e.allowAwaitExpr=this.allowAwaitExpr,e.isModule=this.isModule,e.labels=this.labels,e.loopLabels=this.loopLabels,e}goDeeper(){let e=this.clone();return++e.depth,e}tooDeep(){return this.depth>=this.maxDepth}allowBreak(){return this.inLoop||this.inSwitch||0!==this.labels.length}enableMissingElse(){let e=this.clone();return e.allowMissingElse=!0,e}disableMissingElse(){let e=this.clone();return e.allowMissingElse=!1,e}disableYieldExpr(){let e=this.clone();return e.allowYieldExpr=!1,e}disableAwaitExpr(){let e=this.clone();return e.allowAwaitExpr=!1,e}enterFunction({isGenerator:e=!1,isAsync:t=!1,isArrow:r=!1,isMethod:o=!1,hasStrictDirective:n=!1}={}){let i=this.clone();if(null!==i.declKind)throw"declKind";return i.inLoop=!1,i.inSwitch=!1,n&&(i.strict=!0),i.allowReturn=!0,r?i.allowYieldExpr=!1:(i.allowNewTarget=!0,e?(i.allowYieldIdentifier=!1,i.allowYieldExpr=!0):(i.allowYieldIdentifier=!0,i.allowYieldExpr=!1),o||(i.allowSuperCall=!1,i.allowSuperProp=!1)),t?(i.allowAwaitExpr=!0,i.allowAwaitIdentifier=!1):(i.allowAwaitExpr=!1,i.allowAwaitIdentifier=!i.isModule),i.allowMissingElse=!0,i.labels=[],i.loopLabels=[],i}enterLoop(){let e=this.clone();return e.inLoop=!0,e}enterSwitch(){let e=this.clone();return e.inSwitch=!0,e}};t.exports=o}}),s=t({"node_modules/shift-fuzzer/src/combinators.js"(e,t){var r=i();function o(e){return t=>u((()=>[]),((o=new r)=>{let n=o.rng.nextInt(e+1),i=[];for(;n-- >0;)i.push(t(o));return i}))}var n=o(5);function s(e,t){return(o=new r)=>(o.rng.nextBoolean()?e:t)(o)}function u(e,t){return(o=new r)=>o.tooDeep()?e(o):t(o)}t.exports={MANY_BOUND:5,manyN:o,many:n,many1:function(e){return(t=new r)=>{let o=n(e)(t);return 0===o.length&&o.push(e(t)),o}},either:s,choose:function(...e){switch(e.length){case 0:throw new Error("choose must be given at least one fuzzer");case 1:return e[0];case 2:return s(e[0],e[1]);default:return(t=new r)=>e[t.rng.nextInt(e.length)](t)}},oneOf:function(...e){return t=>e[t.rng.nextInt(e.length)]},opt:function(e){return u((()=>null),((t=new r)=>t.rng.nextBoolean()?null:e(t)))},ap:function(e,t,o=new r){let n=o.goDeeper(),i=Object.create(null);for(let e in t)t.hasOwnProperty(e)&&(i[e]=t[e](n));return new e(i)},guardDepth:u}}}),u=t({"node_modules/shift-parser/src/unicode.js"(e){e.whitespaceArray=[5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8239,8287,12288,65279],e.whitespaceBool=[!1,!1,!1,!1,!1,!1,!1,!1,!1,!0,!1,!0,!0,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!0,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1],e.idStartLargeRegex=/^[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]$/,e.idStartBool=[!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!0,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!1,!1,!1,!1,!0,!1,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!1,!1,!1,!1,!1],e.idContinueLargeRegex=/^[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]$/,e.idContinueBool=[!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!0,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!1,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!1,!1,!1,!1,!1,!1,!1,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!1,!1,!1,!1,!0,!1,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!0,!1,!1,!1,!1,!1]}}),a=t({"node_modules/shift-parser/src/utils.js"(e){var{whitespaceArray:t,whitespaceBool:r,idStartLargeRegex:o,idStartBool:n,idContinueLargeRegex:i,idContinueBool:s}=u(),a=["null","true","false","implements","interface","package","private","protected","public","static","let","if","in","do","var","for","new","try","this","else","case","void","with","enum","while","break","catch","throw","const","yield","class","super","return","typeof","delete","switch","export","import","default","finally","extends","function","continue","debugger","instanceof"];e.isStrictModeReservedWord=e=>-1!==a.indexOf(e),e.isWhiteSpace=e=>e<128?r[e]:160===e||e>5759&&-1!==t.indexOf(e),e.isLineTerminator=e=>10===e||13===e||8232===e||8233===e,e.isIdentifierStart=e=>e<128?n[e]:o.test(String.fromCodePoint(e)),e.isIdentifierPart=e=>e<128?s[e]:i.test(String.fromCodePoint(e)),e.isDecimalDigit=e=>e>=48&&e<=57,e.getHexValue=e=>e>="0"&&e<="9"?e.charCodeAt(0)-48:e>="a"&&e<="f"?e.charCodeAt(0)-87:e>="A"&&e<="F"?e.charCodeAt(0)-55:-1}}),c=t({"node_modules/shift-fuzzer/src/unicode.js"(e,t){var{isIdentifierStart:r,isIdentifierPart:o}=a(),{IDENTIFIER_START:n,IDENTIFIER_CONTINUE:i}=(()=>{let e=[],t=[];for(let n=0;n<=1048576;n++)r(n)&&e.push(String.fromCodePoint(n)),o(n)&&t.push(String.fromCodePoint(n));return{IDENTIFIER_START:e,IDENTIFIER_CONTINUE:t}})();t.exports={IDENTIFIER_START:n,IDENTIFIER_CONTINUE:i}}}),p=t({"node_modules/shift-fuzzer/src/regexp.js"(e,t){var r=n(),{choose:o,many:u,oneOf:a}=s(),{IDENTIFIER_START:p,IDENTIFIER_CONTINUE:l}=c(),{FuzzerState:g}=i(),y=class{constructor(){this.noNumericLookahead=!1,this.maxGroupSecifier=0}},D=class{constructor({maxDepth:e=5,rng:t=new r(Math.random),unicode:o=!1,requireQuantifiable:n=!1,inClass:i=!1,maxNumber:s=1e5,globalState:u=new y}){this.maxDepth=e,this.depth=0,this.rng=t,this.unicode=o,this.requireQuantifiable=n,this.inClass=i,this.maxNumber=s,this.globalState=u}tooDeep(){return this.depth>=this.maxDepth}clone(){let e=new D({maxDepth:this.maxDepth,rng:this.rng,unicode:this.unicode,requireQuantifiable:this.requireQuantifiable,inClass:this.inClass,maxNumber:this.maxNumber,globalState:this.globalState});return e.depth=this.depth,e}goDeeper(){let e=this.clone();return++e.depth,e}},d=e=>{if("\\"!==e[0])return e.codePointAt(0);switch(e[1]){case"u":let t=e.indexOf("\\u",2);if(-1===t){let t="{"===e[2]?1:0;return parseInt(e.slice(2+t,e.length-t),16)}{let r=65536;return r+=(1023&parseInt(e.slice(2,t),16))<<10,r+=1023&parseInt(e.slice(t+2,e.length),16),r}case"x":return parseInt(e.slice(2),16);case"0":case"1":case"2":case"3":case"4":case"5":case"6":case"7":return parseInt(e.slice(1),8);case"b":return 8;case"t":return 9;case"n":return 10;case"v":return 11;case"f":return 12;case"r":return 13;case"c":throw new Error("control sequences not supported");default:return e.codePointAt(1)}},m=e=>{let t=32+e.rng.nextInt(94);for(;47===t;)t=32+e.rng.nextInt(94);return String.fromCharCode(t)},h=(e,t)=>a(..."01234567890abcdefABCDEF".split("").filter((e=>-1===t.indexOf(e))))(e),f=a("0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f","A","B","C","D","E","F"),E=["0","1","2","3","4","5","6","7","8","9"],w="^$\\.*+?()[{|".split(""),A="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".split(""),F=E.slice(0,8),x=["d","D","s","S","w","W","f","n","r","t","v","u","x","b","B","c","1","2","3","4","5","6","7","8","9","0"],C=e=>{let t=e.rng.nextInt(9)+1;return e.globalState.maxGroupSecifier=Math.max(e.globalState.maxGroupSecifier,t),`\\${t}`},b=e=>{let t=[e=>`\\${a("d","D","s","S","w","W")(e)}`,e=>`\\${a("f","n","r","t","v")(e)}`,e=>`\\c${a(...A)(e)}`,e=>`\\x${f(e)}${f(e)}`,e=>{let t=[];if(e.unicode){let e=null;t.push((t=>`\\u{${e=f(t)}${"d"===e||"D"===e?h(t,"89abcdefABCDEF".split("")):f(t)}${f(t)}${f(t)}}`),(t=>`\\u${e=f(t)}${"d"===e||"D"===e?h(t,"89abcdefABCDEF".split("")):f(t)}${f(t)}${f(t)}`),(e=>`\\u{${h(e,["0"])}${f(e)}${f(e)}${f(e)}${f(e)}}`),(e=>`\\u{10${f(e)}${f(e)}${f(e)}${f(e)}}`),(e=>`\\u${a("d","D")(e)}${a("8","9","A","B","a","b")(e)}${f(e)}${f(e)}\\u${a("d","D")(e)}${a("C","D","E","F","c","d","e","f")(e)}${f(e)}${f(e)}`))}else t.push((e=>`\\u${f(e)}${f(e)}${f(e)}${f(e)}`));return o(...t)(e)},e=>"\\0"];return e.unicode||t.push((e=>`\\${o(a(...F),(e=>`${a(...F.slice(0,4))(e)}${a(...F)(e)}${o((e=>""),a(...F))(e)}`),(e=>`${a(...F.slice(4))(e)}${a(...F)(e)}`))(e)}`),(e=>{let t;do{t=m(e)}while(-1!==x.indexOf(t));return`\\${t}`})),o(...t)(e)},B=e=>t=>{let r;do{r=m(t)}while(-1!==e.indexOf(r));return r},T=e=>B(e.unicode?"^$\\.*+?()[]{}|":w)(e),S=e=>{if(e.tooDeep())return"()";(e=e.goDeeper()).globalState.noNumericLookahead=!1;let t=`(?:${q(e)})`;return e.globalState.noNumericLookahead=!1,t},k=e=>t=>{if(t.tooDeep())return"()";(t=t.goDeeper()).globalState.noNumericLookahead=!1;let r=`(${a(...e)(t)}${q(t)})`;return t.globalState.noNumericLookahead=!1,r},j=(e,t)=>r=>{let o;do{o=e(r)}while(t(o));return o},v=(e,t)=>{let r=e.unicode?E:F,o=j(t,(e=>-1!==r.indexOf(e.charAt(0))));return e=>{let n;if(n=e.globalState.noNumericLookahead?o(e):t(e),n.length>0){let t=n.lastIndexOf("\\");e.globalState.noNumericLookahead=t>=0&&r.indexOf(n[t+1])>=0}return n}},O=e=>{if(e.tooDeep())return"";e=e.goDeeper();let t=[T,b,z,S];return e.unicode&&t.push(C),o(...t)(e)},I=e=>{if(e.tooDeep())return"";e=e.goDeeper();let t=[B(["\\","]","-"]),e=>`\\${a(...w)(e)}`,b];return e.unicode?t.push((e=>"\\-")):t.push((e=>`\\c${a(...E,"_")(e)}`)),o(...t)(e)},z=e=>{if(e.tooDeep())return"[]";(e=e.goDeeper()).globalState.noNumericLookahead=!1;let t=!0,r=M(!0),n=M(!1),i=!1,s=u((e=>{let s=!1,u=v(e,j(o((e=>(s=!1,t?(e=>o((e=>"-"),I)(e))(e):I(e))),(e=>(s=!0,t?r(e):n(e)))),(e=>!i&&e.startsWith("^"))))(e);return t=s,i=!0,u}))(e).join("");return e.globalState.noNumericLookahead=!1,`[${a("^","")(e)}${s}${a("-","")(e)}]`},P=["\\c"],N=["\\d","\\D","\\w","\\W","\\s","\\S","\\c"],M=e=>e=>{let t=e.unicode?N:P,r=j(I,(e=>0==e.length||t.filter((t=>e.startsWith(t))).length>0))(e),o=j(I,(e=>0==e.length||t.filter((t=>e.startsWith(t))).length>0))(e);return d(r)>d(o)&&([r,o]=[o,r]),`${r}-${o}`},L=e=>o((e=>`{${e.rng.nextInt(e.maxNumber)}${a(",","")(e)}}`),(e=>{let t,r=e.rng.nextInt(e.maxNumber);return t=r+e.rng.nextInt(e.maxNumber-r),`{${r},${t}}`}))(e),$=e=>t=>t.tooDeep()||(t=t.goDeeper()).tooDeep()?"":`${e(t)}${(e=>`${o(a("?","+","*"),L)(e)}${a("","?")(e)}`)(t)}`,W=["?=","?!"],V=e=>o(a("^","$","\\b","\\B"),(e=>k(W)(e)))(e),G=e=>e.unicode?(e=>o(V,O,$(O))(e))(e):(e=>o($(k(W)),V,O,$(O))(e))(e),R=e=>u(v(e,G))(e).join(""),Y=e=>e.tooDeep()?"":(e=e.goDeeper(),u(R)(e).join("|")),q=e=>e.tooDeep()?"":(e=e.goDeeper(),o(R,Y)(e));t.exports=function(e=new g,t=!1){let r=new D({rng:e.rng,unicode:t}),o=q(r);for(let e=0;e<r.globalState.maxGroupSecifier;++e)o+="()";return""===o?"(?:)":o}}}),l=t({"node_modules/shift-fuzzer/src/index.js"(e,t){var r=o(),u=i(),{ap:a,choose:c,guardDepth:l,many:g,many1:y,manyN:D,oneOf:d,opt:m,MANY_BOUND:h}=s(),f=p(),E=(n(),["break","case","catch","class","const","continue","debugger","default","delete","do","else","export","extends","finally","for","function","if","import","in","instanceof","new","return","super","switch","this","throw","try","typeof","var","void","while","with","null","true","false","enum"]),w=["implements","package","protected","interface","private","public","static"],A=E.concat(w).concat(["let","yield","await","eval","arguments","constructor","prototype"]);function F(e){return String.fromCharCode(97+e.rng.nextInt(25))}var x=F,C=e=>F(e)+D(15)(x)(e).join(""),b=(e,t)=>{let r=["async"],o=[...E];return e.strict?o.push(...w,"let","yield"):(r.push(...w),("let"===e.declKind||"const"===e.declKind?o:r).push("let"),(e.allowYieldIdentifier?r:o).push("yield")),(e.strict&&t?o:r).push("eval","arguments"),(e.allowAwaitIdentifier?r:o).push("await"),B(e,r,o)},B=(e=new u,t=[],r=E)=>{if(t.length>0&&e.rng.nextBoolean())return d(...t)(e);for(;;){let t=C(e);if(r.indexOf(t)<0)return t}},T=c(C,d(...A)),S=(d(..."0123456789abcdefABCDEF"),e=>e.rng.nextString()),k=(e,t)=>{let r;do{r=t,t=t.replace(/((^|[^\\])(\\\\)*\\)(8|9|u|x|$)/g,"$1\\$4"),e.strict&&(t=(t=t.replace(/((^|[^\\])(\\\\)*\\)0([0-9])/g,"$1\\0$4")).replace(/((^|[^\\])(\\\\)*\\)([1-9])/g,"$1\\$4"))}while(t!==r);return t},j=e=>a(r.ArrayAssignmentTarget,{elements:g(m(c(L,jt))),rest:m(jt)},e),v=e=>a(r.ArrayBinding,{elements:g(m(c(R,vt))),rest:m(vt)},e),O=e=>a(r.ArrayExpression,{elements:g(m(c(It,He)))},e),I=(e=new u)=>{let t,o,n=e.rng.nextBoolean(),i=e.rng.nextBoolean(),s=!e.allowAwaitIdentifier;if(i){let r=(e=e.enterFunction({isArrow:!0,isAsync:n})).allowAwaitIdentifier;s&&(e.allowAwaitIdentifier=!1),t=Fe(e),s&&(e.allowAwaitIdentifier=r),o=It(e)}else{let{directives:i,hasStrictDirective:u}=kt(e),a=(e=e.enterFunction({isArrow:!0,isAsync:n,hasStrictDirective:u})).allowAwaitIdentifier;s&&(e.allowAwaitIdentifier=!1),t=Fe(e,{hasStrictDirective:u}),s&&(e.allowAwaitIdentifier=a),o=new r.FunctionBody({directives:i,statements:g(Pt)(e.goDeeper())})}return new r.ArrowExpression({isAsync:n,params:t,body:o})},z=e=>a(r.AssignmentExpression,{binding:jt,expression:It},e),P=e=>a(r.AssignmentTargetIdentifier,{name:e=>b(e,!0)},e),N=e=>a(r.AssignmentTargetPropertyIdentifier,{binding:P,init:m(It)},e),M=e=>a(r.AssignmentTargetPropertyProperty,{name:c(te,Ze),binding:c(L,jt)},e),L=e=>a(r.AssignmentTargetWithDefault,{binding:jt,init:It},e),$=e=>a(r.BinaryExpression,{left:It,operator:d("==","!=","===","!==","<","<=",">",">=","in","instanceof","<<",">>",">>>","+","-","*","/","%","**",",","||","&&","|","^","&"),right:It},e),W=e=>a(r.BindingIdentifier,{name:e=>b(e,!0)},e),V=e=>a(r.BindingPropertyIdentifier,{binding:W,init:m(It)},e),G=e=>a(r.BindingPropertyProperty,{name:c(te,Ze),binding:c(R,vt)},e),R=e=>a(r.BindingWithDefault,{binding:vt,init:It},e),Y=e=>a(r.Block,{statements:g(Pt)},e),q=e=>a(r.BlockStatement,{block:Y},e),U=e=>a(r.BreakStatement,{label:e=>e.labels.length>0&&(!e.inLoop&&!e.inSwitch||e.rng.nextBoolean())?d(...e.labels)(e):null},e),_=e=>a(r.CallExpression,{callee:Tt,arguments:g(c(It,He))},e),K=e=>a(r.CatchClause,{binding:m(vt),body:Y},e),H=(e=new u)=>{(e=e.goDeeper()).inLoop=e.inSwitch=!1,e.strict=!0;let t=W(e),o=m(It)(e),n=St(e,{allowConstructor:null!==o});return new r.ClassDeclaration({name:t,super:o,elements:n})},Q=(e=new u,{allowConstructor:t=!0,constructorMayContainSuperCall:o=!1}={})=>{let n=(e=e.goDeeper()).rng.nextBoolean(),i=c((e=>be(e,{isStatic:n,inClass:!0})),(e=>Le(e,{isStatic:n,inClass:!0,allowConstructor:t,constructorMayContainSuperCall:o})),(e=>_e(e,{isStatic:n,inClass:!0})))(e);return new r.ClassElement({isStatic:n,method:i})},J=(e=new u)=>{(e=e.goDeeper()).inLoop=e.inSwitch=!1,e.strict=!0;let t=m(W)(e),o=m(It)(e),n=St(e,{allowConstructor:null!==o});return new r.ClassExpression({name:t,super:o,elements:n})},X=e=>a(r.CompoundAssignmentExpression,{binding:c(P,c(Z,Je)),operator:d("+=","-=","*=","/=","%=","**=","<<=",">>=",">>>=","|=","^=","&="),expression:It},e),Z=e=>a(r.ComputedMemberAssignmentTarget,{object:Bt,expression:It},e),ee=e=>a(r.ComputedMemberExpression,{object:Bt,expression:It},e),te=e=>a(r.ComputedPropertyName,{expression:It},e),re=e=>a(r.ConditionalExpression,{test:It,consequent:It,alternate:It},e),oe=e=>a(r.ContinueStatement,{label:e=>e.loopLabels.length>0&&e.rng.nextBoolean()?d(...e.loopLabels)(e):null},e),ne=e=>a(r.DataProperty,{name:c(te,Ze),expression:It},e),ie=e=>a(r.DebuggerStatement,{},e),se=(e=new u,{allowUseStrict:t=!0}={})=>{let o,n=t&&e.rng.nextBoolean()?"use strict":S(e);if(n.match('"')&&n.match("'")){let t,r=e.rng.nextBoolean()?'"':"'",o='"'===r?/((^|[^\\])(\\\\)*)"/g:/((^|[^\\])(\\\\)*)'/g;do{t=n,n=n.replace(o,`$1\\${r}`)}while(n!==t)}do{o=n,n=n.replace(/((^|[^\\])(\\\\)*)([\r\n])/g,"$1\\$4")}while(n!==o);return n=k(e,n),t||"use strict"!==n||(n=""),new r.Directive({rawValue:n})},ue=e=>a(r.DoWhileStatement,{body:e=>Pt(e.enterLoop(),{allowProperDeclarations:!1,allowFunctionDeclarations:!1}),test:It},e),ae=e=>a(r.EmptyStatement,{},e),ce=e=>a(r.Export,{declaration:c(H,xe,yt)},e),pe=e=>a(r.ExportAllFrom,{moduleSpecifier:S},e),le=e=>a(r.ExportDefault,{body:c(H,It,xe)},e),ge=e=>a(r.ExportFrom,{namedExports:g(ye),moduleSpecifier:S},e),ye=e=>a(r.ExportFromSpecifier,{name:T,exportedName:m(T)},e),De=e=>a(r.ExportLocalSpecifier,{name:Be,exportedName:m(T)},e),de=e=>a(r.ExportLocals,{namedExports:g(De)},e),me=e=>a(r.ExpressionStatement,{expression:It},e),he=(e=new u)=>{let t=(e=e.goDeeper()).rng.nextBoolean()?yt(e,{inForInOfHead:!0}):jt(e),o=It(e),n=Pt(e.enterLoop(),{allowProperDeclarations:!1,allowFunctionDeclarations:!1});return new r.ForInStatement({left:t,right:o,body:n})};function fe(e){let t=(e=e.goDeeper()).rng.nextBoolean()?yt(e,{inForInOfHead:!0}):jt(e);return"AssignmentTargetIdentifier"===t.type&&"async"===t.name&&(t.name="_async"),{left:t,right:It(e),body:Pt(e.enterLoop(),{allowProperDeclarations:!1,allowFunctionDeclarations:!1})}}var Ee=(e=new u)=>new r.ForOfStatement(fe(e)),we=(e=new u)=>new r.ForAwaitStatement(fe(e)),Ae=e=>a(r.ForStatement,{init:m(c(It,yt)),test:m(It),update:m(It),body:e=>Pt(e.enterLoop(),{allowProperDeclarations:!1,allowFunctionDeclarations:!1})},e),Fe=(e=new u,{hasStrictDirective:t=!1}={})=>{if(t)return new r.FormalParameters({items:g(W)(e),rest:null});e=e.goDeeper().disableYieldExpr().disableAwaitExpr();let o=g(c(R,vt))(e),n=m(vt)(e);return new r.FormalParameters({items:o,rest:n})},xe=(e=new u,{allowProperDeclarations:t=!0}={})=>{let{directives:o,hasStrictDirective:n}=kt(e),i=!1,s=!1;if(t){let t=e.rng.nextInt(3);0===t?(i=!0,e.allowYieldIdentifier=!1):1===t&&(s=!0,e.allowAwaitIdentifier=!1)}let a=W(e);e=e.enterFunction({isGenerator:i,isAsync:s,hasStrictDirective:n});let c=Fe(e,{hasStrictDirective:n}),p=new r.FunctionBody({directives:o,statements:g(Pt)(e.goDeeper())});return new r.FunctionDeclaration({isGenerator:i,isAsync:s,name:a,params:c,body:p})},Ce=(e=new u)=>{e=e.clone();let{directives:t,hasStrictDirective:o}=kt(e),n=!1,i=!1,s=e.rng.nextInt(3);0===s?(n=!0,e.allowYieldIdentifier=!1):1===s&&(i=!0,e.allowAwaitIdentifier=!1);let a=e.rng.nextBoolean()?W(e):null;e=e.enterFunction({isGenerator:n,isAsync:i,hasStrictDirective:o});let c=Fe(e,{hasStrictDirective:o}),p=new r.FunctionBody({directives:t,statements:g(Pt)(e.goDeeper())});return new r.FunctionExpression({isGenerator:n,isAsync:i,name:a,params:c,body:p})},be=(e=new u,{isStatic:t=!1,inClass:o=!1}={})=>{let{directives:n,hasStrictDirective:i}=kt(e),s=e.rng.nextBoolean?te(e):Ze(e,{allowConstructor:!o,allowPrototype:!t});(e=e.enterFunction({isMethod:!0,hasStrictDirective:i})).allowSuperCall=!1,e.allowSuperProp=!0;let a=new r.FunctionBody({directives:n,statements:g(Pt)(e.goDeeper())});return new r.Getter({name:s,body:a})},Be=e=>a(r.IdentifierExpression,{name:e=>b(e,!1)},e),Te=(e=new u)=>{e=e.goDeeper();let t=It(e),o=!e.allowMissingElse||e.rng.nextBoolean()?Pt(e,{allowProperDeclarations:!1,allowFunctionDeclarations:!e.strict,allowLabeledFunctionDeclarations:!1}):null;o&&(e.allowMissingElse=!1);let n=Pt(e,{allowProperDeclarations:!1,allowFunctionDeclarations:!e.strict,allowLabeledFunctionDeclarations:!1});return new r.IfStatement({test:t,consequent:n,alternate:o})},Se=e=>a(r.Import,{defaultBinding:m(W),namedImports:g(je),moduleSpecifier:S},e),ke=e=>a(r.ImportNamespace,{defaultBinding:m(W),namespaceBinding:W,moduleSpecifier:S},e),je=e=>a(r.ImportSpecifier,{name:m(T),binding:W},e),ve=(e=new u,{allowFunctionDeclarations:t=e.strict}={})=>{let o,n=(e=>{let t=["eval","arguments","async"],r=[...E,...e.labels];return e.strict?r.push(...w,"let","yield"):(t.push(...w,"let"),(e.allowYieldIdentifier?t:r).push("yield")),(e.allowAwaitIdentifier?t:r).push("await"),e.labels.forEach((e=>{let r=t.indexOf(e);-1!==r&&t.splice(r,1)})),B(e,t,r)})(e=e.goDeeper());return e.labels=e.labels.concat([n]),e.rng.nextBoolean()?(e.loopLabels=e.loopLabels.concat([n]),o=c(...Ct)(e)):o=Pt(e,{allowLoops:!1,allowProperDeclarations:!1,allowFunctionDeclarations:t}),new r.LabeledStatement({label:n,body:o})},Oe=e=>a(r.LiteralBooleanExpression,{value:e=>e.rng.nextBoolean()},e),Ie=e=>a(r.LiteralInfinityExpression,{},e),ze=e=>a(r.LiteralNullExpression,{},e),Pe=e=>a(r.LiteralNumericExpression,{value:c((e=>e.rng.nextInt(1e4)),(e=>e.rng.nextInt(Math.pow(2,53))),(e=>e.rng.nextDouble()*Math.pow(10,e.rng.nextInt(309))),(e=>parseFloat((""+1e4*e.rng.nextDouble()).slice(0,7))),(e=>parseFloat((""+e.rng.nextDouble()).slice(0,4))),(e=>0))},e),Ne=(e=new u,t=!0)=>{let o=t&&e.rng.nextBoolean();return a(r.LiteralRegExpExpression,{pattern:e=>f(e,o),global:e=>e.rng.nextBoolean(),ignoreCase:e=>e.rng.nextBoolean(),multiLine:e=>e.rng.nextBoolean(),dotAll:e=>e.rng.nextBoolean(),unicode:e=>o,sticky:e=>e.rng.nextBoolean()},e)},Me=e=>a(r.LiteralStringExpression,{value:S},e),Le=(e=new u,{isStatic:t=!1,inClass:o=!1,allowConstructor:n=!0,constructorMayContainSuperCall:i=!1}={})=>{e=e.goDeeper();let{directives:s,hasStrictDirective:a}=kt(e),p=o&&n&&!t&&e.rng.nextBoolean(),l=!1,y=!1;if(!p){let t=e.rng.nextInt(3);0==t?(l=!0,e.allowYieldIdentifier=!1):1===t&&(y=!0,e.allowAwaitIdentifier=!1)}let D=p?new r.StaticPropertyName({value:"constructor"}):c(te,(e=>Ze(e,{allowConstructor:!o,allowPrototype:!t})))(e);(e=e.enterFunction({isMethod:!0,isAsync:y,isGenerator:l,hasStrictDirective:a})).allowSuperCall=p&&i,e.allowSuperProp=!0;let d=Fe(e,{hasStrictDirective:a}),m=new r.FunctionBody({directives:s,statements:g(Pt)(e.goDeeper())});return new r.Method({isGenerator:l,isAsync:y,name:D,params:d,body:m})},$e=(e=new u)=>((e=e.clone()).strict=!0,e.allowAwaitIdentifier=!1,e.isModule=!0,a(r.Module,{directives:e=>kt(e).directives,items:g(c(c(ce,pe,le,ge,de),c(Se,ke),Pt))},e)),We=e=>a(r.NewExpression,{callee:It,arguments:g(c(It,He))},e),Ve=e=>a(r.NewTargetExpression,{},e),Ge=e=>a(r.ObjectAssignmentTarget,{properties:g(c(N,M)),rest:m(c(P,c(Z,Je)))},e),Re=e=>a(r.ObjectBinding,{properties:g(c(V,G)),rest:m(W)},e),Ye=e=>a(r.ObjectExpression,{properties:g(c(c(ne,c(be,Le,_e)),Ke,Qe))},e),qe=e=>a(r.ReturnStatement,{expression:m(It)},e),Ue=(e=new u)=>{e=e.goDeeper();let{directives:t,hasStrictDirective:o}=kt(e);return e.strict=o,new r.Script({directives:t,statements:g(Pt)(e)})},_e=(e=new u,{isStatic:t=!1,inClass:o=!1}={})=>{let{directives:n,hasStrictDirective:i}=kt(e),s=e.rng.nextBoolean?te(e):Ze(e,{allowConstructor:!o,allowPrototype:!t});(e=e.enterFunction({isMethod:!0,hasStrictDirective:i})).allowSuperCall=!1,e.allowSuperProp=!0;let a=i?W(e):c(R,vt)(e),p=new r.FunctionBody({directives:n,statements:g(Pt)(e.goDeeper())});return new r.Setter({name:s,param:a,body:p})},Ke=e=>a(r.ShorthandProperty,{name:Be},e),He=e=>a(r.SpreadElement,{expression:It},e),Qe=e=>a(r.SpreadProperty,{expression:It},e),Je=e=>a(r.StaticMemberAssignmentTarget,{object:Bt,property:T},e),Xe=e=>a(r.StaticMemberExpression,{object:Bt,property:T},e),Ze=(e=new u,{allowConstructor:t=!0,allowPrototype:o=!0}={})=>{let n;do{n=S(e)}while(!t&&"constructor"===n||!o&&"prototype"===n);return new r.StaticPropertyName({value:n})},et=e=>a(r.Super,{},e),tt=e=>a(r.SwitchCase,{test:It,consequent:g(Pt)},e),rt=e=>a(r.SwitchDefault,{consequent:g(Pt)},e),ot=e=>a(r.SwitchStatement,{discriminant:It,cases:g(tt)},e.enterSwitch()),nt=e=>a(r.SwitchStatementWithDefault,{discriminant:It,preDefaultCases:g(tt),defaultCase:rt,postDefaultCases:g(tt)},e.enterSwitch()),it=(e=new u)=>{let t,o=k(e,S(e));do{t=o,o=o.replace(/((^|[^\\])(\\\\)*)(`|\${)/g,"$1\\$4"),o=o.replace(/((^|[^\\])(\\\\)*\\)(0(?=[0-7])|[1-7])/g,"$1\\$4")}while(o!==t);return new r.TemplateElement({rawValue:o})},st=(e=new u)=>{e=e.goDeeper();let t=m(It)(e),o=g(It)(e),n=[it(e)];for(let t=0;t<o.length;++t)n.push(o[t],it(e));return new r.TemplateExpression({tag:t,elements:n})},ut=e=>a(r.ThisExpression,{},e),at=e=>a(r.ThrowStatement,{expression:It},e),ct=e=>a(r.TryCatchStatement,{body:Y,catchClause:K},e),pt=e=>a(r.TryFinallyStatement,{body:Y,catchClause:m(K),finalizer:Y},e),lt=(e=new u)=>{e=e.goDeeper();let t=d("+","-","!","~","typeof","void","delete")(e),o=It(e,{allowIdentifierExpression:"delete"!==t||!e.strict});return new r.UnaryExpression({operator:t,operand:o})},gt=e=>a(r.UpdateExpression,{isPrefix:e=>e.rng.nextBoolean(),operator:d("++","--"),operand:c(P,c(Z,Je))},e),yt=(e=new u,{allowProperDeclarations:t=!0,inForInOfHead:o=!1}={})=>{e=e.goDeeper();let n,i=t?d("var","let","const")(e):"var";return e.declKind=i,n=o?[dt(e,{inForInOfHead:o})]:y(dt)(e),new r.VariableDeclaration({kind:i,declarators:n})},Dt=(e=new u,{allowProperDeclarations:t=!0}={})=>{e=e.goDeeper();let o=yt(e,{allowProperDeclarations:t});return new r.VariableDeclarationStatement({declaration:o})},dt=(e=new u,{inForInOfHead:t=!1}={})=>{e=e.goDeeper();let o,n=vt(e);return o=t?null:"const"===e.declKind||"ArrayBinding"===n.type||"ObjectBinding"===n.type||e.rng.nextBoolean()?It(e):null,new r.VariableDeclarator({binding:n,init:o})},mt=e=>a(r.WhileStatement,{test:It,body:e=>Pt(e.enterLoop(),{allowProperDeclarations:!1,allowFunctionDeclarations:!1})},e),ht=e=>a(r.WithStatement,{object:It,body:e=>Pt(e,{allowProperDeclarations:!1,allowFunctionDeclarations:!1})},e),ft=e=>a(r.YieldExpression,{expression:m(It)},e),Et=e=>a(r.AwaitExpression,{expression:It},e),wt=e=>a(r.YieldGeneratorExpression,{expression:It},e),At=[O,I,z,$,_,J,X,re,Ce,Oe,Ie,ze,Pe,Ne,Me,We,Ye,st,ut,lt,gt,ee,Xe],Ft=[ft,wt],xt=[q,ie,ae,me,Te,ve,ot,nt,at,ct,pt,Dt],Ct=[ue,he,Ee,Ae,mt],bt=[ve,Ae,he,Ee,Te,mt,ht],Bt=e=>e.allowSuperProp?c(It,et)(e):It(e),Tt=e=>e.allowSuperCall?c(It,et)(e):It(e),St=(e,{allowConstructor:t})=>{let r=[];if(e.tooDeep())return r;let o=e.rng.nextInt(h+1);for(;o-- >0;){let o=Q(e,{allowConstructor:t,constructorMayContainSuperCall:!0});o.isStatic||"Method"!==o.method.type||"StaticPropertyName"!==o.method.name.type||"constructor"!==o.method.name.value||(t=!1),r.push(o)}return r},kt=e=>{let t=(e=e.clone()).rng.nextBoolean();t&&(e.strict=!0);let o=g((e=>se(e,{allowUseStrict:t})))(e);return t&&!o.some((e=>"use strict"===e.rawValue))&&o.push(new r.Directive({rawValue:"use strict"})),{directives:o,hasStrictDirective:t}},jt=e=>e.tooDeep()||e.rng.nextBoolean()?P(e):c(c(j,Ge),c(Z,Je))(e),vt=e=>e.tooDeep()||e.rng.nextBoolean()?W(e):(e.rng.nextBoolean()?v:Re)(e),Ot=c($e,Ue),It=(e=new u,{allowIdentifierExpression:t=!0}={})=>{if(e.tooDeep())return zt(e,{allowIdentifierExpression:t});let r=At;return e.allowYieldExpr&&(r=r.concat(Ft)),e.allowAwaitExpr&&(r=r.concat([Et])),e.allowNewTarget&&(r=r.concat([Ve])),t&&(r=r.concat([Be])),(e=e.clone()).declKind=null,c(...r)(e)},zt=(e,{allowIdentifierExpression:t})=>{let r=[Oe,Ie,ze,Pe,Ne,Me,ut];return t&&r.push(Be),e.allowNewTarget&&r.push(Ve),e.allowYieldExpr&&r.push(ft),c(...r)(e)},Pt=(e=new u,{allowLoops:t=!0,allowProperDeclarations:r=!0,allowFunctionDeclarations:o=!0,allowLabeledFunctionDeclarations:n=!e.strict&&o}={})=>{if(e.tooDeep())return Nt(e);let i=[...xt];t&&i.push(...Ct),e.allowReturn&&i.push(qe),e.allowAwaitExpr&&i.push(we),e.inLoop?i.push(U,oe):e.allowBreak()&&i.push(U),r?i.push(H,xe):o&&i.push(xe),e.strict||i.push(ht);let s=d(...i)(e);return-1===bt.indexOf(s)&&(e=e.enableMissingElse()),s===Dt?Dt(e,{allowProperDeclarations:r}):s===xe?xe(e,{allowProperDeclarations:r}):s===ve?ve(e,{allowFunctionDeclarations:n}):s(e)},Nt=e=>{let t=[ie,ae];return e.allowBreak()&&t.push(U),e.inLoop&&t.push(oe),e.allowReturn&&t.push(qe),c(...t)(e)};t.exports={default:Ot,FuzzerState:u,fuzzIdentifier:B,fuzzArrayAssignmentTarget:j,fuzzArrayBinding:v,fuzzArrayExpression:O,fuzzArrowExpression:I,fuzzAssignmentExpression:z,fuzzAssignmentTargetIdentifier:P,fuzzAssignmentTargetPropertyIdentifier:N,fuzzAssignmentTargetPropertyProperty:M,fuzzAssignmentTargetWithDefault:L,fuzzBinaryExpression:$,fuzzBindingIdentifier:W,fuzzBindingPropertyIdentifier:V,fuzzBindingWithDefault:R,fuzzBlock:Y,fuzzBlockStatement:q,fuzzBreakStatement:U,fuzzCallExpression:_,fuzzCatchClause:K,fuzzClassDeclaration:H,fuzzClassElement:Q,fuzzClassExpression:J,fuzzCompoundAssignmentExpression:X,fuzzComputedMemberAssignmentTarget:Z,fuzzComputedMemberExpression:ee,fuzzComputedPropertyName:te,fuzzConditionalExpression:re,fuzzContinueStatement:oe,fuzzDataProperty:ne,fuzzDebuggerStatement:ie,fuzzDirective:se,fuzzDoWhileStatement:ue,fuzzEmptyStatement:ae,fuzzExport:ce,fuzzExportAllFrom:pe,fuzzExportDefault:le,fuzzExportFrom:ge,fuzzExportFromSpecifier:ye,fuzzExportLocalSpecifier:De,fuzzExportLocals:de,fuzzExpressionStatement:me,fuzzForInStatement:he,fuzzForOfStatement:Ee,fuzzForAwaitStatement:we,fuzzForStatement:Ae,fuzzFormalParameters:Fe,fuzzFunctionBody:e=>a(r.FunctionBody,{directives:kt(e).directives,statements:g(Pt)},e),fuzzFunctionDeclaration:xe,fuzzFunctionExpression:Ce,fuzzGetter:be,fuzzIdentifierExpression:Be,fuzzIfStatement:Te,fuzzImport:Se,fuzzImportNamespace:ke,fuzzImportSpecifier:je,fuzzLabeledStatement:ve,fuzzLiteralBooleanExpression:Oe,fuzzLiteralInfinityExpression:Ie,fuzzLiteralNullExpression:ze,fuzzLiteralNumericExpression:Pe,fuzzLiteralRegExpExpression:Ne,fuzzLiteralStringExpression:Me,fuzzMethod:Le,fuzzModule:$e,fuzzNewExpression:We,fuzzNewTargetExpression:Ve,fuzzObjectAssignmentTarget:Ge,fuzzObjectBinding:Re,fuzzObjectExpression:Ye,fuzzReturnStatement:qe,fuzzScript:Ue,fuzzSetter:_e,fuzzShorthandProperty:Ke,fuzzSpreadElement:He,fuzzSpreadProperty:Qe,fuzzStaticMemberAssignmentTarget:Je,fuzzStaticMemberExpression:Xe,fuzzStaticPropertyName:Ze,fuzzSuper:et,fuzzSwitchCase:tt,fuzzSwitchDefault:rt,fuzzSwitchStatement:ot,fuzzSwitchStatementWithDefault:nt,fuzzTemplateElement:it,fuzzTemplateExpression:st,fuzzThisExpression:ut,fuzzThrowStatement:at,fuzzTryCatchStatement:ct,fuzzTryFinallyStatement:pt,fuzzUnaryExpression:lt,fuzzUpdateExpression:gt,fuzzVariableDeclaration:yt,fuzzVariableDeclarationStatement:Dt,fuzzVariableDeclarator:dt,fuzzWhileStatement:mt,fuzzWithStatement:ht,fuzzYieldExpression:ft,fuzzAwaitExpression:Et,fuzzYieldGeneratorExpression:wt,fuzzProgram:Ot,fuzzExpression:It,fuzzExpression:It,fuzzStatement:Pt}}});window.fuzzer=l()})();